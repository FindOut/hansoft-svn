class HPMUntranslatedString
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMUntranslatedString *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMUntranslatedString *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMUntranslatedString()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMUntranslatedString(HPMUntranslatedString const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMUntranslatedString(HPMUntranslatedString &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMUntranslatedString &operator =(HPMUntranslatedString const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMUntranslatedString &operator =(HPMUntranslatedString &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMUntranslatedString &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMUntranslatedString &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMUntranslatedString &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMUntranslatedString &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMUntranslatedString &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMUntranslatedString &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceDefinition
{
	public:
	EHPMResourceGroupingType m_GroupingType;
	HPMUniqueID m_ID;
	HPMResourceDefinition()
		: m_GroupingType(EHPMResourceGroupingType_Resource)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceDefinition(HPMResourceDefinition const &_Right)
		: m_GroupingType(_Right.m_GroupingType)
		, m_ID(_Right.m_ID)
	{
	}
	HPMResourceDefinition(HPMResourceDefinition &&_Right)
		: m_GroupingType(std::move(_Right.m_GroupingType))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMResourceDefinition &operator =(HPMResourceDefinition const &_Right)
	{
		m_GroupingType = _Right.m_GroupingType;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMResourceDefinition &operator =(HPMResourceDefinition &&_Right)
	{
		m_GroupingType = std::move(_Right.m_GroupingType);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMResourceDefinition &_Right) const
	{
		if (m_GroupingType != _Right.m_GroupingType)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMResourceDefinition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceDefinition &_Right) const
	{
		if (m_GroupingType < _Right.m_GroupingType)
			return true;
		if (m_GroupingType > _Right.m_GroupingType)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMResourceDefinition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceDefinition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceDefinition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceDefinitionList
{
	public:
	std::vector<HPMResourceDefinition> m_Resources;
	HPMResourceDefinitionList()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceDefinitionList(HPMResourceDefinitionList const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMResourceDefinitionList(HPMResourceDefinitionList &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMResourceDefinitionList &operator =(HPMResourceDefinitionList const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMResourceDefinitionList &operator =(HPMResourceDefinitionList &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMResourceDefinitionList &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMResourceDefinitionList &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceDefinitionList &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMResourceDefinitionList &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceDefinitionList &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceDefinitionList &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkPass
{
	public:
	HPMUInt32 m_Start;
	HPMUInt32 m_End;
	HPMWorkPass()
		: m_Start(0)
		, m_End(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkPass(HPMWorkPass const &_Right)
		: m_Start(_Right.m_Start)
		, m_End(_Right.m_End)
	{
	}
	HPMWorkPass(HPMWorkPass &&_Right)
		: m_Start(std::move(_Right.m_Start))
		, m_End(std::move(_Right.m_End))
	{
	}
	HPMWorkPass &operator =(HPMWorkPass const &_Right)
	{
		m_Start = _Right.m_Start;
		m_End = _Right.m_End;
		return *this;
	}
	HPMWorkPass &operator =(HPMWorkPass &&_Right)
	{
		m_Start = std::move(_Right.m_Start);
		m_End = std::move(_Right.m_End);
		return *this;
	}
#endif
	bool operator == (const HPMWorkPass &_Right) const
	{
		if (m_Start != _Right.m_Start)
			return false;
		if (m_End != _Right.m_End)
			return false;
		return true;
	}
	bool operator != (const HPMWorkPass &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkPass &_Right) const
	{
		if (m_Start < _Right.m_Start)
			return true;
		if (m_Start > _Right.m_Start)
			return false;
		if (m_End < _Right.m_End)
			return true;
		if (m_End > _Right.m_End)
			return false;
		return false;
	}
	bool operator > (const HPMWorkPass &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkPass &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkPass &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkDay
{
	public:
	std::vector<HPMWorkPass> m_WorkPasses;
	HPMWorkDay()
	{
		m_WorkPasses.resize(3);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkDay(HPMWorkDay const &_Right)
		: m_WorkPasses(_Right.m_WorkPasses)
	{
	}
	HPMWorkDay(HPMWorkDay &&_Right)
		: m_WorkPasses(std::move(_Right.m_WorkPasses))
	{
	}
	HPMWorkDay &operator =(HPMWorkDay const &_Right)
	{
		m_WorkPasses = _Right.m_WorkPasses;
		return *this;
	}
	HPMWorkDay &operator =(HPMWorkDay &&_Right)
	{
		m_WorkPasses = std::move(_Right.m_WorkPasses);
		return *this;
	}
#endif
	bool operator == (const HPMWorkDay &_Right) const
	{
		if (m_WorkPasses.size() != _Right.m_WorkPasses.size())
			return false;
		for (size_t i = 0; i < m_WorkPasses.size(); ++i)
			if (m_WorkPasses[i] != _Right.m_WorkPasses[i])
				return false;
		return true;
	}
	bool operator != (const HPMWorkDay &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkDay &_Right) const
	{
		if (m_WorkPasses.size() < _Right.m_WorkPasses.size())
			return true;
		if (m_WorkPasses.size() > _Right.m_WorkPasses.size())
			return false;
		for (size_t i = 0; i < m_WorkPasses.size(); ++i)
		{
			if (m_WorkPasses[i] < _Right.m_WorkPasses[i])
				return true;
			if (m_WorkPasses[i] > _Right.m_WorkPasses[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMWorkDay &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkDay &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkDay &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkingDays
{
	public:
	std::vector<bool> m_bWorkDay;
	HPMWorkingDays()
	{
		m_bWorkDay.resize(7, 1);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkingDays(HPMWorkingDays const &_Right)
		: m_bWorkDay(_Right.m_bWorkDay)
	{
	}
	HPMWorkingDays(HPMWorkingDays &&_Right)
		: m_bWorkDay(std::move(_Right.m_bWorkDay))
	{
	}
	HPMWorkingDays &operator =(HPMWorkingDays const &_Right)
	{
		m_bWorkDay = _Right.m_bWorkDay;
		return *this;
	}
	HPMWorkingDays &operator =(HPMWorkingDays &&_Right)
	{
		m_bWorkDay = std::move(_Right.m_bWorkDay);
		return *this;
	}
#endif
	bool operator == (const HPMWorkingDays &_Right) const
	{
		if (m_bWorkDay.size() != _Right.m_bWorkDay.size())
			return false;
		for (size_t i = 0; i < m_bWorkDay.size(); ++i)
			if (m_bWorkDay[i] != _Right.m_bWorkDay[i])
				return false;
		return true;
	}
	bool operator != (const HPMWorkingDays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkingDays &_Right) const
	{
		if (m_bWorkDay.size() < _Right.m_bWorkDay.size())
			return true;
		if (m_bWorkDay.size() > _Right.m_bWorkDay.size())
			return false;
		for (size_t i = 0; i < m_bWorkDay.size(); ++i)
		{
			if (m_bWorkDay[i] < _Right.m_bWorkDay[i])
				return true;
			if (m_bWorkDay[i] > _Right.m_bWorkDay[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMWorkingDays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkingDays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkingDays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomWorkDay
{
	public:
	HPMUInt64 m_Date;
	bool m_bWorkDay;
	HPMCustomWorkDay()
		: m_Date(0)
		, m_bWorkDay(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomWorkDay(HPMCustomWorkDay const &_Right)
		: m_Date(_Right.m_Date)
		, m_bWorkDay(_Right.m_bWorkDay)
	{
	}
	HPMCustomWorkDay(HPMCustomWorkDay &&_Right)
		: m_Date(std::move(_Right.m_Date))
		, m_bWorkDay(std::move(_Right.m_bWorkDay))
	{
	}
	HPMCustomWorkDay &operator =(HPMCustomWorkDay const &_Right)
	{
		m_Date = _Right.m_Date;
		m_bWorkDay = _Right.m_bWorkDay;
		return *this;
	}
	HPMCustomWorkDay &operator =(HPMCustomWorkDay &&_Right)
	{
		m_Date = std::move(_Right.m_Date);
		m_bWorkDay = std::move(_Right.m_bWorkDay);
		return *this;
	}
#endif
	bool operator == (const HPMCustomWorkDay &_Right) const
	{
		if (m_Date != _Right.m_Date)
			return false;
		if (m_bWorkDay != _Right.m_bWorkDay)
			return false;
		return true;
	}
	bool operator != (const HPMCustomWorkDay &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomWorkDay &_Right) const
	{
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_bWorkDay < _Right.m_bWorkDay)
			return true;
		if (m_bWorkDay > _Right.m_bWorkDay)
			return false;
		return false;
	}
	bool operator > (const HPMCustomWorkDay &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomWorkDay &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomWorkDay &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomWorkingDays
{
	public:
	std::vector<HPMCustomWorkDay> m_ChangedDays;
	HPMCustomWorkingDays()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomWorkingDays(HPMCustomWorkingDays const &_Right)
		: m_ChangedDays(_Right.m_ChangedDays)
	{
	}
	HPMCustomWorkingDays(HPMCustomWorkingDays &&_Right)
		: m_ChangedDays(std::move(_Right.m_ChangedDays))
	{
	}
	HPMCustomWorkingDays &operator =(HPMCustomWorkingDays const &_Right)
	{
		m_ChangedDays = _Right.m_ChangedDays;
		return *this;
	}
	HPMCustomWorkingDays &operator =(HPMCustomWorkingDays &&_Right)
	{
		m_ChangedDays = std::move(_Right.m_ChangedDays);
		return *this;
	}
#endif
	bool operator == (const HPMCustomWorkingDays &_Right) const
	{
		if (m_ChangedDays.size() != _Right.m_ChangedDays.size())
			return false;
		for (size_t i = 0; i < m_ChangedDays.size(); ++i)
			if (m_ChangedDays[i] != _Right.m_ChangedDays[i])
				return false;
		return true;
	}
	bool operator != (const HPMCustomWorkingDays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomWorkingDays &_Right) const
	{
		if (m_ChangedDays.size() < _Right.m_ChangedDays.size())
			return true;
		if (m_ChangedDays.size() > _Right.m_ChangedDays.size())
			return false;
		for (size_t i = 0; i < m_ChangedDays.size(); ++i)
		{
			if (m_ChangedDays[i] < _Right.m_ChangedDays[i])
				return true;
			if (m_ChangedDays[i] > _Right.m_ChangedDays[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCustomWorkingDays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomWorkingDays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomWorkingDays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomWorkHoursDay
{
	public:
	HPMUInt64 m_Date;
	std::vector<HPMWorkPass> m_WorkPasses;
	HPMCustomWorkHoursDay()
		: m_Date(0)
	{
		m_WorkPasses.resize(3);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomWorkHoursDay(HPMCustomWorkHoursDay const &_Right)
		: m_Date(_Right.m_Date)
		, m_WorkPasses(_Right.m_WorkPasses)
	{
	}
	HPMCustomWorkHoursDay(HPMCustomWorkHoursDay &&_Right)
		: m_Date(std::move(_Right.m_Date))
		, m_WorkPasses(std::move(_Right.m_WorkPasses))
	{
	}
	HPMCustomWorkHoursDay &operator =(HPMCustomWorkHoursDay const &_Right)
	{
		m_Date = _Right.m_Date;
		m_WorkPasses = _Right.m_WorkPasses;
		return *this;
	}
	HPMCustomWorkHoursDay &operator =(HPMCustomWorkHoursDay &&_Right)
	{
		m_Date = std::move(_Right.m_Date);
		m_WorkPasses = std::move(_Right.m_WorkPasses);
		return *this;
	}
#endif
	bool operator == (const HPMCustomWorkHoursDay &_Right) const
	{
		if (m_Date != _Right.m_Date)
			return false;
		if (m_WorkPasses.size() != _Right.m_WorkPasses.size())
			return false;
		for (size_t i = 0; i < m_WorkPasses.size(); ++i)
			if (m_WorkPasses[i] != _Right.m_WorkPasses[i])
				return false;
		return true;
	}
	bool operator != (const HPMCustomWorkHoursDay &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomWorkHoursDay &_Right) const
	{
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_WorkPasses.size() < _Right.m_WorkPasses.size())
			return true;
		if (m_WorkPasses.size() > _Right.m_WorkPasses.size())
			return false;
		for (size_t i = 0; i < m_WorkPasses.size(); ++i)
		{
			if (m_WorkPasses[i] < _Right.m_WorkPasses[i])
				return true;
			if (m_WorkPasses[i] > _Right.m_WorkPasses[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCustomWorkHoursDay &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomWorkHoursDay &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomWorkHoursDay &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomWorkingHours
{
	public:
	std::vector<HPMCustomWorkHoursDay> m_ChangedDays;
	HPMCustomWorkingHours()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomWorkingHours(HPMCustomWorkingHours const &_Right)
		: m_ChangedDays(_Right.m_ChangedDays)
	{
	}
	HPMCustomWorkingHours(HPMCustomWorkingHours &&_Right)
		: m_ChangedDays(std::move(_Right.m_ChangedDays))
	{
	}
	HPMCustomWorkingHours &operator =(HPMCustomWorkingHours const &_Right)
	{
		m_ChangedDays = _Right.m_ChangedDays;
		return *this;
	}
	HPMCustomWorkingHours &operator =(HPMCustomWorkingHours &&_Right)
	{
		m_ChangedDays = std::move(_Right.m_ChangedDays);
		return *this;
	}
#endif
	bool operator == (const HPMCustomWorkingHours &_Right) const
	{
		if (m_ChangedDays.size() != _Right.m_ChangedDays.size())
			return false;
		for (size_t i = 0; i < m_ChangedDays.size(); ++i)
			if (m_ChangedDays[i] != _Right.m_ChangedDays[i])
				return false;
		return true;
	}
	bool operator != (const HPMCustomWorkingHours &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomWorkingHours &_Right) const
	{
		if (m_ChangedDays.size() < _Right.m_ChangedDays.size())
			return true;
		if (m_ChangedDays.size() > _Right.m_ChangedDays.size())
			return false;
		for (size_t i = 0; i < m_ChangedDays.size(); ++i)
		{
			if (m_ChangedDays[i] < _Right.m_ChangedDays[i])
				return true;
			if (m_ChangedDays[i] > _Right.m_ChangedDays[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCustomWorkingHours &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomWorkingHours &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomWorkingHours &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkingHours
{
	public:
	std::vector<HPMWorkDay> m_WorkDays;
	HPMWorkingHours()
	{
		m_WorkDays.resize(7);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkingHours(HPMWorkingHours const &_Right)
		: m_WorkDays(_Right.m_WorkDays)
	{
	}
	HPMWorkingHours(HPMWorkingHours &&_Right)
		: m_WorkDays(std::move(_Right.m_WorkDays))
	{
	}
	HPMWorkingHours &operator =(HPMWorkingHours const &_Right)
	{
		m_WorkDays = _Right.m_WorkDays;
		return *this;
	}
	HPMWorkingHours &operator =(HPMWorkingHours &&_Right)
	{
		m_WorkDays = std::move(_Right.m_WorkDays);
		return *this;
	}
#endif
	bool operator == (const HPMWorkingHours &_Right) const
	{
		if (m_WorkDays.size() != _Right.m_WorkDays.size())
			return false;
		for (size_t i = 0; i < m_WorkDays.size(); ++i)
			if (m_WorkDays[i] != _Right.m_WorkDays[i])
				return false;
		return true;
	}
	bool operator != (const HPMWorkingHours &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkingHours &_Right) const
	{
		if (m_WorkDays.size() < _Right.m_WorkDays.size())
			return true;
		if (m_WorkDays.size() > _Right.m_WorkDays.size())
			return false;
		for (size_t i = 0; i < m_WorkDays.size(); ++i)
		{
			if (m_WorkDays[i] < _Right.m_WorkDays[i])
				return true;
			if (m_WorkDays[i] > _Right.m_WorkDays[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMWorkingHours &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkingHours &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkingHours &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMHoliday
{
	public:
	HPMUInt64 m_Date;
	HPMUntranslatedString m_Name;
	HPMHoliday()
		: m_Date(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMHoliday(HPMHoliday const &_Right)
		: m_Date(_Right.m_Date)
		, m_Name(_Right.m_Name)
	{
	}
	HPMHoliday(HPMHoliday &&_Right)
		: m_Date(std::move(_Right.m_Date))
		, m_Name(std::move(_Right.m_Name))
	{
	}
	HPMHoliday &operator =(HPMHoliday const &_Right)
	{
		m_Date = _Right.m_Date;
		m_Name = _Right.m_Name;
		return *this;
	}
	HPMHoliday &operator =(HPMHoliday &&_Right)
	{
		m_Date = std::move(_Right.m_Date);
		m_Name = std::move(_Right.m_Name);
		return *this;
	}
#endif
	bool operator == (const HPMHoliday &_Right) const
	{
		if (m_Date != _Right.m_Date)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		return true;
	}
	bool operator != (const HPMHoliday &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMHoliday &_Right) const
	{
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		return false;
	}
	bool operator > (const HPMHoliday &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMHoliday &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMHoliday &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMHolidayYear
{
	public:
	HPMInt32 m_Year;
	std::vector<HPMHoliday> m_Days;
	HPMHolidayYear()
		: m_Year(1970)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMHolidayYear(HPMHolidayYear const &_Right)
		: m_Year(_Right.m_Year)
		, m_Days(_Right.m_Days)
	{
	}
	HPMHolidayYear(HPMHolidayYear &&_Right)
		: m_Year(std::move(_Right.m_Year))
		, m_Days(std::move(_Right.m_Days))
	{
	}
	HPMHolidayYear &operator =(HPMHolidayYear const &_Right)
	{
		m_Year = _Right.m_Year;
		m_Days = _Right.m_Days;
		return *this;
	}
	HPMHolidayYear &operator =(HPMHolidayYear &&_Right)
	{
		m_Year = std::move(_Right.m_Year);
		m_Days = std::move(_Right.m_Days);
		return *this;
	}
#endif
	bool operator == (const HPMHolidayYear &_Right) const
	{
		if (m_Year != _Right.m_Year)
			return false;
		if (m_Days.size() != _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
			if (m_Days[i] != _Right.m_Days[i])
				return false;
		return true;
	}
	bool operator != (const HPMHolidayYear &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMHolidayYear &_Right) const
	{
		if (m_Year < _Right.m_Year)
			return true;
		if (m_Year > _Right.m_Year)
			return false;
		if (m_Days.size() < _Right.m_Days.size())
			return true;
		if (m_Days.size() > _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
		{
			if (m_Days[i] < _Right.m_Days[i])
				return true;
			if (m_Days[i] > _Right.m_Days[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMHolidayYear &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMHolidayYear &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMHolidayYear &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMHolidays
{
	public:
	HPMUntranslatedString m_Country;
	std::vector<HPMHolidayYear> m_Years;
	HPMHolidays()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMHolidays(HPMHolidays const &_Right)
		: m_Country(_Right.m_Country)
		, m_Years(_Right.m_Years)
	{
	}
	HPMHolidays(HPMHolidays &&_Right)
		: m_Country(std::move(_Right.m_Country))
		, m_Years(std::move(_Right.m_Years))
	{
	}
	HPMHolidays &operator =(HPMHolidays const &_Right)
	{
		m_Country = _Right.m_Country;
		m_Years = _Right.m_Years;
		return *this;
	}
	HPMHolidays &operator =(HPMHolidays &&_Right)
	{
		m_Country = std::move(_Right.m_Country);
		m_Years = std::move(_Right.m_Years);
		return *this;
	}
#endif
	bool operator == (const HPMHolidays &_Right) const
	{
		if (m_Country != _Right.m_Country)
			return false;
		if (m_Years.size() != _Right.m_Years.size())
			return false;
		for (size_t i = 0; i < m_Years.size(); ++i)
			if (m_Years[i] != _Right.m_Years[i])
				return false;
		return true;
	}
	bool operator != (const HPMHolidays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMHolidays &_Right) const
	{
		if (m_Country < _Right.m_Country)
			return true;
		if (m_Country > _Right.m_Country)
			return false;
		if (m_Years.size() < _Right.m_Years.size())
			return true;
		if (m_Years.size() > _Right.m_Years.size())
			return false;
		for (size_t i = 0; i < m_Years.size(); ++i)
		{
			if (m_Years[i] < _Right.m_Years[i])
				return true;
			if (m_Years[i] > _Right.m_Years[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMHolidays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMHolidays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMHolidays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCalendarDayInfo
{
	public:
	bool m_bWorkingDay;
	bool m_bHoliday;
	bool m_bCompensatedHoliday;
	HPMInt32 m_WorkingHours;
	bool m_bOriginatesFromVacationTask;
	HPMCalendarDayInfo()
		: m_bWorkingDay(0)
		, m_bHoliday(0)
		, m_bCompensatedHoliday(0)
		, m_WorkingHours(0)
		, m_bOriginatesFromVacationTask(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCalendarDayInfo(HPMCalendarDayInfo const &_Right)
		: m_bWorkingDay(_Right.m_bWorkingDay)
		, m_bHoliday(_Right.m_bHoliday)
		, m_bCompensatedHoliday(_Right.m_bCompensatedHoliday)
		, m_WorkingHours(_Right.m_WorkingHours)
		, m_bOriginatesFromVacationTask(_Right.m_bOriginatesFromVacationTask)
	{
	}
	HPMCalendarDayInfo(HPMCalendarDayInfo &&_Right)
		: m_bWorkingDay(std::move(_Right.m_bWorkingDay))
		, m_bHoliday(std::move(_Right.m_bHoliday))
		, m_bCompensatedHoliday(std::move(_Right.m_bCompensatedHoliday))
		, m_WorkingHours(std::move(_Right.m_WorkingHours))
		, m_bOriginatesFromVacationTask(std::move(_Right.m_bOriginatesFromVacationTask))
	{
	}
	HPMCalendarDayInfo &operator =(HPMCalendarDayInfo const &_Right)
	{
		m_bWorkingDay = _Right.m_bWorkingDay;
		m_bHoliday = _Right.m_bHoliday;
		m_bCompensatedHoliday = _Right.m_bCompensatedHoliday;
		m_WorkingHours = _Right.m_WorkingHours;
		m_bOriginatesFromVacationTask = _Right.m_bOriginatesFromVacationTask;
		return *this;
	}
	HPMCalendarDayInfo &operator =(HPMCalendarDayInfo &&_Right)
	{
		m_bWorkingDay = std::move(_Right.m_bWorkingDay);
		m_bHoliday = std::move(_Right.m_bHoliday);
		m_bCompensatedHoliday = std::move(_Right.m_bCompensatedHoliday);
		m_WorkingHours = std::move(_Right.m_WorkingHours);
		m_bOriginatesFromVacationTask = std::move(_Right.m_bOriginatesFromVacationTask);
		return *this;
	}
#endif
	bool operator == (const HPMCalendarDayInfo &_Right) const
	{
		if (m_bWorkingDay != _Right.m_bWorkingDay)
			return false;
		if (m_bHoliday != _Right.m_bHoliday)
			return false;
		if (m_bCompensatedHoliday != _Right.m_bCompensatedHoliday)
			return false;
		if (m_WorkingHours != _Right.m_WorkingHours)
			return false;
		if (m_bOriginatesFromVacationTask != _Right.m_bOriginatesFromVacationTask)
			return false;
		return true;
	}
	bool operator != (const HPMCalendarDayInfo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCalendarDayInfo &_Right) const
	{
		if (m_bWorkingDay < _Right.m_bWorkingDay)
			return true;
		if (m_bWorkingDay > _Right.m_bWorkingDay)
			return false;
		if (m_bHoliday < _Right.m_bHoliday)
			return true;
		if (m_bHoliday > _Right.m_bHoliday)
			return false;
		if (m_bCompensatedHoliday < _Right.m_bCompensatedHoliday)
			return true;
		if (m_bCompensatedHoliday > _Right.m_bCompensatedHoliday)
			return false;
		if (m_WorkingHours < _Right.m_WorkingHours)
			return true;
		if (m_WorkingHours > _Right.m_WorkingHours)
			return false;
		if (m_bOriginatesFromVacationTask < _Right.m_bOriginatesFromVacationTask)
			return true;
		if (m_bOriginatesFromVacationTask > _Right.m_bOriginatesFromVacationTask)
			return false;
		return false;
	}
	bool operator > (const HPMCalendarDayInfo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCalendarDayInfo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCalendarDayInfo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMMD5Checksum
{
	public:
	std::vector<HPMUInt8> m_Checksum;
	HPMMD5Checksum()
	{
		m_Checksum.resize(16, 0);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMMD5Checksum(HPMMD5Checksum const &_Right)
		: m_Checksum(_Right.m_Checksum)
	{
	}
	HPMMD5Checksum(HPMMD5Checksum &&_Right)
		: m_Checksum(std::move(_Right.m_Checksum))
	{
	}
	HPMMD5Checksum &operator =(HPMMD5Checksum const &_Right)
	{
		m_Checksum = _Right.m_Checksum;
		return *this;
	}
	HPMMD5Checksum &operator =(HPMMD5Checksum &&_Right)
	{
		m_Checksum = std::move(_Right.m_Checksum);
		return *this;
	}
#endif
	bool operator == (const HPMMD5Checksum &_Right) const
	{
		if (m_Checksum.size() != _Right.m_Checksum.size())
			return false;
		for (size_t i = 0; i < m_Checksum.size(); ++i)
			if (m_Checksum[i] != _Right.m_Checksum[i])
				return false;
		return true;
	}
	bool operator != (const HPMMD5Checksum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMMD5Checksum &_Right) const
	{
		if (m_Checksum.size() < _Right.m_Checksum.size())
			return true;
		if (m_Checksum.size() > _Right.m_Checksum.size())
			return false;
		for (size_t i = 0; i < m_Checksum.size(); ++i)
		{
			if (m_Checksum[i] < _Right.m_Checksum[i])
				return true;
			if (m_Checksum[i] > _Right.m_Checksum[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMMD5Checksum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMMD5Checksum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMMD5Checksum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomSettingValue
{
	public:
	bool m_bIsDefault;
	bool m_bSecretValue;
	HPMString m_Value;
	HPMCustomSettingValue()
		: m_bIsDefault(0)
		, m_bSecretValue(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomSettingValue(HPMCustomSettingValue const &_Right)
		: m_bIsDefault(_Right.m_bIsDefault)
		, m_bSecretValue(_Right.m_bSecretValue)
		, m_Value(_Right.m_Value)
	{
	}
	HPMCustomSettingValue(HPMCustomSettingValue &&_Right)
		: m_bIsDefault(std::move(_Right.m_bIsDefault))
		, m_bSecretValue(std::move(_Right.m_bSecretValue))
		, m_Value(std::move(_Right.m_Value))
	{
	}
	HPMCustomSettingValue &operator =(HPMCustomSettingValue const &_Right)
	{
		m_bIsDefault = _Right.m_bIsDefault;
		m_bSecretValue = _Right.m_bSecretValue;
		m_Value = _Right.m_Value;
		return *this;
	}
	HPMCustomSettingValue &operator =(HPMCustomSettingValue &&_Right)
	{
		m_bIsDefault = std::move(_Right.m_bIsDefault);
		m_bSecretValue = std::move(_Right.m_bSecretValue);
		m_Value = std::move(_Right.m_Value);
		return *this;
	}
#endif
	bool operator == (const HPMCustomSettingValue &_Right) const
	{
		if (m_bIsDefault != _Right.m_bIsDefault)
			return false;
		if (m_bSecretValue != _Right.m_bSecretValue)
			return false;
		if (m_Value != _Right.m_Value)
			return false;
		return true;
	}
	bool operator != (const HPMCustomSettingValue &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomSettingValue &_Right) const
	{
		if (m_bIsDefault < _Right.m_bIsDefault)
			return true;
		if (m_bIsDefault > _Right.m_bIsDefault)
			return false;
		if (m_bSecretValue < _Right.m_bSecretValue)
			return true;
		if (m_bSecretValue > _Right.m_bSecretValue)
			return false;
		if (m_Value < _Right.m_Value)
			return true;
		if (m_Value > _Right.m_Value)
			return false;
		return false;
	}
	bool operator > (const HPMCustomSettingValue &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomSettingValue &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomSettingValue &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMSDKInternalData
{
	public:
	bool m_bSecret;
	std::vector<HPMUInt8> m_Data;
	HPMSDKInternalData()
		: m_bSecret(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMSDKInternalData(HPMSDKInternalData const &_Right)
		: m_bSecret(_Right.m_bSecret)
		, m_Data(_Right.m_Data)
	{
	}
	HPMSDKInternalData(HPMSDKInternalData &&_Right)
		: m_bSecret(std::move(_Right.m_bSecret))
		, m_Data(std::move(_Right.m_Data))
	{
	}
	HPMSDKInternalData &operator =(HPMSDKInternalData const &_Right)
	{
		m_bSecret = _Right.m_bSecret;
		m_Data = _Right.m_Data;
		return *this;
	}
	HPMSDKInternalData &operator =(HPMSDKInternalData &&_Right)
	{
		m_bSecret = std::move(_Right.m_bSecret);
		m_Data = std::move(_Right.m_Data);
		return *this;
	}
#endif
	bool operator == (const HPMSDKInternalData &_Right) const
	{
		if (m_bSecret != _Right.m_bSecret)
			return false;
		if (m_Data.size() != _Right.m_Data.size())
			return false;
		for (size_t i = 0; i < m_Data.size(); ++i)
			if (m_Data[i] != _Right.m_Data[i])
				return false;
		return true;
	}
	bool operator != (const HPMSDKInternalData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMSDKInternalData &_Right) const
	{
		if (m_bSecret < _Right.m_bSecret)
			return true;
		if (m_bSecret > _Right.m_bSecret)
			return false;
		if (m_Data.size() < _Right.m_Data.size())
			return true;
		if (m_Data.size() > _Right.m_Data.size())
			return false;
		for (size_t i = 0; i < m_Data.size(); ++i)
		{
			if (m_Data[i] < _Right.m_Data[i])
				return true;
			if (m_Data[i] > _Right.m_Data[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMSDKInternalData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMSDKInternalData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMSDKInternalData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomStatisticsField
{
	public:
	EHPMStatisticsField m_FieldID;
	HPMUInt32 m_FieldData;
	HPMCustomStatisticsField()
		: m_FieldID(EHPMStatisticsField_WorkRemaining)
		, m_FieldData(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomStatisticsField(HPMCustomStatisticsField const &_Right)
		: m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
	{
	}
	HPMCustomStatisticsField(HPMCustomStatisticsField &&_Right)
		: m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
	{
	}
	HPMCustomStatisticsField &operator =(HPMCustomStatisticsField const &_Right)
	{
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		return *this;
	}
	HPMCustomStatisticsField &operator =(HPMCustomStatisticsField &&_Right)
	{
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		return *this;
	}
#endif
	bool operator == (const HPMCustomStatisticsField &_Right) const
	{
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		return true;
	}
	bool operator != (const HPMCustomStatisticsField &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomStatisticsField &_Right) const
	{
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		return false;
	}
	bool operator > (const HPMCustomStatisticsField &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomStatisticsField &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomStatisticsField &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVariantData
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMVariantData *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMVariantData *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMVariantData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVariantData(HPMVariantData const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMVariantData(HPMVariantData &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMVariantData &operator =(HPMVariantData const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMVariantData &operator =(HPMVariantData &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMVariantData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMVariantData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVariantData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMVariantData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVariantData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVariantData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskField
{
	public:
	EHPMTaskField m_FieldID;
	HPMUInt32 m_FieldData;
	HPMTaskField()
		: m_FieldID(EHPMTaskField_Undefined)
		, m_FieldData(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskField(HPMTaskField const &_Right)
		: m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
	{
	}
	HPMTaskField(HPMTaskField &&_Right)
		: m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
	{
	}
	HPMTaskField &operator =(HPMTaskField const &_Right)
	{
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		return *this;
	}
	HPMTaskField &operator =(HPMTaskField &&_Right)
	{
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		return *this;
	}
#endif
	bool operator == (const HPMTaskField &_Right) const
	{
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		return true;
	}
	bool operator != (const HPMTaskField &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskField &_Right) const
	{
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		return false;
	}
	bool operator > (const HPMTaskField &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskField &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskField &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskFieldData
{
	public:
	HPMTaskField m_TaskField;
	HPMVariantData m_VariantData;
	HPMTaskFieldData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskFieldData(HPMTaskFieldData const &_Right)
		: m_TaskField(_Right.m_TaskField)
		, m_VariantData(_Right.m_VariantData)
	{
	}
	HPMTaskFieldData(HPMTaskFieldData &&_Right)
		: m_TaskField(std::move(_Right.m_TaskField))
		, m_VariantData(std::move(_Right.m_VariantData))
	{
	}
	HPMTaskFieldData &operator =(HPMTaskFieldData const &_Right)
	{
		m_TaskField = _Right.m_TaskField;
		m_VariantData = _Right.m_VariantData;
		return *this;
	}
	HPMTaskFieldData &operator =(HPMTaskFieldData &&_Right)
	{
		m_TaskField = std::move(_Right.m_TaskField);
		m_VariantData = std::move(_Right.m_VariantData);
		return *this;
	}
#endif
	bool operator == (const HPMTaskFieldData &_Right) const
	{
		if (m_TaskField != _Right.m_TaskField)
			return false;
		if (m_VariantData != _Right.m_VariantData)
			return false;
		return true;
	}
	bool operator != (const HPMTaskFieldData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskFieldData &_Right) const
	{
		if (m_TaskField < _Right.m_TaskField)
			return true;
		if (m_TaskField > _Right.m_TaskField)
			return false;
		if (m_VariantData < _Right.m_VariantData)
			return true;
		if (m_VariantData > _Right.m_VariantData)
			return false;
		return false;
	}
	bool operator > (const HPMTaskFieldData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskFieldData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskFieldData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMColumn
{
	public:
	EHPMColumnType m_ColumnType;
	HPMUInt32 m_ColumnID;
	HPMColumn()
		: m_ColumnType(EHPMColumnType_DefaultColumn)
		, m_ColumnID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMColumn(HPMColumn const &_Right)
		: m_ColumnType(_Right.m_ColumnType)
		, m_ColumnID(_Right.m_ColumnID)
	{
	}
	HPMColumn(HPMColumn &&_Right)
		: m_ColumnType(std::move(_Right.m_ColumnType))
		, m_ColumnID(std::move(_Right.m_ColumnID))
	{
	}
	HPMColumn &operator =(HPMColumn const &_Right)
	{
		m_ColumnType = _Right.m_ColumnType;
		m_ColumnID = _Right.m_ColumnID;
		return *this;
	}
	HPMColumn &operator =(HPMColumn &&_Right)
	{
		m_ColumnType = std::move(_Right.m_ColumnType);
		m_ColumnID = std::move(_Right.m_ColumnID);
		return *this;
	}
#endif
	bool operator == (const HPMColumn &_Right) const
	{
		if (m_ColumnType != _Right.m_ColumnType)
			return false;
		if (m_ColumnID != _Right.m_ColumnID)
			return false;
		return true;
	}
	bool operator != (const HPMColumn &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMColumn &_Right) const
	{
		if (m_ColumnType < _Right.m_ColumnType)
			return true;
		if (m_ColumnType > _Right.m_ColumnType)
			return false;
		if (m_ColumnID < _Right.m_ColumnID)
			return true;
		if (m_ColumnID > _Right.m_ColumnID)
			return false;
		return false;
	}
	bool operator > (const HPMColumn &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMColumn &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMColumn &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMColumnData
{
	public:
	std::vector<HPMUInt32> m_DataItems;
	bool m_bFirstItemIsNotSet;
	HPMColumnData()
		: m_bFirstItemIsNotSet(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMColumnData(HPMColumnData const &_Right)
		: m_DataItems(_Right.m_DataItems)
		, m_bFirstItemIsNotSet(_Right.m_bFirstItemIsNotSet)
	{
	}
	HPMColumnData(HPMColumnData &&_Right)
		: m_DataItems(std::move(_Right.m_DataItems))
		, m_bFirstItemIsNotSet(std::move(_Right.m_bFirstItemIsNotSet))
	{
	}
	HPMColumnData &operator =(HPMColumnData const &_Right)
	{
		m_DataItems = _Right.m_DataItems;
		m_bFirstItemIsNotSet = _Right.m_bFirstItemIsNotSet;
		return *this;
	}
	HPMColumnData &operator =(HPMColumnData &&_Right)
	{
		m_DataItems = std::move(_Right.m_DataItems);
		m_bFirstItemIsNotSet = std::move(_Right.m_bFirstItemIsNotSet);
		return *this;
	}
#endif
	bool operator == (const HPMColumnData &_Right) const
	{
		if (m_DataItems.size() != _Right.m_DataItems.size())
			return false;
		for (size_t i = 0; i < m_DataItems.size(); ++i)
			if (m_DataItems[i] != _Right.m_DataItems[i])
				return false;
		if (m_bFirstItemIsNotSet != _Right.m_bFirstItemIsNotSet)
			return false;
		return true;
	}
	bool operator != (const HPMColumnData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMColumnData &_Right) const
	{
		if (m_DataItems.size() < _Right.m_DataItems.size())
			return true;
		if (m_DataItems.size() > _Right.m_DataItems.size())
			return false;
		for (size_t i = 0; i < m_DataItems.size(); ++i)
		{
			if (m_DataItems[i] < _Right.m_DataItems[i])
				return true;
			if (m_DataItems[i] > _Right.m_DataItems[i])
				return false;
		}
		if (m_bFirstItemIsNotSet < _Right.m_bFirstItemIsNotSet)
			return true;
		if (m_bFirstItemIsNotSet > _Right.m_bFirstItemIsNotSet)
			return false;
		return false;
	}
	bool operator > (const HPMColumnData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMColumnData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMColumnData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMColumnDescription
{
	public:
	EHPMValueType m_Type;
	EHPMFindCriteriaDataType m_CriteriaDataType;
	bool m_bFloatingPoint;
	bool m_bReadOnly;
	EHPMTaskField m_TaskFieldID;
	HPMInt64 m_MinValue;
	HPMInt64 m_MaxValue;
	HPMInt32 m_MaxDecimals;
	HPMColumnDescription()
		: m_Type(EHPMValueType_Undefined)
		, m_CriteriaDataType(EHPMFindCriteriaDataType_Invalid)
		, m_bFloatingPoint(0)
		, m_bReadOnly(0)
		, m_TaskFieldID(EHPMTaskField_Undefined)
		, m_MinValue(0)
		, m_MaxValue(0)
		, m_MaxDecimals(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMColumnDescription(HPMColumnDescription const &_Right)
		: m_Type(_Right.m_Type)
		, m_CriteriaDataType(_Right.m_CriteriaDataType)
		, m_bFloatingPoint(_Right.m_bFloatingPoint)
		, m_bReadOnly(_Right.m_bReadOnly)
		, m_TaskFieldID(_Right.m_TaskFieldID)
		, m_MinValue(_Right.m_MinValue)
		, m_MaxValue(_Right.m_MaxValue)
		, m_MaxDecimals(_Right.m_MaxDecimals)
	{
	}
	HPMColumnDescription(HPMColumnDescription &&_Right)
		: m_Type(std::move(_Right.m_Type))
		, m_CriteriaDataType(std::move(_Right.m_CriteriaDataType))
		, m_bFloatingPoint(std::move(_Right.m_bFloatingPoint))
		, m_bReadOnly(std::move(_Right.m_bReadOnly))
		, m_TaskFieldID(std::move(_Right.m_TaskFieldID))
		, m_MinValue(std::move(_Right.m_MinValue))
		, m_MaxValue(std::move(_Right.m_MaxValue))
		, m_MaxDecimals(std::move(_Right.m_MaxDecimals))
	{
	}
	HPMColumnDescription &operator =(HPMColumnDescription const &_Right)
	{
		m_Type = _Right.m_Type;
		m_CriteriaDataType = _Right.m_CriteriaDataType;
		m_bFloatingPoint = _Right.m_bFloatingPoint;
		m_bReadOnly = _Right.m_bReadOnly;
		m_TaskFieldID = _Right.m_TaskFieldID;
		m_MinValue = _Right.m_MinValue;
		m_MaxValue = _Right.m_MaxValue;
		m_MaxDecimals = _Right.m_MaxDecimals;
		return *this;
	}
	HPMColumnDescription &operator =(HPMColumnDescription &&_Right)
	{
		m_Type = std::move(_Right.m_Type);
		m_CriteriaDataType = std::move(_Right.m_CriteriaDataType);
		m_bFloatingPoint = std::move(_Right.m_bFloatingPoint);
		m_bReadOnly = std::move(_Right.m_bReadOnly);
		m_TaskFieldID = std::move(_Right.m_TaskFieldID);
		m_MinValue = std::move(_Right.m_MinValue);
		m_MaxValue = std::move(_Right.m_MaxValue);
		m_MaxDecimals = std::move(_Right.m_MaxDecimals);
		return *this;
	}
#endif
	bool operator == (const HPMColumnDescription &_Right) const
	{
		if (m_Type != _Right.m_Type)
			return false;
		if (m_CriteriaDataType != _Right.m_CriteriaDataType)
			return false;
		if (m_bFloatingPoint != _Right.m_bFloatingPoint)
			return false;
		if (m_bReadOnly != _Right.m_bReadOnly)
			return false;
		if (m_TaskFieldID != _Right.m_TaskFieldID)
			return false;
		if (m_MinValue != _Right.m_MinValue)
			return false;
		if (m_MaxValue != _Right.m_MaxValue)
			return false;
		if (m_MaxDecimals != _Right.m_MaxDecimals)
			return false;
		return true;
	}
	bool operator != (const HPMColumnDescription &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMColumnDescription &_Right) const
	{
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_CriteriaDataType < _Right.m_CriteriaDataType)
			return true;
		if (m_CriteriaDataType > _Right.m_CriteriaDataType)
			return false;
		if (m_bFloatingPoint < _Right.m_bFloatingPoint)
			return true;
		if (m_bFloatingPoint > _Right.m_bFloatingPoint)
			return false;
		if (m_bReadOnly < _Right.m_bReadOnly)
			return true;
		if (m_bReadOnly > _Right.m_bReadOnly)
			return false;
		if (m_TaskFieldID < _Right.m_TaskFieldID)
			return true;
		if (m_TaskFieldID > _Right.m_TaskFieldID)
			return false;
		if (m_MinValue < _Right.m_MinValue)
			return true;
		if (m_MinValue > _Right.m_MinValue)
			return false;
		if (m_MaxValue < _Right.m_MaxValue)
			return true;
		if (m_MaxValue > _Right.m_MaxValue)
			return false;
		if (m_MaxDecimals < _Right.m_MaxDecimals)
			return true;
		if (m_MaxDecimals > _Right.m_MaxDecimals)
			return false;
		return false;
	}
	bool operator > (const HPMColumnDescription &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMColumnDescription &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMColumnDescription &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMColumnTextOptions
{
	public:
	bool m_bForDisplay;
	bool m_bMyWork;
	bool m_bDisplayUnits;
	bool m_bExpandResources;
	bool m_bOnlyFirstResource;
	bool m_bNeedFullProjectPath;
	bool m_bNeedSprintInSubProjectPath;
	bool m_bSeparateSubProjectPath;
	HPMUniqueID m_ForResource;
	HPMColumnTextOptions()
		: m_bForDisplay(1)
		, m_bMyWork(0)
		, m_bDisplayUnits(1)
		, m_bExpandResources(0)
		, m_bOnlyFirstResource(0)
		, m_bNeedFullProjectPath(0)
		, m_bNeedSprintInSubProjectPath(0)
		, m_bSeparateSubProjectPath(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMColumnTextOptions(HPMColumnTextOptions const &_Right)
		: m_bForDisplay(_Right.m_bForDisplay)
		, m_bMyWork(_Right.m_bMyWork)
		, m_bDisplayUnits(_Right.m_bDisplayUnits)
		, m_bExpandResources(_Right.m_bExpandResources)
		, m_bOnlyFirstResource(_Right.m_bOnlyFirstResource)
		, m_bNeedFullProjectPath(_Right.m_bNeedFullProjectPath)
		, m_bNeedSprintInSubProjectPath(_Right.m_bNeedSprintInSubProjectPath)
		, m_bSeparateSubProjectPath(_Right.m_bSeparateSubProjectPath)
		, m_ForResource(_Right.m_ForResource)
	{
	}
	HPMColumnTextOptions(HPMColumnTextOptions &&_Right)
		: m_bForDisplay(std::move(_Right.m_bForDisplay))
		, m_bMyWork(std::move(_Right.m_bMyWork))
		, m_bDisplayUnits(std::move(_Right.m_bDisplayUnits))
		, m_bExpandResources(std::move(_Right.m_bExpandResources))
		, m_bOnlyFirstResource(std::move(_Right.m_bOnlyFirstResource))
		, m_bNeedFullProjectPath(std::move(_Right.m_bNeedFullProjectPath))
		, m_bNeedSprintInSubProjectPath(std::move(_Right.m_bNeedSprintInSubProjectPath))
		, m_bSeparateSubProjectPath(std::move(_Right.m_bSeparateSubProjectPath))
		, m_ForResource(std::move(_Right.m_ForResource))
	{
	}
	HPMColumnTextOptions &operator =(HPMColumnTextOptions const &_Right)
	{
		m_bForDisplay = _Right.m_bForDisplay;
		m_bMyWork = _Right.m_bMyWork;
		m_bDisplayUnits = _Right.m_bDisplayUnits;
		m_bExpandResources = _Right.m_bExpandResources;
		m_bOnlyFirstResource = _Right.m_bOnlyFirstResource;
		m_bNeedFullProjectPath = _Right.m_bNeedFullProjectPath;
		m_bNeedSprintInSubProjectPath = _Right.m_bNeedSprintInSubProjectPath;
		m_bSeparateSubProjectPath = _Right.m_bSeparateSubProjectPath;
		m_ForResource = _Right.m_ForResource;
		return *this;
	}
	HPMColumnTextOptions &operator =(HPMColumnTextOptions &&_Right)
	{
		m_bForDisplay = std::move(_Right.m_bForDisplay);
		m_bMyWork = std::move(_Right.m_bMyWork);
		m_bDisplayUnits = std::move(_Right.m_bDisplayUnits);
		m_bExpandResources = std::move(_Right.m_bExpandResources);
		m_bOnlyFirstResource = std::move(_Right.m_bOnlyFirstResource);
		m_bNeedFullProjectPath = std::move(_Right.m_bNeedFullProjectPath);
		m_bNeedSprintInSubProjectPath = std::move(_Right.m_bNeedSprintInSubProjectPath);
		m_bSeparateSubProjectPath = std::move(_Right.m_bSeparateSubProjectPath);
		m_ForResource = std::move(_Right.m_ForResource);
		return *this;
	}
#endif
	bool operator == (const HPMColumnTextOptions &_Right) const
	{
		if (m_bForDisplay != _Right.m_bForDisplay)
			return false;
		if (m_bMyWork != _Right.m_bMyWork)
			return false;
		if (m_bDisplayUnits != _Right.m_bDisplayUnits)
			return false;
		if (m_bExpandResources != _Right.m_bExpandResources)
			return false;
		if (m_bOnlyFirstResource != _Right.m_bOnlyFirstResource)
			return false;
		if (m_bNeedFullProjectPath != _Right.m_bNeedFullProjectPath)
			return false;
		if (m_bNeedSprintInSubProjectPath != _Right.m_bNeedSprintInSubProjectPath)
			return false;
		if (m_bSeparateSubProjectPath != _Right.m_bSeparateSubProjectPath)
			return false;
		if (m_ForResource != _Right.m_ForResource)
			return false;
		return true;
	}
	bool operator != (const HPMColumnTextOptions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMColumnTextOptions &_Right) const
	{
		if (m_bForDisplay < _Right.m_bForDisplay)
			return true;
		if (m_bForDisplay > _Right.m_bForDisplay)
			return false;
		if (m_bMyWork < _Right.m_bMyWork)
			return true;
		if (m_bMyWork > _Right.m_bMyWork)
			return false;
		if (m_bDisplayUnits < _Right.m_bDisplayUnits)
			return true;
		if (m_bDisplayUnits > _Right.m_bDisplayUnits)
			return false;
		if (m_bExpandResources < _Right.m_bExpandResources)
			return true;
		if (m_bExpandResources > _Right.m_bExpandResources)
			return false;
		if (m_bOnlyFirstResource < _Right.m_bOnlyFirstResource)
			return true;
		if (m_bOnlyFirstResource > _Right.m_bOnlyFirstResource)
			return false;
		if (m_bNeedFullProjectPath < _Right.m_bNeedFullProjectPath)
			return true;
		if (m_bNeedFullProjectPath > _Right.m_bNeedFullProjectPath)
			return false;
		if (m_bNeedSprintInSubProjectPath < _Right.m_bNeedSprintInSubProjectPath)
			return true;
		if (m_bNeedSprintInSubProjectPath > _Right.m_bNeedSprintInSubProjectPath)
			return false;
		if (m_bSeparateSubProjectPath < _Right.m_bSeparateSubProjectPath)
			return true;
		if (m_bSeparateSubProjectPath > _Right.m_bSeparateSubProjectPath)
			return false;
		if (m_ForResource < _Right.m_ForResource)
			return true;
		if (m_ForResource > _Right.m_ForResource)
			return false;
		return false;
	}
	bool operator > (const HPMColumnTextOptions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMColumnTextOptions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMColumnTextOptions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomColumnInfo
{
	public:
	EHPMColumnType m_ColumnType;
	HPMInt32 m_ColumnID;
	HPMCustomColumnInfo()
		: m_ColumnType(EHPMColumnType_DefaultColumn)
		, m_ColumnID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomColumnInfo(HPMCustomColumnInfo const &_Right)
		: m_ColumnType(_Right.m_ColumnType)
		, m_ColumnID(_Right.m_ColumnID)
	{
	}
	HPMCustomColumnInfo(HPMCustomColumnInfo &&_Right)
		: m_ColumnType(std::move(_Right.m_ColumnType))
		, m_ColumnID(std::move(_Right.m_ColumnID))
	{
	}
	HPMCustomColumnInfo &operator =(HPMCustomColumnInfo const &_Right)
	{
		m_ColumnType = _Right.m_ColumnType;
		m_ColumnID = _Right.m_ColumnID;
		return *this;
	}
	HPMCustomColumnInfo &operator =(HPMCustomColumnInfo &&_Right)
	{
		m_ColumnType = std::move(_Right.m_ColumnType);
		m_ColumnID = std::move(_Right.m_ColumnID);
		return *this;
	}
#endif
	bool operator == (const HPMCustomColumnInfo &_Right) const
	{
		if (m_ColumnType != _Right.m_ColumnType)
			return false;
		if (m_ColumnID != _Right.m_ColumnID)
			return false;
		return true;
	}
	bool operator != (const HPMCustomColumnInfo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomColumnInfo &_Right) const
	{
		if (m_ColumnType < _Right.m_ColumnType)
			return true;
		if (m_ColumnType > _Right.m_ColumnType)
			return false;
		if (m_ColumnID < _Right.m_ColumnID)
			return true;
		if (m_ColumnID > _Right.m_ColumnID)
			return false;
		return false;
	}
	bool operator > (const HPMCustomColumnInfo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomColumnInfo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomColumnInfo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCondition
{
	public:
	EHPMFindSelectionType m_SelectionType;
	HPMInt32 m_SelectionID;
	HPMColumn m_Column;
	HPMFindCondition()
		: m_SelectionType(EHPMFindSelectionType_Column)
		, m_SelectionID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCondition(HPMFindCondition const &_Right)
		: m_SelectionType(_Right.m_SelectionType)
		, m_SelectionID(_Right.m_SelectionID)
		, m_Column(_Right.m_Column)
	{
	}
	HPMFindCondition(HPMFindCondition &&_Right)
		: m_SelectionType(std::move(_Right.m_SelectionType))
		, m_SelectionID(std::move(_Right.m_SelectionID))
		, m_Column(std::move(_Right.m_Column))
	{
	}
	HPMFindCondition &operator =(HPMFindCondition const &_Right)
	{
		m_SelectionType = _Right.m_SelectionType;
		m_SelectionID = _Right.m_SelectionID;
		m_Column = _Right.m_Column;
		return *this;
	}
	HPMFindCondition &operator =(HPMFindCondition &&_Right)
	{
		m_SelectionType = std::move(_Right.m_SelectionType);
		m_SelectionID = std::move(_Right.m_SelectionID);
		m_Column = std::move(_Right.m_Column);
		return *this;
	}
#endif
	bool operator == (const HPMFindCondition &_Right) const
	{
		if (m_SelectionType != _Right.m_SelectionType)
			return false;
		if (m_SelectionID != _Right.m_SelectionID)
			return false;
		if (m_Column != _Right.m_Column)
			return false;
		return true;
	}
	bool operator != (const HPMFindCondition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCondition &_Right) const
	{
		if (m_SelectionType < _Right.m_SelectionType)
			return true;
		if (m_SelectionType > _Right.m_SelectionType)
			return false;
		if (m_SelectionID < _Right.m_SelectionID)
			return true;
		if (m_SelectionID > _Right.m_SelectionID)
			return false;
		if (m_Column < _Right.m_Column)
			return true;
		if (m_Column > _Right.m_Column)
			return false;
		return false;
	}
	bool operator > (const HPMFindCondition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCondition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCondition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindContextData
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMFindContextData *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMFindContextData *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMFindContextData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindContextData(HPMFindContextData const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMFindContextData(HPMFindContextData &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMFindContextData &operator =(HPMFindContextData const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMFindContextData &operator =(HPMFindContextData &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMFindContextData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMFindContextData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindContextData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMFindContextData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindContextData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindContextData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindContext
{
	public:
	std::vector<HPMFindCondition> m_Conditions;
	std::vector<HPMUniqueID> m_Milestones;
	std::vector<HPMUniqueID> m_PipelinesAndWorkflows;
	HPMFindContext()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindContext(HPMFindContext const &_Right)
		: m_Conditions(_Right.m_Conditions)
		, m_Milestones(_Right.m_Milestones)
		, m_PipelinesAndWorkflows(_Right.m_PipelinesAndWorkflows)
	{
	}
	HPMFindContext(HPMFindContext &&_Right)
		: m_Conditions(std::move(_Right.m_Conditions))
		, m_Milestones(std::move(_Right.m_Milestones))
		, m_PipelinesAndWorkflows(std::move(_Right.m_PipelinesAndWorkflows))
	{
	}
	HPMFindContext &operator =(HPMFindContext const &_Right)
	{
		m_Conditions = _Right.m_Conditions;
		m_Milestones = _Right.m_Milestones;
		m_PipelinesAndWorkflows = _Right.m_PipelinesAndWorkflows;
		return *this;
	}
	HPMFindContext &operator =(HPMFindContext &&_Right)
	{
		m_Conditions = std::move(_Right.m_Conditions);
		m_Milestones = std::move(_Right.m_Milestones);
		m_PipelinesAndWorkflows = std::move(_Right.m_PipelinesAndWorkflows);
		return *this;
	}
#endif
	bool operator == (const HPMFindContext &_Right) const
	{
		if (m_Conditions.size() != _Right.m_Conditions.size())
			return false;
		for (size_t i = 0; i < m_Conditions.size(); ++i)
			if (m_Conditions[i] != _Right.m_Conditions[i])
				return false;
		if (m_Milestones.size() != _Right.m_Milestones.size())
			return false;
		for (size_t i = 0; i < m_Milestones.size(); ++i)
			if (m_Milestones[i] != _Right.m_Milestones[i])
				return false;
		if (m_PipelinesAndWorkflows.size() != _Right.m_PipelinesAndWorkflows.size())
			return false;
		for (size_t i = 0; i < m_PipelinesAndWorkflows.size(); ++i)
			if (m_PipelinesAndWorkflows[i] != _Right.m_PipelinesAndWorkflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMFindContext &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindContext &_Right) const
	{
		if (m_Conditions.size() < _Right.m_Conditions.size())
			return true;
		if (m_Conditions.size() > _Right.m_Conditions.size())
			return false;
		for (size_t i = 0; i < m_Conditions.size(); ++i)
		{
			if (m_Conditions[i] < _Right.m_Conditions[i])
				return true;
			if (m_Conditions[i] > _Right.m_Conditions[i])
				return false;
		}
		if (m_Milestones.size() < _Right.m_Milestones.size())
			return true;
		if (m_Milestones.size() > _Right.m_Milestones.size())
			return false;
		for (size_t i = 0; i < m_Milestones.size(); ++i)
		{
			if (m_Milestones[i] < _Right.m_Milestones[i])
				return true;
			if (m_Milestones[i] > _Right.m_Milestones[i])
				return false;
		}
		if (m_PipelinesAndWorkflows.size() < _Right.m_PipelinesAndWorkflows.size())
			return true;
		if (m_PipelinesAndWorkflows.size() > _Right.m_PipelinesAndWorkflows.size())
			return false;
		for (size_t i = 0; i < m_PipelinesAndWorkflows.size(); ++i)
		{
			if (m_PipelinesAndWorkflows[i] < _Right.m_PipelinesAndWorkflows[i])
				return true;
			if (m_PipelinesAndWorkflows[i] > _Right.m_PipelinesAndWorkflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMFindContext &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindContext &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindContext &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkflowObjectIdentifier
{
	public:
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMWorkflowObjectIdentifier()
		: m_WorkflowID(0)
		, m_WorkflowObjectID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkflowObjectIdentifier(HPMWorkflowObjectIdentifier const &_Right)
		: m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
	{
	}
	HPMWorkflowObjectIdentifier(HPMWorkflowObjectIdentifier &&_Right)
		: m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
	{
	}
	HPMWorkflowObjectIdentifier &operator =(HPMWorkflowObjectIdentifier const &_Right)
	{
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		return *this;
	}
	HPMWorkflowObjectIdentifier &operator =(HPMWorkflowObjectIdentifier &&_Right)
	{
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		return *this;
	}
#endif
	bool operator == (const HPMWorkflowObjectIdentifier &_Right) const
	{
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		return true;
	}
	bool operator != (const HPMWorkflowObjectIdentifier &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkflowObjectIdentifier &_Right) const
	{
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		return false;
	}
	bool operator > (const HPMWorkflowObjectIdentifier &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkflowObjectIdentifier &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkflowObjectIdentifier &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkflowStatusTransitInfo
{
	public:
	HPMUniqueID m_ResourceID;
	HPMUInt64 m_Time;
	HPMWorkflowStatusTransitInfo()
		: m_Time(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkflowStatusTransitInfo(HPMWorkflowStatusTransitInfo const &_Right)
		: m_ResourceID(_Right.m_ResourceID)
		, m_Time(_Right.m_Time)
	{
	}
	HPMWorkflowStatusTransitInfo(HPMWorkflowStatusTransitInfo &&_Right)
		: m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Time(std::move(_Right.m_Time))
	{
	}
	HPMWorkflowStatusTransitInfo &operator =(HPMWorkflowStatusTransitInfo const &_Right)
	{
		m_ResourceID = _Right.m_ResourceID;
		m_Time = _Right.m_Time;
		return *this;
	}
	HPMWorkflowStatusTransitInfo &operator =(HPMWorkflowStatusTransitInfo &&_Right)
	{
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Time = std::move(_Right.m_Time);
		return *this;
	}
#endif
	bool operator == (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Time != _Right.m_Time)
			return false;
		return true;
	}
	bool operator != (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Time < _Right.m_Time)
			return true;
		if (m_Time > _Right.m_Time)
			return false;
		return false;
	}
	bool operator > (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkflowStatusTransitInfo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaDataListItem
{
	public:
	HPMInt32 m_ID;
	HPMUInt32 m_Data;
	HPMFindCriteriaDataListItem()
		: m_ID(1)
		, m_Data(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaDataListItem(HPMFindCriteriaDataListItem const &_Right)
		: m_ID(_Right.m_ID)
		, m_Data(_Right.m_Data)
	{
	}
	HPMFindCriteriaDataListItem(HPMFindCriteriaDataListItem &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_Data(std::move(_Right.m_Data))
	{
	}
	HPMFindCriteriaDataListItem &operator =(HPMFindCriteriaDataListItem const &_Right)
	{
		m_ID = _Right.m_ID;
		m_Data = _Right.m_Data;
		return *this;
	}
	HPMFindCriteriaDataListItem &operator =(HPMFindCriteriaDataListItem &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_Data = std::move(_Right.m_Data);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaDataListItem &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_Data != _Right.m_Data)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaDataListItem &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaDataListItem &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_Data < _Right.m_Data)
			return true;
		if (m_Data > _Right.m_Data)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaDataListItem &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaDataListItem &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaDataListItem &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaData
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMFindCriteriaData *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMFindCriteriaData *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMFindCriteriaData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaData(HPMFindCriteriaData const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMFindCriteriaData(HPMFindCriteriaData &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMFindCriteriaData &operator =(HPMFindCriteriaData const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMFindCriteriaData &operator =(HPMFindCriteriaData &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaData &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMFindCriteriaData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaConnection
{
	public:
	HPMUInt32 m_ID;
	HPMInt32 m_ConnectFrom;
	HPMInt32 m_ConnectTo;
	HPMFindCriteriaConnection()
		: m_ID(0)
		, m_ConnectFrom(0)
		, m_ConnectTo(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaConnection(HPMFindCriteriaConnection const &_Right)
		: m_ID(_Right.m_ID)
		, m_ConnectFrom(_Right.m_ConnectFrom)
		, m_ConnectTo(_Right.m_ConnectTo)
	{
	}
	HPMFindCriteriaConnection(HPMFindCriteriaConnection &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_ConnectFrom(std::move(_Right.m_ConnectFrom))
		, m_ConnectTo(std::move(_Right.m_ConnectTo))
	{
	}
	HPMFindCriteriaConnection &operator =(HPMFindCriteriaConnection const &_Right)
	{
		m_ID = _Right.m_ID;
		m_ConnectFrom = _Right.m_ConnectFrom;
		m_ConnectTo = _Right.m_ConnectTo;
		return *this;
	}
	HPMFindCriteriaConnection &operator =(HPMFindCriteriaConnection &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_ConnectFrom = std::move(_Right.m_ConnectFrom);
		m_ConnectTo = std::move(_Right.m_ConnectTo);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaConnection &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_ConnectFrom != _Right.m_ConnectFrom)
			return false;
		if (m_ConnectTo != _Right.m_ConnectTo)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaConnection &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaConnection &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_ConnectFrom < _Right.m_ConnectFrom)
			return true;
		if (m_ConnectFrom > _Right.m_ConnectFrom)
			return false;
		if (m_ConnectTo < _Right.m_ConnectTo)
			return true;
		if (m_ConnectTo > _Right.m_ConnectTo)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaConnection &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaConnection &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaConnection &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteria
{
	public:
	HPMUInt32 m_ID;
	HPMInt32 m_PositionX;
	HPMInt32 m_PositionY;
	EHPMFindCriteriaType m_Type;
	EHPMFindCriteriaFlag m_Flags;
	HPMString m_CriteriaString;
	HPMFindCriteriaData m_CriteriaData;
	std::vector<HPMFindCriteriaConnection> m_ConnectedToCriterias;
	HPMFindCriteria()
		: m_ID(1)
		, m_PositionX(0)
		, m_PositionY(0)
		, m_Type(EHPMFindCriteriaType_Criteria)
		, m_Flags(EHPMFindCriteriaFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteria(HPMFindCriteria const &_Right)
		: m_ID(_Right.m_ID)
		, m_PositionX(_Right.m_PositionX)
		, m_PositionY(_Right.m_PositionY)
		, m_Type(_Right.m_Type)
		, m_Flags(_Right.m_Flags)
		, m_CriteriaString(_Right.m_CriteriaString)
		, m_CriteriaData(_Right.m_CriteriaData)
		, m_ConnectedToCriterias(_Right.m_ConnectedToCriterias)
	{
	}
	HPMFindCriteria(HPMFindCriteria &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_PositionX(std::move(_Right.m_PositionX))
		, m_PositionY(std::move(_Right.m_PositionY))
		, m_Type(std::move(_Right.m_Type))
		, m_Flags(std::move(_Right.m_Flags))
		, m_CriteriaString(std::move(_Right.m_CriteriaString))
		, m_CriteriaData(std::move(_Right.m_CriteriaData))
		, m_ConnectedToCriterias(std::move(_Right.m_ConnectedToCriterias))
	{
	}
	HPMFindCriteria &operator =(HPMFindCriteria const &_Right)
	{
		m_ID = _Right.m_ID;
		m_PositionX = _Right.m_PositionX;
		m_PositionY = _Right.m_PositionY;
		m_Type = _Right.m_Type;
		m_Flags = _Right.m_Flags;
		m_CriteriaString = _Right.m_CriteriaString;
		m_CriteriaData = _Right.m_CriteriaData;
		m_ConnectedToCriterias = _Right.m_ConnectedToCriterias;
		return *this;
	}
	HPMFindCriteria &operator =(HPMFindCriteria &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_PositionX = std::move(_Right.m_PositionX);
		m_PositionY = std::move(_Right.m_PositionY);
		m_Type = std::move(_Right.m_Type);
		m_Flags = std::move(_Right.m_Flags);
		m_CriteriaString = std::move(_Right.m_CriteriaString);
		m_CriteriaData = std::move(_Right.m_CriteriaData);
		m_ConnectedToCriterias = std::move(_Right.m_ConnectedToCriterias);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteria &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_PositionX != _Right.m_PositionX)
			return false;
		if (m_PositionY != _Right.m_PositionY)
			return false;
		if (m_Type != _Right.m_Type)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_CriteriaString != _Right.m_CriteriaString)
			return false;
		if (m_CriteriaData != _Right.m_CriteriaData)
			return false;
		if (m_ConnectedToCriterias.size() != _Right.m_ConnectedToCriterias.size())
			return false;
		for (size_t i = 0; i < m_ConnectedToCriterias.size(); ++i)
			if (m_ConnectedToCriterias[i] != _Right.m_ConnectedToCriterias[i])
				return false;
		return true;
	}
	bool operator != (const HPMFindCriteria &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteria &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_PositionX < _Right.m_PositionX)
			return true;
		if (m_PositionX > _Right.m_PositionX)
			return false;
		if (m_PositionY < _Right.m_PositionY)
			return true;
		if (m_PositionY > _Right.m_PositionY)
			return false;
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_CriteriaString < _Right.m_CriteriaString)
			return true;
		if (m_CriteriaString > _Right.m_CriteriaString)
			return false;
		if (m_CriteriaData < _Right.m_CriteriaData)
			return true;
		if (m_CriteriaData > _Right.m_CriteriaData)
			return false;
		if (m_ConnectedToCriterias.size() < _Right.m_ConnectedToCriterias.size())
			return true;
		if (m_ConnectedToCriterias.size() > _Right.m_ConnectedToCriterias.size())
			return false;
		for (size_t i = 0; i < m_ConnectedToCriterias.size(); ++i)
		{
			if (m_ConnectedToCriterias[i] < _Right.m_ConnectedToCriterias[i])
				return true;
			if (m_ConnectedToCriterias[i] > _Right.m_ConnectedToCriterias[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMFindCriteria &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteria &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteria &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaDataHeader
{
	public:
	HPMColumn m_Column;
	EHPMFindCriteriaOperator m_Operator;
	HPMFindCriteriaDataHeader()
		: m_Operator(EHPMFindCriteriaOperator_NoOperator)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaDataHeader(HPMFindCriteriaDataHeader const &_Right)
		: m_Column(_Right.m_Column)
		, m_Operator(_Right.m_Operator)
	{
	}
	HPMFindCriteriaDataHeader(HPMFindCriteriaDataHeader &&_Right)
		: m_Column(std::move(_Right.m_Column))
		, m_Operator(std::move(_Right.m_Operator))
	{
	}
	HPMFindCriteriaDataHeader &operator =(HPMFindCriteriaDataHeader const &_Right)
	{
		m_Column = _Right.m_Column;
		m_Operator = _Right.m_Operator;
		return *this;
	}
	HPMFindCriteriaDataHeader &operator =(HPMFindCriteriaDataHeader &&_Right)
	{
		m_Column = std::move(_Right.m_Column);
		m_Operator = std::move(_Right.m_Operator);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaDataHeader &_Right) const
	{
		if (m_Column != _Right.m_Column)
			return false;
		if (m_Operator != _Right.m_Operator)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaDataHeader &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaDataHeader &_Right) const
	{
		if (m_Column < _Right.m_Column)
			return true;
		if (m_Column > _Right.m_Column)
			return false;
		if (m_Operator < _Right.m_Operator)
			return true;
		if (m_Operator > _Right.m_Operator)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaDataHeader &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaDataHeader &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaDataHeader &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeText
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	HPMString m_Text;
	HPMFindCriteriaTypeText()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeText(HPMFindCriteriaTypeText const &_Right)
		: m_Header(_Right.m_Header)
		, m_Text(_Right.m_Text)
	{
	}
	HPMFindCriteriaTypeText(HPMFindCriteriaTypeText &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_Text(std::move(_Right.m_Text))
	{
	}
	HPMFindCriteriaTypeText &operator =(HPMFindCriteriaTypeText const &_Right)
	{
		m_Header = _Right.m_Header;
		m_Text = _Right.m_Text;
		return *this;
	}
	HPMFindCriteriaTypeText &operator =(HPMFindCriteriaTypeText &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_Text = std::move(_Right.m_Text);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeText &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_Text != _Right.m_Text)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeText &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeText &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_Text < _Right.m_Text)
			return true;
		if (m_Text > _Right.m_Text)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeText &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeText &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeText &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeInteger
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	HPMInt64 m_Number;
	HPMInt64 m_ToNumber;
	HPMFindCriteriaTypeInteger()
		: m_Number(0)
		, m_ToNumber(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeInteger(HPMFindCriteriaTypeInteger const &_Right)
		: m_Header(_Right.m_Header)
		, m_Number(_Right.m_Number)
		, m_ToNumber(_Right.m_ToNumber)
	{
	}
	HPMFindCriteriaTypeInteger(HPMFindCriteriaTypeInteger &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_Number(std::move(_Right.m_Number))
		, m_ToNumber(std::move(_Right.m_ToNumber))
	{
	}
	HPMFindCriteriaTypeInteger &operator =(HPMFindCriteriaTypeInteger const &_Right)
	{
		m_Header = _Right.m_Header;
		m_Number = _Right.m_Number;
		m_ToNumber = _Right.m_ToNumber;
		return *this;
	}
	HPMFindCriteriaTypeInteger &operator =(HPMFindCriteriaTypeInteger &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_Number = std::move(_Right.m_Number);
		m_ToNumber = std::move(_Right.m_ToNumber);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeInteger &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_Number != _Right.m_Number)
			return false;
		if (m_ToNumber != _Right.m_ToNumber)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeInteger &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeInteger &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_Number < _Right.m_Number)
			return true;
		if (m_Number > _Right.m_Number)
			return false;
		if (m_ToNumber < _Right.m_ToNumber)
			return true;
		if (m_ToNumber > _Right.m_ToNumber)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeInteger &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeInteger &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeInteger &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeFloat
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	HPMFP64 m_Number;
	HPMFP64 m_ToNumber;
	HPMFindCriteriaTypeFloat()
		: m_Number(0.0)
		, m_ToNumber(0.0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeFloat(HPMFindCriteriaTypeFloat const &_Right)
		: m_Header(_Right.m_Header)
		, m_Number(_Right.m_Number)
		, m_ToNumber(_Right.m_ToNumber)
	{
	}
	HPMFindCriteriaTypeFloat(HPMFindCriteriaTypeFloat &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_Number(std::move(_Right.m_Number))
		, m_ToNumber(std::move(_Right.m_ToNumber))
	{
	}
	HPMFindCriteriaTypeFloat &operator =(HPMFindCriteriaTypeFloat const &_Right)
	{
		m_Header = _Right.m_Header;
		m_Number = _Right.m_Number;
		m_ToNumber = _Right.m_ToNumber;
		return *this;
	}
	HPMFindCriteriaTypeFloat &operator =(HPMFindCriteriaTypeFloat &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_Number = std::move(_Right.m_Number);
		m_ToNumber = std::move(_Right.m_ToNumber);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeFloat &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_Number != _Right.m_Number)
			return false;
		if (m_ToNumber != _Right.m_ToNumber)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeFloat &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeFloat &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_Number < _Right.m_Number)
			return true;
		if (m_Number > _Right.m_Number)
			return false;
		if (m_ToNumber < _Right.m_ToNumber)
			return true;
		if (m_ToNumber > _Right.m_ToNumber)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeFloat &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeFloat &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeFloat &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeGeneralCondition
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	HPMFindCriteriaTypeGeneralCondition()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeGeneralCondition(HPMFindCriteriaTypeGeneralCondition const &_Right)
		: m_Header(_Right.m_Header)
	{
	}
	HPMFindCriteriaTypeGeneralCondition(HPMFindCriteriaTypeGeneralCondition &&_Right)
		: m_Header(std::move(_Right.m_Header))
	{
	}
	HPMFindCriteriaTypeGeneralCondition &operator =(HPMFindCriteriaTypeGeneralCondition const &_Right)
	{
		m_Header = _Right.m_Header;
		return *this;
	}
	HPMFindCriteriaTypeGeneralCondition &operator =(HPMFindCriteriaTypeGeneralCondition &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeGeneralCondition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeDate
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	HPMUInt64 m_Date;
	HPMUInt64 m_ToDate;
	HPMInt32 m_Range;
	HPMString m_Text;
	HPMFindCriteriaTypeDate()
		: m_Date(0)
		, m_ToDate(0)
		, m_Range(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeDate(HPMFindCriteriaTypeDate const &_Right)
		: m_Header(_Right.m_Header)
		, m_Date(_Right.m_Date)
		, m_ToDate(_Right.m_ToDate)
		, m_Range(_Right.m_Range)
		, m_Text(_Right.m_Text)
	{
	}
	HPMFindCriteriaTypeDate(HPMFindCriteriaTypeDate &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_Date(std::move(_Right.m_Date))
		, m_ToDate(std::move(_Right.m_ToDate))
		, m_Range(std::move(_Right.m_Range))
		, m_Text(std::move(_Right.m_Text))
	{
	}
	HPMFindCriteriaTypeDate &operator =(HPMFindCriteriaTypeDate const &_Right)
	{
		m_Header = _Right.m_Header;
		m_Date = _Right.m_Date;
		m_ToDate = _Right.m_ToDate;
		m_Range = _Right.m_Range;
		m_Text = _Right.m_Text;
		return *this;
	}
	HPMFindCriteriaTypeDate &operator =(HPMFindCriteriaTypeDate &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_Date = std::move(_Right.m_Date);
		m_ToDate = std::move(_Right.m_ToDate);
		m_Range = std::move(_Right.m_Range);
		m_Text = std::move(_Right.m_Text);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeDate &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_Date != _Right.m_Date)
			return false;
		if (m_ToDate != _Right.m_ToDate)
			return false;
		if (m_Range != _Right.m_Range)
			return false;
		if (m_Text != _Right.m_Text)
			return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeDate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeDate &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_ToDate < _Right.m_ToDate)
			return true;
		if (m_ToDate > _Right.m_ToDate)
			return false;
		if (m_Range < _Right.m_Range)
			return true;
		if (m_Range > _Right.m_Range)
			return false;
		if (m_Text < _Right.m_Text)
			return true;
		if (m_Text > _Right.m_Text)
			return false;
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeDate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeDate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeDate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeDroplist
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	std::vector<HPMFindCriteriaDataListItem> m_ListItems;
	HPMFindCriteriaTypeDroplist()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeDroplist(HPMFindCriteriaTypeDroplist const &_Right)
		: m_Header(_Right.m_Header)
		, m_ListItems(_Right.m_ListItems)
	{
	}
	HPMFindCriteriaTypeDroplist(HPMFindCriteriaTypeDroplist &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_ListItems(std::move(_Right.m_ListItems))
	{
	}
	HPMFindCriteriaTypeDroplist &operator =(HPMFindCriteriaTypeDroplist const &_Right)
	{
		m_Header = _Right.m_Header;
		m_ListItems = _Right.m_ListItems;
		return *this;
	}
	HPMFindCriteriaTypeDroplist &operator =(HPMFindCriteriaTypeDroplist &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_ListItems = std::move(_Right.m_ListItems);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_ListItems.size() != _Right.m_ListItems.size())
			return false;
		for (size_t i = 0; i < m_ListItems.size(); ++i)
			if (m_ListItems[i] != _Right.m_ListItems[i])
				return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_ListItems.size() < _Right.m_ListItems.size())
			return true;
		if (m_ListItems.size() > _Right.m_ListItems.size())
			return false;
		for (size_t i = 0; i < m_ListItems.size(); ++i)
		{
			if (m_ListItems[i] < _Right.m_ListItems[i])
				return true;
			if (m_ListItems[i] > _Right.m_ListItems[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeDroplist &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMFindCriteriaTypeMultiSelectDroplist
{
	public:
	HPMFindCriteriaDataHeader m_Header;
	std::vector<HPMFindCriteriaDataListItem> m_ListItems;
	HPMFindCriteriaTypeMultiSelectDroplist()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMFindCriteriaTypeMultiSelectDroplist(HPMFindCriteriaTypeMultiSelectDroplist const &_Right)
		: m_Header(_Right.m_Header)
		, m_ListItems(_Right.m_ListItems)
	{
	}
	HPMFindCriteriaTypeMultiSelectDroplist(HPMFindCriteriaTypeMultiSelectDroplist &&_Right)
		: m_Header(std::move(_Right.m_Header))
		, m_ListItems(std::move(_Right.m_ListItems))
	{
	}
	HPMFindCriteriaTypeMultiSelectDroplist &operator =(HPMFindCriteriaTypeMultiSelectDroplist const &_Right)
	{
		m_Header = _Right.m_Header;
		m_ListItems = _Right.m_ListItems;
		return *this;
	}
	HPMFindCriteriaTypeMultiSelectDroplist &operator =(HPMFindCriteriaTypeMultiSelectDroplist &&_Right)
	{
		m_Header = std::move(_Right.m_Header);
		m_ListItems = std::move(_Right.m_ListItems);
		return *this;
	}
#endif
	bool operator == (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		if (m_Header != _Right.m_Header)
			return false;
		if (m_ListItems.size() != _Right.m_ListItems.size())
			return false;
		for (size_t i = 0; i < m_ListItems.size(); ++i)
			if (m_ListItems[i] != _Right.m_ListItems[i])
				return false;
		return true;
	}
	bool operator != (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		if (m_Header < _Right.m_Header)
			return true;
		if (m_Header > _Right.m_Header)
			return false;
		if (m_ListItems.size() < _Right.m_ListItems.size())
			return true;
		if (m_ListItems.size() > _Right.m_ListItems.size())
			return false;
		for (size_t i = 0; i < m_ListItems.size(); ++i)
		{
			if (m_ListItems[i] < _Right.m_ListItems[i])
				return true;
			if (m_ListItems[i] > _Right.m_ListItems[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMFindCriteriaTypeMultiSelectDroplist &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMReportEmailProperties
{
	public:
	EHPMPeriodicityType m_PeriodicityType;
	HPMInt32 m_DayOfWeek;
	HPMInt32 m_HourOfDay;
	HPMResourceDefinitionList m_RecipientList;
	HPMReportEmailProperties()
		: m_PeriodicityType(EHPMPeriodicityType_Never)
		, m_DayOfWeek(0)
		, m_HourOfDay(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMReportEmailProperties(HPMReportEmailProperties const &_Right)
		: m_PeriodicityType(_Right.m_PeriodicityType)
		, m_DayOfWeek(_Right.m_DayOfWeek)
		, m_HourOfDay(_Right.m_HourOfDay)
		, m_RecipientList(_Right.m_RecipientList)
	{
	}
	HPMReportEmailProperties(HPMReportEmailProperties &&_Right)
		: m_PeriodicityType(std::move(_Right.m_PeriodicityType))
		, m_DayOfWeek(std::move(_Right.m_DayOfWeek))
		, m_HourOfDay(std::move(_Right.m_HourOfDay))
		, m_RecipientList(std::move(_Right.m_RecipientList))
	{
	}
	HPMReportEmailProperties &operator =(HPMReportEmailProperties const &_Right)
	{
		m_PeriodicityType = _Right.m_PeriodicityType;
		m_DayOfWeek = _Right.m_DayOfWeek;
		m_HourOfDay = _Right.m_HourOfDay;
		m_RecipientList = _Right.m_RecipientList;
		return *this;
	}
	HPMReportEmailProperties &operator =(HPMReportEmailProperties &&_Right)
	{
		m_PeriodicityType = std::move(_Right.m_PeriodicityType);
		m_DayOfWeek = std::move(_Right.m_DayOfWeek);
		m_HourOfDay = std::move(_Right.m_HourOfDay);
		m_RecipientList = std::move(_Right.m_RecipientList);
		return *this;
	}
#endif
	bool operator == (const HPMReportEmailProperties &_Right) const
	{
		if (m_PeriodicityType != _Right.m_PeriodicityType)
			return false;
		if (m_DayOfWeek != _Right.m_DayOfWeek)
			return false;
		if (m_HourOfDay != _Right.m_HourOfDay)
			return false;
		if (m_RecipientList != _Right.m_RecipientList)
			return false;
		return true;
	}
	bool operator != (const HPMReportEmailProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMReportEmailProperties &_Right) const
	{
		if (m_PeriodicityType < _Right.m_PeriodicityType)
			return true;
		if (m_PeriodicityType > _Right.m_PeriodicityType)
			return false;
		if (m_DayOfWeek < _Right.m_DayOfWeek)
			return true;
		if (m_DayOfWeek > _Right.m_DayOfWeek)
			return false;
		if (m_HourOfDay < _Right.m_HourOfDay)
			return true;
		if (m_HourOfDay > _Right.m_HourOfDay)
			return false;
		if (m_RecipientList < _Right.m_RecipientList)
			return true;
		if (m_RecipientList > _Right.m_RecipientList)
			return false;
		return false;
	}
	bool operator > (const HPMReportEmailProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMReportEmailProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMReportEmailProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMReportSortGroupProperties
{
	public:
	HPMColumn m_Column;
	EHPMReportSortGroupOrderType m_OrderType;
	bool m_bDescending;
	HPMReportSortGroupProperties()
		: m_OrderType(EHPMReportSortGroupOrderType_None)
		, m_bDescending(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMReportSortGroupProperties(HPMReportSortGroupProperties const &_Right)
		: m_Column(_Right.m_Column)
		, m_OrderType(_Right.m_OrderType)
		, m_bDescending(_Right.m_bDescending)
	{
	}
	HPMReportSortGroupProperties(HPMReportSortGroupProperties &&_Right)
		: m_Column(std::move(_Right.m_Column))
		, m_OrderType(std::move(_Right.m_OrderType))
		, m_bDescending(std::move(_Right.m_bDescending))
	{
	}
	HPMReportSortGroupProperties &operator =(HPMReportSortGroupProperties const &_Right)
	{
		m_Column = _Right.m_Column;
		m_OrderType = _Right.m_OrderType;
		m_bDescending = _Right.m_bDescending;
		return *this;
	}
	HPMReportSortGroupProperties &operator =(HPMReportSortGroupProperties &&_Right)
	{
		m_Column = std::move(_Right.m_Column);
		m_OrderType = std::move(_Right.m_OrderType);
		m_bDescending = std::move(_Right.m_bDescending);
		return *this;
	}
#endif
	bool operator == (const HPMReportSortGroupProperties &_Right) const
	{
		if (m_Column != _Right.m_Column)
			return false;
		if (m_OrderType != _Right.m_OrderType)
			return false;
		if (m_bDescending != _Right.m_bDescending)
			return false;
		return true;
	}
	bool operator != (const HPMReportSortGroupProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMReportSortGroupProperties &_Right) const
	{
		if (m_Column < _Right.m_Column)
			return true;
		if (m_Column > _Right.m_Column)
			return false;
		if (m_OrderType < _Right.m_OrderType)
			return true;
		if (m_OrderType > _Right.m_OrderType)
			return false;
		if (m_bDescending < _Right.m_bDescending)
			return true;
		if (m_bDescending > _Right.m_bDescending)
			return false;
		return false;
	}
	bool operator > (const HPMReportSortGroupProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMReportSortGroupProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMReportSortGroupProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMReport
{
	public:
	HPMUniqueID m_ReportID;
	HPMUInt64 m_ReportGUID;
	HPMString m_Name;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	EHPMReportFlag m_Flags;
	EHPMListIcon m_Icon;
	std::vector<HPMColumn> m_ColumnsShowing;
	HPMReportEmailProperties m_EmailProperties;
	HPMResourceDefinitionList m_ShareResourceList;
	std::vector<HPMReportSortGroupProperties> m_SortColumns;
	HPMReportSortGroupProperties m_GroupByColumnMain;
	HPMReportSortGroupProperties m_GroupByColumnSub;
	std::vector<HPMFindCriteria> m_FindCriterias;
	HPMReport()
		: m_ReportGUID(0)
		, m_Flags(EHPMReportFlag_None)
		, m_Icon(EHPMListIcon_Default)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMReport(HPMReport const &_Right)
		: m_ReportID(_Right.m_ReportID)
		, m_ReportGUID(_Right.m_ReportGUID)
		, m_Name(_Right.m_Name)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Flags(_Right.m_Flags)
		, m_Icon(_Right.m_Icon)
		, m_ColumnsShowing(_Right.m_ColumnsShowing)
		, m_EmailProperties(_Right.m_EmailProperties)
		, m_ShareResourceList(_Right.m_ShareResourceList)
		, m_SortColumns(_Right.m_SortColumns)
		, m_GroupByColumnMain(_Right.m_GroupByColumnMain)
		, m_GroupByColumnSub(_Right.m_GroupByColumnSub)
		, m_FindCriterias(_Right.m_FindCriterias)
	{
	}
	HPMReport(HPMReport &&_Right)
		: m_ReportID(std::move(_Right.m_ReportID))
		, m_ReportGUID(std::move(_Right.m_ReportGUID))
		, m_Name(std::move(_Right.m_Name))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Flags(std::move(_Right.m_Flags))
		, m_Icon(std::move(_Right.m_Icon))
		, m_ColumnsShowing(std::move(_Right.m_ColumnsShowing))
		, m_EmailProperties(std::move(_Right.m_EmailProperties))
		, m_ShareResourceList(std::move(_Right.m_ShareResourceList))
		, m_SortColumns(std::move(_Right.m_SortColumns))
		, m_GroupByColumnMain(std::move(_Right.m_GroupByColumnMain))
		, m_GroupByColumnSub(std::move(_Right.m_GroupByColumnSub))
		, m_FindCriterias(std::move(_Right.m_FindCriterias))
	{
	}
	HPMReport &operator =(HPMReport const &_Right)
	{
		m_ReportID = _Right.m_ReportID;
		m_ReportGUID = _Right.m_ReportGUID;
		m_Name = _Right.m_Name;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_Flags = _Right.m_Flags;
		m_Icon = _Right.m_Icon;
		m_ColumnsShowing = _Right.m_ColumnsShowing;
		m_EmailProperties = _Right.m_EmailProperties;
		m_ShareResourceList = _Right.m_ShareResourceList;
		m_SortColumns = _Right.m_SortColumns;
		m_GroupByColumnMain = _Right.m_GroupByColumnMain;
		m_GroupByColumnSub = _Right.m_GroupByColumnSub;
		m_FindCriterias = _Right.m_FindCriterias;
		return *this;
	}
	HPMReport &operator =(HPMReport &&_Right)
	{
		m_ReportID = std::move(_Right.m_ReportID);
		m_ReportGUID = std::move(_Right.m_ReportGUID);
		m_Name = std::move(_Right.m_Name);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Flags = std::move(_Right.m_Flags);
		m_Icon = std::move(_Right.m_Icon);
		m_ColumnsShowing = std::move(_Right.m_ColumnsShowing);
		m_EmailProperties = std::move(_Right.m_EmailProperties);
		m_ShareResourceList = std::move(_Right.m_ShareResourceList);
		m_SortColumns = std::move(_Right.m_SortColumns);
		m_GroupByColumnMain = std::move(_Right.m_GroupByColumnMain);
		m_GroupByColumnSub = std::move(_Right.m_GroupByColumnSub);
		m_FindCriterias = std::move(_Right.m_FindCriterias);
		return *this;
	}
#endif
	bool operator == (const HPMReport &_Right) const
	{
		if (m_ReportID != _Right.m_ReportID)
			return false;
		if (m_ReportGUID != _Right.m_ReportGUID)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_Icon != _Right.m_Icon)
			return false;
		if (m_ColumnsShowing.size() != _Right.m_ColumnsShowing.size())
			return false;
		for (size_t i = 0; i < m_ColumnsShowing.size(); ++i)
			if (m_ColumnsShowing[i] != _Right.m_ColumnsShowing[i])
				return false;
		if (m_EmailProperties != _Right.m_EmailProperties)
			return false;
		if (m_ShareResourceList != _Right.m_ShareResourceList)
			return false;
		if (m_SortColumns.size() != _Right.m_SortColumns.size())
			return false;
		for (size_t i = 0; i < m_SortColumns.size(); ++i)
			if (m_SortColumns[i] != _Right.m_SortColumns[i])
				return false;
		if (m_GroupByColumnMain != _Right.m_GroupByColumnMain)
			return false;
		if (m_GroupByColumnSub != _Right.m_GroupByColumnSub)
			return false;
		if (m_FindCriterias.size() != _Right.m_FindCriterias.size())
			return false;
		for (size_t i = 0; i < m_FindCriterias.size(); ++i)
			if (m_FindCriterias[i] != _Right.m_FindCriterias[i])
				return false;
		return true;
	}
	bool operator != (const HPMReport &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMReport &_Right) const
	{
		if (m_ReportID < _Right.m_ReportID)
			return true;
		if (m_ReportID > _Right.m_ReportID)
			return false;
		if (m_ReportGUID < _Right.m_ReportGUID)
			return true;
		if (m_ReportGUID > _Right.m_ReportGUID)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_Icon < _Right.m_Icon)
			return true;
		if (m_Icon > _Right.m_Icon)
			return false;
		if (m_ColumnsShowing.size() < _Right.m_ColumnsShowing.size())
			return true;
		if (m_ColumnsShowing.size() > _Right.m_ColumnsShowing.size())
			return false;
		for (size_t i = 0; i < m_ColumnsShowing.size(); ++i)
		{
			if (m_ColumnsShowing[i] < _Right.m_ColumnsShowing[i])
				return true;
			if (m_ColumnsShowing[i] > _Right.m_ColumnsShowing[i])
				return false;
		}
		if (m_EmailProperties < _Right.m_EmailProperties)
			return true;
		if (m_EmailProperties > _Right.m_EmailProperties)
			return false;
		if (m_ShareResourceList < _Right.m_ShareResourceList)
			return true;
		if (m_ShareResourceList > _Right.m_ShareResourceList)
			return false;
		if (m_SortColumns.size() < _Right.m_SortColumns.size())
			return true;
		if (m_SortColumns.size() > _Right.m_SortColumns.size())
			return false;
		for (size_t i = 0; i < m_SortColumns.size(); ++i)
		{
			if (m_SortColumns[i] < _Right.m_SortColumns[i])
				return true;
			if (m_SortColumns[i] > _Right.m_SortColumns[i])
				return false;
		}
		if (m_GroupByColumnMain < _Right.m_GroupByColumnMain)
			return true;
		if (m_GroupByColumnMain > _Right.m_GroupByColumnMain)
			return false;
		if (m_GroupByColumnSub < _Right.m_GroupByColumnSub)
			return true;
		if (m_GroupByColumnSub > _Right.m_GroupByColumnSub)
			return false;
		if (m_FindCriterias.size() < _Right.m_FindCriterias.size())
			return true;
		if (m_FindCriterias.size() > _Right.m_FindCriterias.size())
			return false;
		for (size_t i = 0; i < m_FindCriterias.size(); ++i)
		{
			if (m_FindCriterias[i] < _Right.m_FindCriterias[i])
				return true;
			if (m_FindCriterias[i] > _Right.m_FindCriterias[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMReport &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMReport &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMReport &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMReports
{
	public:
	std::vector<HPMReport> m_Reports;
	HPMReports()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMReports(HPMReports const &_Right)
		: m_Reports(_Right.m_Reports)
	{
	}
	HPMReports(HPMReports &&_Right)
		: m_Reports(std::move(_Right.m_Reports))
	{
	}
	HPMReports &operator =(HPMReports const &_Right)
	{
		m_Reports = _Right.m_Reports;
		return *this;
	}
	HPMReports &operator =(HPMReports &&_Right)
	{
		m_Reports = std::move(_Right.m_Reports);
		return *this;
	}
#endif
	bool operator == (const HPMReports &_Right) const
	{
		if (m_Reports.size() != _Right.m_Reports.size())
			return false;
		for (size_t i = 0; i < m_Reports.size(); ++i)
			if (m_Reports[i] != _Right.m_Reports[i])
				return false;
		return true;
	}
	bool operator != (const HPMReports &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMReports &_Right) const
	{
		if (m_Reports.size() < _Right.m_Reports.size())
			return true;
		if (m_Reports.size() > _Right.m_Reports.size())
			return false;
		for (size_t i = 0; i < m_Reports.size(); ++i)
		{
			if (m_Reports[i] < _Right.m_Reports[i])
				return true;
			if (m_Reports[i] > _Right.m_Reports[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMReports &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMReports &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMReports &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkflowProgressionState
{
	public:
	HPMUInt32 m_StatusID;
	std::vector<HPMTaskField> m_RequiredFields;
	HPMWorkflowProgressionState()
		: m_StatusID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkflowProgressionState(HPMWorkflowProgressionState const &_Right)
		: m_StatusID(_Right.m_StatusID)
		, m_RequiredFields(_Right.m_RequiredFields)
	{
	}
	HPMWorkflowProgressionState(HPMWorkflowProgressionState &&_Right)
		: m_StatusID(std::move(_Right.m_StatusID))
		, m_RequiredFields(std::move(_Right.m_RequiredFields))
	{
	}
	HPMWorkflowProgressionState &operator =(HPMWorkflowProgressionState const &_Right)
	{
		m_StatusID = _Right.m_StatusID;
		m_RequiredFields = _Right.m_RequiredFields;
		return *this;
	}
	HPMWorkflowProgressionState &operator =(HPMWorkflowProgressionState &&_Right)
	{
		m_StatusID = std::move(_Right.m_StatusID);
		m_RequiredFields = std::move(_Right.m_RequiredFields);
		return *this;
	}
#endif
	bool operator == (const HPMWorkflowProgressionState &_Right) const
	{
		if (m_StatusID != _Right.m_StatusID)
			return false;
		if (m_RequiredFields.size() != _Right.m_RequiredFields.size())
			return false;
		for (size_t i = 0; i < m_RequiredFields.size(); ++i)
			if (m_RequiredFields[i] != _Right.m_RequiredFields[i])
				return false;
		return true;
	}
	bool operator != (const HPMWorkflowProgressionState &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkflowProgressionState &_Right) const
	{
		if (m_StatusID < _Right.m_StatusID)
			return true;
		if (m_StatusID > _Right.m_StatusID)
			return false;
		if (m_RequiredFields.size() < _Right.m_RequiredFields.size())
			return true;
		if (m_RequiredFields.size() > _Right.m_RequiredFields.size())
			return false;
		for (size_t i = 0; i < m_RequiredFields.size(); ++i)
		{
			if (m_RequiredFields[i] < _Right.m_RequiredFields[i])
				return true;
			if (m_RequiredFields[i] > _Right.m_RequiredFields[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMWorkflowProgressionState &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkflowProgressionState &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkflowProgressionState &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkflowProgressionStructure
{
	public:
	std::vector<HPMWorkflowProgressionState> m_ProgressionStates;
	HPMWorkflowProgressionStructure()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkflowProgressionStructure(HPMWorkflowProgressionStructure const &_Right)
		: m_ProgressionStates(_Right.m_ProgressionStates)
	{
	}
	HPMWorkflowProgressionStructure(HPMWorkflowProgressionStructure &&_Right)
		: m_ProgressionStates(std::move(_Right.m_ProgressionStates))
	{
	}
	HPMWorkflowProgressionStructure &operator =(HPMWorkflowProgressionStructure const &_Right)
	{
		m_ProgressionStates = _Right.m_ProgressionStates;
		return *this;
	}
	HPMWorkflowProgressionStructure &operator =(HPMWorkflowProgressionStructure &&_Right)
	{
		m_ProgressionStates = std::move(_Right.m_ProgressionStates);
		return *this;
	}
#endif
	bool operator == (const HPMWorkflowProgressionStructure &_Right) const
	{
		if (m_ProgressionStates.size() != _Right.m_ProgressionStates.size())
			return false;
		for (size_t i = 0; i < m_ProgressionStates.size(); ++i)
			if (m_ProgressionStates[i] != _Right.m_ProgressionStates[i])
				return false;
		return true;
	}
	bool operator != (const HPMWorkflowProgressionStructure &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkflowProgressionStructure &_Right) const
	{
		if (m_ProgressionStates.size() < _Right.m_ProgressionStates.size())
			return true;
		if (m_ProgressionStates.size() > _Right.m_ProgressionStates.size())
			return false;
		for (size_t i = 0; i < m_ProgressionStates.size(); ++i)
		{
			if (m_ProgressionStates[i] < _Right.m_ProgressionStates[i])
				return true;
			if (m_ProgressionStates[i] > _Right.m_ProgressionStates[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMWorkflowProgressionStructure &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkflowProgressionStructure &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkflowProgressionStructure &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCommunicationChannelPacket
{
	public:
	std::vector<HPMUInt8> m_Bytes;
	EHPMPacketFlag m_Flags;
	HPMCommunicationChannelPacket()
		: m_Flags(EHPMPacketFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCommunicationChannelPacket(HPMCommunicationChannelPacket const &_Right)
		: m_Bytes(_Right.m_Bytes)
		, m_Flags(_Right.m_Flags)
	{
	}
	HPMCommunicationChannelPacket(HPMCommunicationChannelPacket &&_Right)
		: m_Bytes(std::move(_Right.m_Bytes))
		, m_Flags(std::move(_Right.m_Flags))
	{
	}
	HPMCommunicationChannelPacket &operator =(HPMCommunicationChannelPacket const &_Right)
	{
		m_Bytes = _Right.m_Bytes;
		m_Flags = _Right.m_Flags;
		return *this;
	}
	HPMCommunicationChannelPacket &operator =(HPMCommunicationChannelPacket &&_Right)
	{
		m_Bytes = std::move(_Right.m_Bytes);
		m_Flags = std::move(_Right.m_Flags);
		return *this;
	}
#endif
	bool operator == (const HPMCommunicationChannelPacket &_Right) const
	{
		if (m_Bytes.size() != _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
			if (m_Bytes[i] != _Right.m_Bytes[i])
				return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		return true;
	}
	bool operator != (const HPMCommunicationChannelPacket &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCommunicationChannelPacket &_Right) const
	{
		if (m_Bytes.size() < _Right.m_Bytes.size())
			return true;
		if (m_Bytes.size() > _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
		{
			if (m_Bytes[i] < _Right.m_Bytes[i])
				return true;
			if (m_Bytes[i] > _Right.m_Bytes[i])
				return false;
		}
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		return false;
	}
	bool operator > (const HPMCommunicationChannelPacket &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCommunicationChannelPacket &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCommunicationChannelPacket &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTimesheetConfigRow
{
	public:
	HPMUInt32 m_RowID;
	HPMUntranslatedString m_RowName;
	HPMTimesheetConfigRow()
		: m_RowID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTimesheetConfigRow(HPMTimesheetConfigRow const &_Right)
		: m_RowID(_Right.m_RowID)
		, m_RowName(_Right.m_RowName)
	{
	}
	HPMTimesheetConfigRow(HPMTimesheetConfigRow &&_Right)
		: m_RowID(std::move(_Right.m_RowID))
		, m_RowName(std::move(_Right.m_RowName))
	{
	}
	HPMTimesheetConfigRow &operator =(HPMTimesheetConfigRow const &_Right)
	{
		m_RowID = _Right.m_RowID;
		m_RowName = _Right.m_RowName;
		return *this;
	}
	HPMTimesheetConfigRow &operator =(HPMTimesheetConfigRow &&_Right)
	{
		m_RowID = std::move(_Right.m_RowID);
		m_RowName = std::move(_Right.m_RowName);
		return *this;
	}
#endif
	bool operator == (const HPMTimesheetConfigRow &_Right) const
	{
		if (m_RowID != _Right.m_RowID)
			return false;
		if (m_RowName != _Right.m_RowName)
			return false;
		return true;
	}
	bool operator != (const HPMTimesheetConfigRow &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTimesheetConfigRow &_Right) const
	{
		if (m_RowID < _Right.m_RowID)
			return true;
		if (m_RowID > _Right.m_RowID)
			return false;
		if (m_RowName < _Right.m_RowName)
			return true;
		if (m_RowName > _Right.m_RowName)
			return false;
		return false;
	}
	bool operator > (const HPMTimesheetConfigRow &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTimesheetConfigRow &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTimesheetConfigRow &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTimesheetActivity
{
	public:
	HPMInt32 m_RowID;
	HPMInt32 m_ActivityID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_Started;
	HPMUInt32 m_Duration;
	HPMString m_Comment;
	HPMTimesheetActivity()
		: m_Started(0)
		, m_Duration(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTimesheetActivity(HPMTimesheetActivity const &_Right)
		: m_RowID(_Right.m_RowID)
		, m_ActivityID(_Right.m_ActivityID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_TaskID(_Right.m_TaskID)
		, m_Started(_Right.m_Started)
		, m_Duration(_Right.m_Duration)
		, m_Comment(_Right.m_Comment)
	{
	}
	HPMTimesheetActivity(HPMTimesheetActivity &&_Right)
		: m_RowID(std::move(_Right.m_RowID))
		, m_ActivityID(std::move(_Right.m_ActivityID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_Started(std::move(_Right.m_Started))
		, m_Duration(std::move(_Right.m_Duration))
		, m_Comment(std::move(_Right.m_Comment))
	{
	}
	HPMTimesheetActivity &operator =(HPMTimesheetActivity const &_Right)
	{
		m_RowID = _Right.m_RowID;
		m_ActivityID = _Right.m_ActivityID;
		m_ProjectID = _Right.m_ProjectID;
		m_TaskID = _Right.m_TaskID;
		m_Started = _Right.m_Started;
		m_Duration = _Right.m_Duration;
		m_Comment = _Right.m_Comment;
		return *this;
	}
	HPMTimesheetActivity &operator =(HPMTimesheetActivity &&_Right)
	{
		m_RowID = std::move(_Right.m_RowID);
		m_ActivityID = std::move(_Right.m_ActivityID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_Started = std::move(_Right.m_Started);
		m_Duration = std::move(_Right.m_Duration);
		m_Comment = std::move(_Right.m_Comment);
		return *this;
	}
#endif
	bool operator == (const HPMTimesheetActivity &_Right) const
	{
		if (m_RowID != _Right.m_RowID)
			return false;
		if (m_ActivityID != _Right.m_ActivityID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_Started != _Right.m_Started)
			return false;
		if (m_Duration != _Right.m_Duration)
			return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		return true;
	}
	bool operator != (const HPMTimesheetActivity &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTimesheetActivity &_Right) const
	{
		if (m_RowID < _Right.m_RowID)
			return true;
		if (m_RowID > _Right.m_RowID)
			return false;
		if (m_ActivityID < _Right.m_ActivityID)
			return true;
		if (m_ActivityID > _Right.m_ActivityID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_Started < _Right.m_Started)
			return true;
		if (m_Started > _Right.m_Started)
			return false;
		if (m_Duration < _Right.m_Duration)
			return true;
		if (m_Duration > _Right.m_Duration)
			return false;
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		return false;
	}
	bool operator > (const HPMTimesheetActivity &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTimesheetActivity &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTimesheetActivity &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTimesheetDay
{
	public:
	HPMUniqueID m_DayID;
	HPMUniqueID m_ResourceID;
	HPMUInt64 m_Day;
	std::vector<HPMTimesheetActivity> m_Activities;
	HPMTimesheetDay()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTimesheetDay(HPMTimesheetDay const &_Right)
		: m_DayID(_Right.m_DayID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Day(_Right.m_Day)
		, m_Activities(_Right.m_Activities)
	{
	}
	HPMTimesheetDay(HPMTimesheetDay &&_Right)
		: m_DayID(std::move(_Right.m_DayID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Day(std::move(_Right.m_Day))
		, m_Activities(std::move(_Right.m_Activities))
	{
	}
	HPMTimesheetDay &operator =(HPMTimesheetDay const &_Right)
	{
		m_DayID = _Right.m_DayID;
		m_ResourceID = _Right.m_ResourceID;
		m_Day = _Right.m_Day;
		m_Activities = _Right.m_Activities;
		return *this;
	}
	HPMTimesheetDay &operator =(HPMTimesheetDay &&_Right)
	{
		m_DayID = std::move(_Right.m_DayID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Day = std::move(_Right.m_Day);
		m_Activities = std::move(_Right.m_Activities);
		return *this;
	}
#endif
	bool operator == (const HPMTimesheetDay &_Right) const
	{
		if (m_DayID != _Right.m_DayID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Day != _Right.m_Day)
			return false;
		if (m_Activities.size() != _Right.m_Activities.size())
			return false;
		for (size_t i = 0; i < m_Activities.size(); ++i)
			if (m_Activities[i] != _Right.m_Activities[i])
				return false;
		return true;
	}
	bool operator != (const HPMTimesheetDay &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTimesheetDay &_Right) const
	{
		if (m_DayID < _Right.m_DayID)
			return true;
		if (m_DayID > _Right.m_DayID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Day < _Right.m_Day)
			return true;
		if (m_Day > _Right.m_Day)
			return false;
		if (m_Activities.size() < _Right.m_Activities.size())
			return true;
		if (m_Activities.size() > _Right.m_Activities.size())
			return false;
		for (size_t i = 0; i < m_Activities.size(); ++i)
		{
			if (m_Activities[i] < _Right.m_Activities[i])
				return true;
			if (m_Activities[i] > _Right.m_Activities[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTimesheetDay &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTimesheetDay &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTimesheetDay &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMUniqueEnum
{
	public:
	std::vector<HPMUniqueID> m_IDs;
	HPMUniqueEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMUniqueEnum(HPMUniqueEnum const &_Right)
		: m_IDs(_Right.m_IDs)
	{
	}
	HPMUniqueEnum(HPMUniqueEnum &&_Right)
		: m_IDs(std::move(_Right.m_IDs))
	{
	}
	HPMUniqueEnum &operator =(HPMUniqueEnum const &_Right)
	{
		m_IDs = _Right.m_IDs;
		return *this;
	}
	HPMUniqueEnum &operator =(HPMUniqueEnum &&_Right)
	{
		m_IDs = std::move(_Right.m_IDs);
		return *this;
	}
#endif
	bool operator == (const HPMUniqueEnum &_Right) const
	{
		if (m_IDs.size() != _Right.m_IDs.size())
			return false;
		for (size_t i = 0; i < m_IDs.size(); ++i)
			if (m_IDs[i] != _Right.m_IDs[i])
				return false;
		return true;
	}
	bool operator != (const HPMUniqueEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMUniqueEnum &_Right) const
	{
		if (m_IDs.size() < _Right.m_IDs.size())
			return true;
		if (m_IDs.size() > _Right.m_IDs.size())
			return false;
		for (size_t i = 0; i < m_IDs.size(); ++i)
		{
			if (m_IDs[i] < _Right.m_IDs[i])
				return true;
			if (m_IDs[i] > _Right.m_IDs[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMUniqueEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMUniqueEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMUniqueEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTimesheetConfig
{
	public:
	HPMInt32 m_DefaultActivityType;
	HPMUInt32 m_DefaultStarted;
	HPMUInt32 m_DefaultDuration;
	bool m_bHideStartFinish;
	std::vector<HPMTimesheetConfigRow> m_Rows;
	HPMTimesheetConfig()
		: m_DefaultActivityType(0)
		, m_DefaultStarted(28800)
		, m_DefaultDuration(0)
		, m_bHideStartFinish(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTimesheetConfig(HPMTimesheetConfig const &_Right)
		: m_DefaultActivityType(_Right.m_DefaultActivityType)
		, m_DefaultStarted(_Right.m_DefaultStarted)
		, m_DefaultDuration(_Right.m_DefaultDuration)
		, m_bHideStartFinish(_Right.m_bHideStartFinish)
		, m_Rows(_Right.m_Rows)
	{
	}
	HPMTimesheetConfig(HPMTimesheetConfig &&_Right)
		: m_DefaultActivityType(std::move(_Right.m_DefaultActivityType))
		, m_DefaultStarted(std::move(_Right.m_DefaultStarted))
		, m_DefaultDuration(std::move(_Right.m_DefaultDuration))
		, m_bHideStartFinish(std::move(_Right.m_bHideStartFinish))
		, m_Rows(std::move(_Right.m_Rows))
	{
	}
	HPMTimesheetConfig &operator =(HPMTimesheetConfig const &_Right)
	{
		m_DefaultActivityType = _Right.m_DefaultActivityType;
		m_DefaultStarted = _Right.m_DefaultStarted;
		m_DefaultDuration = _Right.m_DefaultDuration;
		m_bHideStartFinish = _Right.m_bHideStartFinish;
		m_Rows = _Right.m_Rows;
		return *this;
	}
	HPMTimesheetConfig &operator =(HPMTimesheetConfig &&_Right)
	{
		m_DefaultActivityType = std::move(_Right.m_DefaultActivityType);
		m_DefaultStarted = std::move(_Right.m_DefaultStarted);
		m_DefaultDuration = std::move(_Right.m_DefaultDuration);
		m_bHideStartFinish = std::move(_Right.m_bHideStartFinish);
		m_Rows = std::move(_Right.m_Rows);
		return *this;
	}
#endif
	bool operator == (const HPMTimesheetConfig &_Right) const
	{
		if (m_DefaultActivityType != _Right.m_DefaultActivityType)
			return false;
		if (m_DefaultStarted != _Right.m_DefaultStarted)
			return false;
		if (m_DefaultDuration != _Right.m_DefaultDuration)
			return false;
		if (m_bHideStartFinish != _Right.m_bHideStartFinish)
			return false;
		if (m_Rows.size() != _Right.m_Rows.size())
			return false;
		for (size_t i = 0; i < m_Rows.size(); ++i)
			if (m_Rows[i] != _Right.m_Rows[i])
				return false;
		return true;
	}
	bool operator != (const HPMTimesheetConfig &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTimesheetConfig &_Right) const
	{
		if (m_DefaultActivityType < _Right.m_DefaultActivityType)
			return true;
		if (m_DefaultActivityType > _Right.m_DefaultActivityType)
			return false;
		if (m_DefaultStarted < _Right.m_DefaultStarted)
			return true;
		if (m_DefaultStarted > _Right.m_DefaultStarted)
			return false;
		if (m_DefaultDuration < _Right.m_DefaultDuration)
			return true;
		if (m_DefaultDuration > _Right.m_DefaultDuration)
			return false;
		if (m_bHideStartFinish < _Right.m_bHideStartFinish)
			return true;
		if (m_bHideStartFinish > _Right.m_bHideStartFinish)
			return false;
		if (m_Rows.size() < _Right.m_Rows.size())
			return true;
		if (m_Rows.size() > _Right.m_Rows.size())
			return false;
		for (size_t i = 0; i < m_Rows.size(); ++i)
		{
			if (m_Rows[i] < _Right.m_Rows[i])
				return true;
			if (m_Rows[i] > _Right.m_Rows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTimesheetConfig &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTimesheetConfig &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTimesheetConfig &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDynamicCustomSettingsContext
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMDynamicCustomSettingsContext *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMDynamicCustomSettingsContext *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMDynamicCustomSettingsContext()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDynamicCustomSettingsContext(HPMDynamicCustomSettingsContext const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMDynamicCustomSettingsContext(HPMDynamicCustomSettingsContext &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMDynamicCustomSettingsContext &operator =(HPMDynamicCustomSettingsContext const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMDynamicCustomSettingsContext &operator =(HPMDynamicCustomSettingsContext &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMDynamicCustomSettingsContext &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMDynamicCustomSettingsContext &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDynamicCustomSettingsContext &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMDynamicCustomSettingsContext &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDynamicCustomSettingsContext &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDynamicCustomSettingsContext &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMRightClickContext
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMRightClickContext *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMRightClickContext *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMRightClickContext()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMRightClickContext(HPMRightClickContext const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMRightClickContext(HPMRightClickContext &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMRightClickContext &operator =(HPMRightClickContext const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMRightClickContext &operator =(HPMRightClickContext &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMRightClickContext &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMRightClickContext &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMRightClickContext &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMRightClickContext &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMRightClickContext &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMRightClickContext &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDynamicCustomSettingsValue
{
	public:
	HPMString m_Path;
	HPMString m_Value;
	HPMDynamicCustomSettingsValue()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDynamicCustomSettingsValue(HPMDynamicCustomSettingsValue const &_Right)
		: m_Path(_Right.m_Path)
		, m_Value(_Right.m_Value)
	{
	}
	HPMDynamicCustomSettingsValue(HPMDynamicCustomSettingsValue &&_Right)
		: m_Path(std::move(_Right.m_Path))
		, m_Value(std::move(_Right.m_Value))
	{
	}
	HPMDynamicCustomSettingsValue &operator =(HPMDynamicCustomSettingsValue const &_Right)
	{
		m_Path = _Right.m_Path;
		m_Value = _Right.m_Value;
		return *this;
	}
	HPMDynamicCustomSettingsValue &operator =(HPMDynamicCustomSettingsValue &&_Right)
	{
		m_Path = std::move(_Right.m_Path);
		m_Value = std::move(_Right.m_Value);
		return *this;
	}
#endif
	bool operator == (const HPMDynamicCustomSettingsValue &_Right) const
	{
		if (m_Path != _Right.m_Path)
			return false;
		if (m_Value != _Right.m_Value)
			return false;
		return true;
	}
	bool operator != (const HPMDynamicCustomSettingsValue &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDynamicCustomSettingsValue &_Right) const
	{
		if (m_Path < _Right.m_Path)
			return true;
		if (m_Path > _Right.m_Path)
			return false;
		if (m_Value < _Right.m_Value)
			return true;
		if (m_Value > _Right.m_Value)
			return false;
		return false;
	}
	bool operator > (const HPMDynamicCustomSettingsValue &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDynamicCustomSettingsValue &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDynamicCustomSettingsValue &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDynamicCustomSettingsValues
{
	public:
	std::vector<HPMDynamicCustomSettingsValue> m_Values;
	HPMDynamicCustomSettingsValues()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDynamicCustomSettingsValues(HPMDynamicCustomSettingsValues const &_Right)
		: m_Values(_Right.m_Values)
	{
	}
	HPMDynamicCustomSettingsValues(HPMDynamicCustomSettingsValues &&_Right)
		: m_Values(std::move(_Right.m_Values))
	{
	}
	HPMDynamicCustomSettingsValues &operator =(HPMDynamicCustomSettingsValues const &_Right)
	{
		m_Values = _Right.m_Values;
		return *this;
	}
	HPMDynamicCustomSettingsValues &operator =(HPMDynamicCustomSettingsValues &&_Right)
	{
		m_Values = std::move(_Right.m_Values);
		return *this;
	}
#endif
	bool operator == (const HPMDynamicCustomSettingsValues &_Right) const
	{
		if (m_Values.size() != _Right.m_Values.size())
			return false;
		for (size_t i = 0; i < m_Values.size(); ++i)
			if (m_Values[i] != _Right.m_Values[i])
				return false;
		return true;
	}
	bool operator != (const HPMDynamicCustomSettingsValues &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDynamicCustomSettingsValues &_Right) const
	{
		if (m_Values.size() < _Right.m_Values.size())
			return true;
		if (m_Values.size() > _Right.m_Values.size())
			return false;
		for (size_t i = 0; i < m_Values.size(); ++i)
		{
			if (m_Values[i] < _Right.m_Values[i])
				return true;
			if (m_Values[i] > _Right.m_Values[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMDynamicCustomSettingsValues &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDynamicCustomSettingsValues &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDynamicCustomSettingsValues &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDynamicCustomSettingsPaths
{
	public:
	std::vector<HPMString> m_Paths;
	HPMDynamicCustomSettingsPaths()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDynamicCustomSettingsPaths(HPMDynamicCustomSettingsPaths const &_Right)
		: m_Paths(_Right.m_Paths)
	{
	}
	HPMDynamicCustomSettingsPaths(HPMDynamicCustomSettingsPaths &&_Right)
		: m_Paths(std::move(_Right.m_Paths))
	{
	}
	HPMDynamicCustomSettingsPaths &operator =(HPMDynamicCustomSettingsPaths const &_Right)
	{
		m_Paths = _Right.m_Paths;
		return *this;
	}
	HPMDynamicCustomSettingsPaths &operator =(HPMDynamicCustomSettingsPaths &&_Right)
	{
		m_Paths = std::move(_Right.m_Paths);
		return *this;
	}
#endif
	bool operator == (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		if (m_Paths.size() != _Right.m_Paths.size())
			return false;
		for (size_t i = 0; i < m_Paths.size(); ++i)
			if (m_Paths[i] != _Right.m_Paths[i])
				return false;
		return true;
	}
	bool operator != (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		if (m_Paths.size() < _Right.m_Paths.size())
			return true;
		if (m_Paths.size() > _Right.m_Paths.size())
			return false;
		for (size_t i = 0; i < m_Paths.size(); ++i)
		{
			if (m_Paths[i] < _Right.m_Paths[i])
				return true;
			if (m_Paths[i] > _Right.m_Paths[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDynamicCustomSettingsPaths &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChatRoom
{
	public:
	HPMResourceDefinition m_ChatResource1;
	HPMResourceDefinition m_ChatResource2;
	HPMChatRoom()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChatRoom(HPMChatRoom const &_Right)
		: m_ChatResource1(_Right.m_ChatResource1)
		, m_ChatResource2(_Right.m_ChatResource2)
	{
	}
	HPMChatRoom(HPMChatRoom &&_Right)
		: m_ChatResource1(std::move(_Right.m_ChatResource1))
		, m_ChatResource2(std::move(_Right.m_ChatResource2))
	{
	}
	HPMChatRoom &operator =(HPMChatRoom const &_Right)
	{
		m_ChatResource1 = _Right.m_ChatResource1;
		m_ChatResource2 = _Right.m_ChatResource2;
		return *this;
	}
	HPMChatRoom &operator =(HPMChatRoom &&_Right)
	{
		m_ChatResource1 = std::move(_Right.m_ChatResource1);
		m_ChatResource2 = std::move(_Right.m_ChatResource2);
		return *this;
	}
#endif
	bool operator == (const HPMChatRoom &_Right) const
	{
		if (m_ChatResource1 != _Right.m_ChatResource1)
			return false;
		if (m_ChatResource2 != _Right.m_ChatResource2)
			return false;
		return true;
	}
	bool operator != (const HPMChatRoom &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChatRoom &_Right) const
	{
		if (m_ChatResource1 < _Right.m_ChatResource1)
			return true;
		if (m_ChatResource1 > _Right.m_ChatResource1)
			return false;
		if (m_ChatResource2 < _Right.m_ChatResource2)
			return true;
		if (m_ChatResource2 > _Right.m_ChatResource2)
			return false;
		return false;
	}
	bool operator > (const HPMChatRoom &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChatRoom &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChatRoom &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChatMessage
{
	public:
	HPMInt64 m_ID;
	HPMString m_Message;
	HPMChatMessage()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChatMessage(HPMChatMessage const &_Right)
		: m_ID(_Right.m_ID)
		, m_Message(_Right.m_Message)
	{
	}
	HPMChatMessage(HPMChatMessage &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_Message(std::move(_Right.m_Message))
	{
	}
	HPMChatMessage &operator =(HPMChatMessage const &_Right)
	{
		m_ID = _Right.m_ID;
		m_Message = _Right.m_Message;
		return *this;
	}
	HPMChatMessage &operator =(HPMChatMessage &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_Message = std::move(_Right.m_Message);
		return *this;
	}
#endif
	bool operator == (const HPMChatMessage &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_Message != _Right.m_Message)
			return false;
		return true;
	}
	bool operator != (const HPMChatMessage &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChatMessage &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_Message < _Right.m_Message)
			return true;
		if (m_Message > _Right.m_Message)
			return false;
		return false;
	}
	bool operator > (const HPMChatMessage &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChatMessage &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChatMessage &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMLastAssignedInWorkflowStatus
{
	public:
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMResourceDefinitionList m_LastAssignedList;
	HPMLastAssignedInWorkflowStatus()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMLastAssignedInWorkflowStatus(HPMLastAssignedInWorkflowStatus const &_Right)
		: m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
		, m_LastAssignedList(_Right.m_LastAssignedList)
	{
	}
	HPMLastAssignedInWorkflowStatus(HPMLastAssignedInWorkflowStatus &&_Right)
		: m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
		, m_LastAssignedList(std::move(_Right.m_LastAssignedList))
	{
	}
	HPMLastAssignedInWorkflowStatus &operator =(HPMLastAssignedInWorkflowStatus const &_Right)
	{
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		m_LastAssignedList = _Right.m_LastAssignedList;
		return *this;
	}
	HPMLastAssignedInWorkflowStatus &operator =(HPMLastAssignedInWorkflowStatus &&_Right)
	{
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		m_LastAssignedList = std::move(_Right.m_LastAssignedList);
		return *this;
	}
#endif
	bool operator == (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		if (m_LastAssignedList != _Right.m_LastAssignedList)
			return false;
		return true;
	}
	bool operator != (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		if (m_LastAssignedList < _Right.m_LastAssignedList)
			return true;
		if (m_LastAssignedList > _Right.m_LastAssignedList)
			return false;
		return false;
	}
	bool operator > (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMLastAssignedInWorkflowStatus &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMLastAssignedInWorkflowStatuses
{
	public:
	std::vector<HPMLastAssignedInWorkflowStatus> m_LastAssignedList;
	HPMLastAssignedInWorkflowStatuses()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMLastAssignedInWorkflowStatuses(HPMLastAssignedInWorkflowStatuses const &_Right)
		: m_LastAssignedList(_Right.m_LastAssignedList)
	{
	}
	HPMLastAssignedInWorkflowStatuses(HPMLastAssignedInWorkflowStatuses &&_Right)
		: m_LastAssignedList(std::move(_Right.m_LastAssignedList))
	{
	}
	HPMLastAssignedInWorkflowStatuses &operator =(HPMLastAssignedInWorkflowStatuses const &_Right)
	{
		m_LastAssignedList = _Right.m_LastAssignedList;
		return *this;
	}
	HPMLastAssignedInWorkflowStatuses &operator =(HPMLastAssignedInWorkflowStatuses &&_Right)
	{
		m_LastAssignedList = std::move(_Right.m_LastAssignedList);
		return *this;
	}
#endif
	bool operator == (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		if (m_LastAssignedList.size() != _Right.m_LastAssignedList.size())
			return false;
		for (size_t i = 0; i < m_LastAssignedList.size(); ++i)
			if (m_LastAssignedList[i] != _Right.m_LastAssignedList[i])
				return false;
		return true;
	}
	bool operator != (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		if (m_LastAssignedList.size() < _Right.m_LastAssignedList.size())
			return true;
		if (m_LastAssignedList.size() > _Right.m_LastAssignedList.size())
			return false;
		for (size_t i = 0; i < m_LastAssignedList.size(); ++i)
		{
			if (m_LastAssignedList[i] < _Right.m_LastAssignedList[i])
				return true;
			if (m_LastAssignedList[i] > _Right.m_LastAssignedList[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMLastAssignedInWorkflowStatuses &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMLanguage
{
	public:
	HPMUInt16 m_LanguageID;
	HPMString m_CustomLanguageID;
	HPMLanguage()
		: m_LanguageID(0x0809)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMLanguage(HPMLanguage const &_Right)
		: m_LanguageID(_Right.m_LanguageID)
		, m_CustomLanguageID(_Right.m_CustomLanguageID)
	{
	}
	HPMLanguage(HPMLanguage &&_Right)
		: m_LanguageID(std::move(_Right.m_LanguageID))
		, m_CustomLanguageID(std::move(_Right.m_CustomLanguageID))
	{
	}
	HPMLanguage &operator =(HPMLanguage const &_Right)
	{
		m_LanguageID = _Right.m_LanguageID;
		m_CustomLanguageID = _Right.m_CustomLanguageID;
		return *this;
	}
	HPMLanguage &operator =(HPMLanguage &&_Right)
	{
		m_LanguageID = std::move(_Right.m_LanguageID);
		m_CustomLanguageID = std::move(_Right.m_CustomLanguageID);
		return *this;
	}
#endif
	bool operator == (const HPMLanguage &_Right) const
	{
		if (m_LanguageID != _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID != _Right.m_CustomLanguageID)
			return false;
		return true;
	}
	bool operator != (const HPMLanguage &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMLanguage &_Right) const
	{
		if (m_LanguageID < _Right.m_LanguageID)
			return true;
		if (m_LanguageID > _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID < _Right.m_CustomLanguageID)
			return true;
		if (m_CustomLanguageID > _Right.m_CustomLanguageID)
			return false;
		return false;
	}
	bool operator > (const HPMLanguage &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMLanguage &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMLanguage &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMLanguages
{
	public:
	std::vector<HPMLanguage> m_Languages;
	HPMLanguages()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMLanguages(HPMLanguages const &_Right)
		: m_Languages(_Right.m_Languages)
	{
	}
	HPMLanguages(HPMLanguages &&_Right)
		: m_Languages(std::move(_Right.m_Languages))
	{
	}
	HPMLanguages &operator =(HPMLanguages const &_Right)
	{
		m_Languages = _Right.m_Languages;
		return *this;
	}
	HPMLanguages &operator =(HPMLanguages &&_Right)
	{
		m_Languages = std::move(_Right.m_Languages);
		return *this;
	}
#endif
	bool operator == (const HPMLanguages &_Right) const
	{
		if (m_Languages.size() != _Right.m_Languages.size())
			return false;
		for (size_t i = 0; i < m_Languages.size(); ++i)
			if (m_Languages[i] != _Right.m_Languages[i])
				return false;
		return true;
	}
	bool operator != (const HPMLanguages &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMLanguages &_Right) const
	{
		if (m_Languages.size() < _Right.m_Languages.size())
			return true;
		if (m_Languages.size() > _Right.m_Languages.size())
			return false;
		for (size_t i = 0; i < m_Languages.size(); ++i)
		{
			if (m_Languages[i] < _Right.m_Languages[i])
				return true;
			if (m_Languages[i] > _Right.m_Languages[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMLanguages &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMLanguages &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMLanguages &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMUntranslatedStringParamListEntry
{
	public:
	HPMVariantData m_VariantData;
	HPMUntranslatedStringParamListEntry()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMUntranslatedStringParamListEntry(HPMUntranslatedStringParamListEntry const &_Right)
		: m_VariantData(_Right.m_VariantData)
	{
	}
	HPMUntranslatedStringParamListEntry(HPMUntranslatedStringParamListEntry &&_Right)
		: m_VariantData(std::move(_Right.m_VariantData))
	{
	}
	HPMUntranslatedStringParamListEntry &operator =(HPMUntranslatedStringParamListEntry const &_Right)
	{
		m_VariantData = _Right.m_VariantData;
		return *this;
	}
	HPMUntranslatedStringParamListEntry &operator =(HPMUntranslatedStringParamListEntry &&_Right)
	{
		m_VariantData = std::move(_Right.m_VariantData);
		return *this;
	}
#endif
	bool operator == (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		if (m_VariantData != _Right.m_VariantData)
			return false;
		return true;
	}
	bool operator != (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		if (m_VariantData < _Right.m_VariantData)
			return true;
		if (m_VariantData > _Right.m_VariantData)
			return false;
		return false;
	}
	bool operator > (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMUntranslatedStringParamListEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMUntranslatedStringParamList
{
	public:
	std::vector<HPMUntranslatedStringParamListEntry> m_Params;
	HPMUntranslatedStringParamList()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMUntranslatedStringParamList(HPMUntranslatedStringParamList const &_Right)
		: m_Params(_Right.m_Params)
	{
	}
	HPMUntranslatedStringParamList(HPMUntranslatedStringParamList &&_Right)
		: m_Params(std::move(_Right.m_Params))
	{
	}
	HPMUntranslatedStringParamList &operator =(HPMUntranslatedStringParamList const &_Right)
	{
		m_Params = _Right.m_Params;
		return *this;
	}
	HPMUntranslatedStringParamList &operator =(HPMUntranslatedStringParamList &&_Right)
	{
		m_Params = std::move(_Right.m_Params);
		return *this;
	}
#endif
	bool operator == (const HPMUntranslatedStringParamList &_Right) const
	{
		if (m_Params.size() != _Right.m_Params.size())
			return false;
		for (size_t i = 0; i < m_Params.size(); ++i)
			if (m_Params[i] != _Right.m_Params[i])
				return false;
		return true;
	}
	bool operator != (const HPMUntranslatedStringParamList &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMUntranslatedStringParamList &_Right) const
	{
		if (m_Params.size() < _Right.m_Params.size())
			return true;
		if (m_Params.size() > _Right.m_Params.size())
			return false;
		for (size_t i = 0; i < m_Params.size(); ++i)
		{
			if (m_Params[i] < _Right.m_Params[i])
				return true;
			if (m_Params[i] > _Right.m_Params[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMUntranslatedStringParamList &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMUntranslatedStringParamList &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMUntranslatedStringParamList &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalStatisticsSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalStatisticsSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalStatisticsSettingsChange(HPMChangeCallbackData_GlobalStatisticsSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalStatisticsSettingsChange(HPMChangeCallbackData_GlobalStatisticsSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalStatisticsSettingsChange &operator =(HPMChangeCallbackData_GlobalStatisticsSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalStatisticsSettingsChange &operator =(HPMChangeCallbackData_GlobalStatisticsSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalStatisticsSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalServerNameChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalServerNameChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalServerNameChange(HPMChangeCallbackData_GlobalServerNameChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalServerNameChange(HPMChangeCallbackData_GlobalServerNameChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalServerNameChange &operator =(HPMChangeCallbackData_GlobalServerNameChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalServerNameChange &operator =(HPMChangeCallbackData_GlobalServerNameChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalServerNameChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange(HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange(HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &operator =(HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &operator =(HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalDocumentAttachmentLimitChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_AuthenticationProtocolBegin
{
	public:
	HPMString m_Identifier;
	HPMString m_UserName;
	HPMString m_Password;
	HPMChangeCallbackData_AuthenticationProtocolBegin()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_AuthenticationProtocolBegin(HPMChangeCallbackData_AuthenticationProtocolBegin const &_Right)
		: m_Identifier(_Right.m_Identifier)
		, m_UserName(_Right.m_UserName)
		, m_Password(_Right.m_Password)
	{
	}
	HPMChangeCallbackData_AuthenticationProtocolBegin(HPMChangeCallbackData_AuthenticationProtocolBegin &&_Right)
		: m_Identifier(std::move(_Right.m_Identifier))
		, m_UserName(std::move(_Right.m_UserName))
		, m_Password(std::move(_Right.m_Password))
	{
	}
	HPMChangeCallbackData_AuthenticationProtocolBegin &operator =(HPMChangeCallbackData_AuthenticationProtocolBegin const &_Right)
	{
		m_Identifier = _Right.m_Identifier;
		m_UserName = _Right.m_UserName;
		m_Password = _Right.m_Password;
		return *this;
	}
	HPMChangeCallbackData_AuthenticationProtocolBegin &operator =(HPMChangeCallbackData_AuthenticationProtocolBegin &&_Right)
	{
		m_Identifier = std::move(_Right.m_Identifier);
		m_UserName = std::move(_Right.m_UserName);
		m_Password = std::move(_Right.m_Password);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		if (m_Identifier != _Right.m_Identifier)
			return false;
		if (m_UserName != _Right.m_UserName)
			return false;
		if (m_Password != _Right.m_Password)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		if (m_Identifier < _Right.m_Identifier)
			return true;
		if (m_Identifier > _Right.m_Identifier)
			return false;
		if (m_UserName < _Right.m_UserName)
			return true;
		if (m_UserName > _Right.m_UserName)
			return false;
		if (m_Password < _Right.m_Password)
			return true;
		if (m_Password > _Right.m_Password)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_AuthenticationProtocolBegin &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CommunicationChannelPacketReceived
{
	public:
	HPMString m_ChannelName;
	HPMUInt64 m_ToSessionID;
	HPMUInt64 m_FromSessionID;
	HPMCommunicationChannelPacket m_Packet;
	HPMChangeCallbackData_CommunicationChannelPacketReceived()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CommunicationChannelPacketReceived(HPMChangeCallbackData_CommunicationChannelPacketReceived const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
		, m_ToSessionID(_Right.m_ToSessionID)
		, m_FromSessionID(_Right.m_FromSessionID)
		, m_Packet(_Right.m_Packet)
	{
	}
	HPMChangeCallbackData_CommunicationChannelPacketReceived(HPMChangeCallbackData_CommunicationChannelPacketReceived &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
		, m_ToSessionID(std::move(_Right.m_ToSessionID))
		, m_FromSessionID(std::move(_Right.m_FromSessionID))
		, m_Packet(std::move(_Right.m_Packet))
	{
	}
	HPMChangeCallbackData_CommunicationChannelPacketReceived &operator =(HPMChangeCallbackData_CommunicationChannelPacketReceived const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		m_ToSessionID = _Right.m_ToSessionID;
		m_FromSessionID = _Right.m_FromSessionID;
		m_Packet = _Right.m_Packet;
		return *this;
	}
	HPMChangeCallbackData_CommunicationChannelPacketReceived &operator =(HPMChangeCallbackData_CommunicationChannelPacketReceived &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		m_ToSessionID = std::move(_Right.m_ToSessionID);
		m_FromSessionID = std::move(_Right.m_FromSessionID);
		m_Packet = std::move(_Right.m_Packet);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		if (m_ToSessionID != _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID != _Right.m_FromSessionID)
			return false;
		if (m_Packet != _Right.m_Packet)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		if (m_ToSessionID < _Right.m_ToSessionID)
			return true;
		if (m_ToSessionID > _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID < _Right.m_FromSessionID)
			return true;
		if (m_FromSessionID > _Right.m_FromSessionID)
			return false;
		if (m_Packet < _Right.m_Packet)
			return true;
		if (m_Packet > _Right.m_Packet)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CommunicationChannelPacketReceived &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CommunicationChannelPacketDropped
{
	public:
	HPMString m_ChannelName;
	HPMUInt64 m_ToSessionID;
	HPMUInt64 m_FromSessionID;
	HPMCommunicationChannelPacket m_Packet;
	EHPMPacketDropReason m_Reason;
	HPMChangeCallbackData_CommunicationChannelPacketDropped()
		: m_Reason(EHPMPacketDropReason_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CommunicationChannelPacketDropped(HPMChangeCallbackData_CommunicationChannelPacketDropped const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
		, m_ToSessionID(_Right.m_ToSessionID)
		, m_FromSessionID(_Right.m_FromSessionID)
		, m_Packet(_Right.m_Packet)
		, m_Reason(_Right.m_Reason)
	{
	}
	HPMChangeCallbackData_CommunicationChannelPacketDropped(HPMChangeCallbackData_CommunicationChannelPacketDropped &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
		, m_ToSessionID(std::move(_Right.m_ToSessionID))
		, m_FromSessionID(std::move(_Right.m_FromSessionID))
		, m_Packet(std::move(_Right.m_Packet))
		, m_Reason(std::move(_Right.m_Reason))
	{
	}
	HPMChangeCallbackData_CommunicationChannelPacketDropped &operator =(HPMChangeCallbackData_CommunicationChannelPacketDropped const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		m_ToSessionID = _Right.m_ToSessionID;
		m_FromSessionID = _Right.m_FromSessionID;
		m_Packet = _Right.m_Packet;
		m_Reason = _Right.m_Reason;
		return *this;
	}
	HPMChangeCallbackData_CommunicationChannelPacketDropped &operator =(HPMChangeCallbackData_CommunicationChannelPacketDropped &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		m_ToSessionID = std::move(_Right.m_ToSessionID);
		m_FromSessionID = std::move(_Right.m_FromSessionID);
		m_Packet = std::move(_Right.m_Packet);
		m_Reason = std::move(_Right.m_Reason);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		if (m_ToSessionID != _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID != _Right.m_FromSessionID)
			return false;
		if (m_Packet != _Right.m_Packet)
			return false;
		if (m_Reason != _Right.m_Reason)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		if (m_ToSessionID < _Right.m_ToSessionID)
			return true;
		if (m_ToSessionID > _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID < _Right.m_FromSessionID)
			return true;
		if (m_FromSessionID > _Right.m_FromSessionID)
			return false;
		if (m_Packet < _Right.m_Packet)
			return true;
		if (m_Packet > _Right.m_Packet)
			return false;
		if (m_Reason < _Right.m_Reason)
			return true;
		if (m_Reason > _Right.m_Reason)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CommunicationChannelPacketDropped &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CommunicationChannelRegisterFailed
{
	public:
	HPMString m_ChannelName;
	EHPMChannelRegisterFailReason m_Reason;
	HPMChangeCallbackData_CommunicationChannelRegisterFailed()
		: m_Reason(EHPMChannelRegisterFailReason_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CommunicationChannelRegisterFailed(HPMChangeCallbackData_CommunicationChannelRegisterFailed const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
		, m_Reason(_Right.m_Reason)
	{
	}
	HPMChangeCallbackData_CommunicationChannelRegisterFailed(HPMChangeCallbackData_CommunicationChannelRegisterFailed &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
		, m_Reason(std::move(_Right.m_Reason))
	{
	}
	HPMChangeCallbackData_CommunicationChannelRegisterFailed &operator =(HPMChangeCallbackData_CommunicationChannelRegisterFailed const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		m_Reason = _Right.m_Reason;
		return *this;
	}
	HPMChangeCallbackData_CommunicationChannelRegisterFailed &operator =(HPMChangeCallbackData_CommunicationChannelRegisterFailed &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		m_Reason = std::move(_Right.m_Reason);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		if (m_Reason != _Right.m_Reason)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		if (m_Reason < _Right.m_Reason)
			return true;
		if (m_Reason > _Right.m_Reason)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CommunicationChannelRegisterFailed &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CommunicationChannelsChanged
{
	public:
	HPMString m_ChannelName;
	HPMChangeCallbackData_CommunicationChannelsChanged()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CommunicationChannelsChanged(HPMChangeCallbackData_CommunicationChannelsChanged const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
	{
	}
	HPMChangeCallbackData_CommunicationChannelsChanged(HPMChangeCallbackData_CommunicationChannelsChanged &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
	{
	}
	HPMChangeCallbackData_CommunicationChannelsChanged &operator =(HPMChangeCallbackData_CommunicationChannelsChanged const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		return *this;
	}
	HPMChangeCallbackData_CommunicationChannelsChanged &operator =(HPMChangeCallbackData_CommunicationChannelsChanged &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CommunicationChannelsChanged &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_AuthenticationResolveCredentials
{
	public:
	HPMString m_ChannelName;
	HPMUInt64 m_ToSessionID;
	HPMUInt64 m_FromSessionID;
	HPMString m_UserName;
	HPMString m_Password;
	HPMChangeCallbackData_AuthenticationResolveCredentials()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_AuthenticationResolveCredentials(HPMChangeCallbackData_AuthenticationResolveCredentials const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
		, m_ToSessionID(_Right.m_ToSessionID)
		, m_FromSessionID(_Right.m_FromSessionID)
		, m_UserName(_Right.m_UserName)
		, m_Password(_Right.m_Password)
	{
	}
	HPMChangeCallbackData_AuthenticationResolveCredentials(HPMChangeCallbackData_AuthenticationResolveCredentials &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
		, m_ToSessionID(std::move(_Right.m_ToSessionID))
		, m_FromSessionID(std::move(_Right.m_FromSessionID))
		, m_UserName(std::move(_Right.m_UserName))
		, m_Password(std::move(_Right.m_Password))
	{
	}
	HPMChangeCallbackData_AuthenticationResolveCredentials &operator =(HPMChangeCallbackData_AuthenticationResolveCredentials const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		m_ToSessionID = _Right.m_ToSessionID;
		m_FromSessionID = _Right.m_FromSessionID;
		m_UserName = _Right.m_UserName;
		m_Password = _Right.m_Password;
		return *this;
	}
	HPMChangeCallbackData_AuthenticationResolveCredentials &operator =(HPMChangeCallbackData_AuthenticationResolveCredentials &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		m_ToSessionID = std::move(_Right.m_ToSessionID);
		m_FromSessionID = std::move(_Right.m_FromSessionID);
		m_UserName = std::move(_Right.m_UserName);
		m_Password = std::move(_Right.m_Password);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		if (m_ToSessionID != _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID != _Right.m_FromSessionID)
			return false;
		if (m_UserName != _Right.m_UserName)
			return false;
		if (m_Password != _Right.m_Password)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		if (m_ToSessionID < _Right.m_ToSessionID)
			return true;
		if (m_ToSessionID > _Right.m_ToSessionID)
			return false;
		if (m_FromSessionID < _Right.m_FromSessionID)
			return true;
		if (m_FromSessionID > _Right.m_FromSessionID)
			return false;
		if (m_UserName < _Right.m_UserName)
			return true;
		if (m_UserName > _Right.m_UserName)
			return false;
		if (m_Password < _Right.m_Password)
			return true;
		if (m_Password > _Right.m_Password)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_AuthenticationResolveCredentials &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_AuthenticationResolveCredentialsResponse
{
	public:
	HPMString m_UserName;
	HPMUniqueID m_ResourceID;
	HPMUInt64 m_AuthSessionID;
	HPMChangeCallbackData_AuthenticationResolveCredentialsResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_AuthenticationResolveCredentialsResponse(HPMChangeCallbackData_AuthenticationResolveCredentialsResponse const &_Right)
		: m_UserName(_Right.m_UserName)
		, m_ResourceID(_Right.m_ResourceID)
		, m_AuthSessionID(_Right.m_AuthSessionID)
	{
	}
	HPMChangeCallbackData_AuthenticationResolveCredentialsResponse(HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &&_Right)
		: m_UserName(std::move(_Right.m_UserName))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_AuthSessionID(std::move(_Right.m_AuthSessionID))
	{
	}
	HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &operator =(HPMChangeCallbackData_AuthenticationResolveCredentialsResponse const &_Right)
	{
		m_UserName = _Right.m_UserName;
		m_ResourceID = _Right.m_ResourceID;
		m_AuthSessionID = _Right.m_AuthSessionID;
		return *this;
	}
	HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &operator =(HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &&_Right)
	{
		m_UserName = std::move(_Right.m_UserName);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_AuthSessionID = std::move(_Right.m_AuthSessionID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		if (m_UserName != _Right.m_UserName)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_AuthSessionID != _Right.m_AuthSessionID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		if (m_UserName < _Right.m_UserName)
			return true;
		if (m_UserName > _Right.m_UserName)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_AuthSessionID < _Right.m_AuthSessionID)
			return true;
		if (m_AuthSessionID > _Right.m_AuthSessionID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_AuthenticationResolveCredentialsResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceCreate
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUniqueID m_TemporaryResourceID;
	HPMChangeCallbackData_ResourceCreate()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceCreate(HPMChangeCallbackData_ResourceCreate const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_TemporaryResourceID(_Right.m_TemporaryResourceID)
	{
	}
	HPMChangeCallbackData_ResourceCreate(HPMChangeCallbackData_ResourceCreate &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_TemporaryResourceID(std::move(_Right.m_TemporaryResourceID))
	{
	}
	HPMChangeCallbackData_ResourceCreate &operator =(HPMChangeCallbackData_ResourceCreate const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_TemporaryResourceID = _Right.m_TemporaryResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourceCreate &operator =(HPMChangeCallbackData_ResourceCreate &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_TemporaryResourceID = std::move(_Right.m_TemporaryResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_TemporaryResourceID != _Right.m_TemporaryResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_TemporaryResourceID < _Right.m_TemporaryResourceID)
			return true;
		if (m_TemporaryResourceID > _Right.m_TemporaryResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceCreate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ResourceDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceDelete(HPMChangeCallbackData_ResourceDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ResourceDelete(HPMChangeCallbackData_ResourceDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ResourceDelete &operator =(HPMChangeCallbackData_ResourceDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourceDelete &operator =(HPMChangeCallbackData_ResourceDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourcePropertiesChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ResourcePropertiesChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourcePropertiesChange(HPMChangeCallbackData_ResourcePropertiesChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ResourcePropertiesChange(HPMChangeCallbackData_ResourcePropertiesChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ResourcePropertiesChange &operator =(HPMChangeCallbackData_ResourcePropertiesChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourcePropertiesChange &operator =(HPMChangeCallbackData_ResourcePropertiesChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourcePropertiesChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceGlobalSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ResourceGlobalSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceGlobalSettingsChange(HPMChangeCallbackData_ResourceGlobalSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ResourceGlobalSettingsChange(HPMChangeCallbackData_ResourceGlobalSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ResourceGlobalSettingsChange &operator =(HPMChangeCallbackData_ResourceGlobalSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourceGlobalSettingsChange &operator =(HPMChangeCallbackData_ResourceGlobalSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceGlobalSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceLicenseViolation
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	EHPMLicenseViolationReason m_ViolationReason;
	HPMChangeCallbackData_ResourceLicenseViolation()
		: m_ViolationReason(EHPMLicenseViolationReason_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceLicenseViolation(HPMChangeCallbackData_ResourceLicenseViolation const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ViolationReason(_Right.m_ViolationReason)
	{
	}
	HPMChangeCallbackData_ResourceLicenseViolation(HPMChangeCallbackData_ResourceLicenseViolation &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ViolationReason(std::move(_Right.m_ViolationReason))
	{
	}
	HPMChangeCallbackData_ResourceLicenseViolation &operator =(HPMChangeCallbackData_ResourceLicenseViolation const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ViolationReason = _Right.m_ViolationReason;
		return *this;
	}
	HPMChangeCallbackData_ResourceLicenseViolation &operator =(HPMChangeCallbackData_ResourceLicenseViolation &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ViolationReason = std::move(_Right.m_ViolationReason);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ViolationReason != _Right.m_ViolationReason)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ViolationReason < _Right.m_ViolationReason)
			return true;
		if (m_ViolationReason > _Right.m_ViolationReason)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceLicenseViolation &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceLockFlagsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ResourceLockFlagsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceLockFlagsChange(HPMChangeCallbackData_ResourceLockFlagsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ResourceLockFlagsChange(HPMChangeCallbackData_ResourceLockFlagsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ResourceLockFlagsChange &operator =(HPMChangeCallbackData_ResourceLockFlagsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourceLockFlagsChange &operator =(HPMChangeCallbackData_ResourceLockFlagsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceLockFlagsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourcePreferredLanguageChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUInt16 m_LanguageID;
	HPMString m_CustomLanguageID;
	HPMChangeCallbackData_ResourcePreferredLanguageChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourcePreferredLanguageChange(HPMChangeCallbackData_ResourcePreferredLanguageChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_LanguageID(_Right.m_LanguageID)
		, m_CustomLanguageID(_Right.m_CustomLanguageID)
	{
	}
	HPMChangeCallbackData_ResourcePreferredLanguageChange(HPMChangeCallbackData_ResourcePreferredLanguageChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_LanguageID(std::move(_Right.m_LanguageID))
		, m_CustomLanguageID(std::move(_Right.m_CustomLanguageID))
	{
	}
	HPMChangeCallbackData_ResourcePreferredLanguageChange &operator =(HPMChangeCallbackData_ResourcePreferredLanguageChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_LanguageID = _Right.m_LanguageID;
		m_CustomLanguageID = _Right.m_CustomLanguageID;
		return *this;
	}
	HPMChangeCallbackData_ResourcePreferredLanguageChange &operator =(HPMChangeCallbackData_ResourcePreferredLanguageChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_LanguageID = std::move(_Right.m_LanguageID);
		m_CustomLanguageID = std::move(_Right.m_CustomLanguageID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_LanguageID != _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID != _Right.m_CustomLanguageID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_LanguageID < _Right.m_LanguageID)
			return true;
		if (m_LanguageID > _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID < _Right.m_CustomLanguageID)
			return true;
		if (m_CustomLanguageID > _Right.m_CustomLanguageID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourcePreferredLanguageChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceLastUsedLanguageChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUInt16 m_LanguageID;
	HPMString m_CustomLanguageID;
	HPMChangeCallbackData_ResourceLastUsedLanguageChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceLastUsedLanguageChange(HPMChangeCallbackData_ResourceLastUsedLanguageChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_LanguageID(_Right.m_LanguageID)
		, m_CustomLanguageID(_Right.m_CustomLanguageID)
	{
	}
	HPMChangeCallbackData_ResourceLastUsedLanguageChange(HPMChangeCallbackData_ResourceLastUsedLanguageChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_LanguageID(std::move(_Right.m_LanguageID))
		, m_CustomLanguageID(std::move(_Right.m_CustomLanguageID))
	{
	}
	HPMChangeCallbackData_ResourceLastUsedLanguageChange &operator =(HPMChangeCallbackData_ResourceLastUsedLanguageChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_LanguageID = _Right.m_LanguageID;
		m_CustomLanguageID = _Right.m_CustomLanguageID;
		return *this;
	}
	HPMChangeCallbackData_ResourceLastUsedLanguageChange &operator =(HPMChangeCallbackData_ResourceLastUsedLanguageChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_LanguageID = std::move(_Right.m_LanguageID);
		m_CustomLanguageID = std::move(_Right.m_CustomLanguageID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_LanguageID != _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID != _Right.m_CustomLanguageID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_LanguageID < _Right.m_LanguageID)
			return true;
		if (m_LanguageID > _Right.m_LanguageID)
			return false;
		if (m_CustomLanguageID < _Right.m_CustomLanguageID)
			return true;
		if (m_CustomLanguageID > _Right.m_CustomLanguageID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceLastUsedLanguageChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceGroupsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_ResourceGroupsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceGroupsChange(HPMChangeCallbackData_ResourceGroupsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_ResourceGroupsChange(HPMChangeCallbackData_ResourceGroupsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_ResourceGroupsChange &operator =(HPMChangeCallbackData_ResourceGroupsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_ResourceGroupsChange &operator =(HPMChangeCallbackData_ResourceGroupsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceGroupsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectViewPresetsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ProjectViewPresetsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectViewPresetsChange(HPMChangeCallbackData_ProjectViewPresetsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ProjectViewPresetsChange(HPMChangeCallbackData_ProjectViewPresetsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ProjectViewPresetsChange &operator =(HPMChangeCallbackData_ProjectViewPresetsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ProjectViewPresetsChange &operator =(HPMChangeCallbackData_ProjectViewPresetsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectViewPresetsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectViewPresetsApplied
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectViewPresetsApplied()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectViewPresetsApplied(HPMChangeCallbackData_ProjectViewPresetsApplied const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectViewPresetsApplied(HPMChangeCallbackData_ProjectViewPresetsApplied &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectViewPresetsApplied &operator =(HPMChangeCallbackData_ProjectViewPresetsApplied const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectViewPresetsApplied &operator =(HPMChangeCallbackData_ProjectViewPresetsApplied &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectViewPresetsApplied &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceTimesheetWeekDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUInt32 m_Year;
	HPMUInt32 m_Week;
	HPMChangeCallbackData_ResourceTimesheetWeekDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceTimesheetWeekDataChange(HPMChangeCallbackData_ResourceTimesheetWeekDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Year(_Right.m_Year)
		, m_Week(_Right.m_Week)
	{
	}
	HPMChangeCallbackData_ResourceTimesheetWeekDataChange(HPMChangeCallbackData_ResourceTimesheetWeekDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Year(std::move(_Right.m_Year))
		, m_Week(std::move(_Right.m_Week))
	{
	}
	HPMChangeCallbackData_ResourceTimesheetWeekDataChange &operator =(HPMChangeCallbackData_ResourceTimesheetWeekDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_Year = _Right.m_Year;
		m_Week = _Right.m_Week;
		return *this;
	}
	HPMChangeCallbackData_ResourceTimesheetWeekDataChange &operator =(HPMChangeCallbackData_ResourceTimesheetWeekDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Year = std::move(_Right.m_Year);
		m_Week = std::move(_Right.m_Week);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Year != _Right.m_Year)
			return false;
		if (m_Week != _Right.m_Week)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Year < _Right.m_Year)
			return true;
		if (m_Year > _Right.m_Year)
			return false;
		if (m_Week < _Right.m_Week)
			return true;
		if (m_Week > _Right.m_Week)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceTimesheetWeekDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalTimesheetConfigChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalTimesheetConfigChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalTimesheetConfigChange(HPMChangeCallbackData_GlobalTimesheetConfigChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalTimesheetConfigChange(HPMChangeCallbackData_GlobalTimesheetConfigChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalTimesheetConfigChange &operator =(HPMChangeCallbackData_GlobalTimesheetConfigChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalTimesheetConfigChange &operator =(HPMChangeCallbackData_GlobalTimesheetConfigChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalTimesheetConfigChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUInt64 m_Date;
	HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete(HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Date(_Right.m_Date)
	{
	}
	HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete(HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Date(std::move(_Right.m_Date))
	{
	}
	HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &operator =(HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_Date = _Right.m_Date;
		return *this;
	}
	HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &operator =(HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Date = std::move(_Right.m_Date);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Date != _Right.m_Date)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceTimesheetPeriodDataDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectTimesheetLockChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectTimesheetLockChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectTimesheetLockChange(HPMChangeCallbackData_ProjectTimesheetLockChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectTimesheetLockChange(HPMChangeCallbackData_ProjectTimesheetLockChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectTimesheetLockChange &operator =(HPMChangeCallbackData_ProjectTimesheetLockChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectTimesheetLockChange &operator =(HPMChangeCallbackData_ProjectTimesheetLockChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectTimesheetLockChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceGetTimesheetDayResponse
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMTimesheetDay m_Day;
	HPMInt32 m_CurrentHighestRowID;
	HPMChangeCallbackData_ResourceGetTimesheetDayResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceGetTimesheetDayResponse(HPMChangeCallbackData_ResourceGetTimesheetDayResponse const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_Day(_Right.m_Day)
		, m_CurrentHighestRowID(_Right.m_CurrentHighestRowID)
	{
	}
	HPMChangeCallbackData_ResourceGetTimesheetDayResponse(HPMChangeCallbackData_ResourceGetTimesheetDayResponse &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_Day(std::move(_Right.m_Day))
		, m_CurrentHighestRowID(std::move(_Right.m_CurrentHighestRowID))
	{
	}
	HPMChangeCallbackData_ResourceGetTimesheetDayResponse &operator =(HPMChangeCallbackData_ResourceGetTimesheetDayResponse const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_Day = _Right.m_Day;
		m_CurrentHighestRowID = _Right.m_CurrentHighestRowID;
		return *this;
	}
	HPMChangeCallbackData_ResourceGetTimesheetDayResponse &operator =(HPMChangeCallbackData_ResourceGetTimesheetDayResponse &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_Day = std::move(_Right.m_Day);
		m_CurrentHighestRowID = std::move(_Right.m_CurrentHighestRowID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_Day != _Right.m_Day)
			return false;
		if (m_CurrentHighestRowID != _Right.m_CurrentHighestRowID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_Day < _Right.m_Day)
			return true;
		if (m_Day > _Right.m_Day)
			return false;
		if (m_CurrentHighestRowID < _Right.m_CurrentHighestRowID)
			return true;
		if (m_CurrentHighestRowID > _Right.m_CurrentHighestRowID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceGetTimesheetDayResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TimesheetGetDateRangeResponse
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	std::vector<HPMTimesheetDay> m_TimesheetDays;
	HPMChangeCallbackData_TimesheetGetDateRangeResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TimesheetGetDateRangeResponse(HPMChangeCallbackData_TimesheetGetDateRangeResponse const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TimesheetDays(_Right.m_TimesheetDays)
	{
	}
	HPMChangeCallbackData_TimesheetGetDateRangeResponse(HPMChangeCallbackData_TimesheetGetDateRangeResponse &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TimesheetDays(std::move(_Right.m_TimesheetDays))
	{
	}
	HPMChangeCallbackData_TimesheetGetDateRangeResponse &operator =(HPMChangeCallbackData_TimesheetGetDateRangeResponse const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TimesheetDays = _Right.m_TimesheetDays;
		return *this;
	}
	HPMChangeCallbackData_TimesheetGetDateRangeResponse &operator =(HPMChangeCallbackData_TimesheetGetDateRangeResponse &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TimesheetDays = std::move(_Right.m_TimesheetDays);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TimesheetDays.size() != _Right.m_TimesheetDays.size())
			return false;
		for (size_t i = 0; i < m_TimesheetDays.size(); ++i)
			if (m_TimesheetDays[i] != _Right.m_TimesheetDays[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TimesheetDays.size() < _Right.m_TimesheetDays.size())
			return true;
		if (m_TimesheetDays.size() > _Right.m_TimesheetDays.size())
			return false;
		for (size_t i = 0; i < m_TimesheetDays.size(); ++i)
		{
			if (m_TimesheetDays[i] < _Right.m_TimesheetDays[i])
				return true;
			if (m_TimesheetDays[i] > _Right.m_TimesheetDays[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TimesheetGetDateRangeResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TimesheetRowChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_DayID;
	HPMUInt32 m_RowID;
	EHPMTimesheetField m_FieldID;
	HPMChangeCallbackData_TimesheetRowChange()
		: m_FieldID(EHPMTimesheetField_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TimesheetRowChange(HPMChangeCallbackData_TimesheetRowChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_DayID(_Right.m_DayID)
		, m_RowID(_Right.m_RowID)
		, m_FieldID(_Right.m_FieldID)
	{
	}
	HPMChangeCallbackData_TimesheetRowChange(HPMChangeCallbackData_TimesheetRowChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_DayID(std::move(_Right.m_DayID))
		, m_RowID(std::move(_Right.m_RowID))
		, m_FieldID(std::move(_Right.m_FieldID))
	{
	}
	HPMChangeCallbackData_TimesheetRowChange &operator =(HPMChangeCallbackData_TimesheetRowChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_DayID = _Right.m_DayID;
		m_RowID = _Right.m_RowID;
		m_FieldID = _Right.m_FieldID;
		return *this;
	}
	HPMChangeCallbackData_TimesheetRowChange &operator =(HPMChangeCallbackData_TimesheetRowChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_DayID = std::move(_Right.m_DayID);
		m_RowID = std::move(_Right.m_RowID);
		m_FieldID = std::move(_Right.m_FieldID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_DayID != _Right.m_DayID)
			return false;
		if (m_RowID != _Right.m_RowID)
			return false;
		if (m_FieldID != _Right.m_FieldID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_DayID < _Right.m_DayID)
			return true;
		if (m_DayID > _Right.m_DayID)
			return false;
		if (m_RowID < _Right.m_RowID)
			return true;
		if (m_RowID > _Right.m_RowID)
			return false;
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TimesheetRowChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectDisplayUserMessage
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	EHPMProjectUserMessageType m_MessageType;
	HPMUntranslatedString m_Message;
	HPMChangeCallbackData_ProjectDisplayUserMessage()
		: m_MessageType(EHPMProjectUserMessageType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectDisplayUserMessage(HPMChangeCallbackData_ProjectDisplayUserMessage const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_MessageType(_Right.m_MessageType)
		, m_Message(_Right.m_Message)
	{
	}
	HPMChangeCallbackData_ProjectDisplayUserMessage(HPMChangeCallbackData_ProjectDisplayUserMessage &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_MessageType(std::move(_Right.m_MessageType))
		, m_Message(std::move(_Right.m_Message))
	{
	}
	HPMChangeCallbackData_ProjectDisplayUserMessage &operator =(HPMChangeCallbackData_ProjectDisplayUserMessage const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_MessageType = _Right.m_MessageType;
		m_Message = _Right.m_Message;
		return *this;
	}
	HPMChangeCallbackData_ProjectDisplayUserMessage &operator =(HPMChangeCallbackData_ProjectDisplayUserMessage &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_MessageType = std::move(_Right.m_MessageType);
		m_Message = std::move(_Right.m_Message);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_MessageType != _Right.m_MessageType)
			return false;
		if (m_Message != _Right.m_Message)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_MessageType < _Right.m_MessageType)
			return true;
		if (m_MessageType > _Right.m_MessageType)
			return false;
		if (m_Message < _Right.m_Message)
			return true;
		if (m_Message > _Right.m_Message)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectDisplayUserMessage &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_IDNoLongerExists
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMChangeCallbackData_IDNoLongerExists()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_IDNoLongerExists(HPMChangeCallbackData_IDNoLongerExists const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
	{
	}
	HPMChangeCallbackData_IDNoLongerExists(HPMChangeCallbackData_IDNoLongerExists &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
	{
	}
	HPMChangeCallbackData_IDNoLongerExists &operator =(HPMChangeCallbackData_IDNoLongerExists const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		return *this;
	}
	HPMChangeCallbackData_IDNoLongerExists &operator =(HPMChangeCallbackData_IDNoLongerExists &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_IDNoLongerExists &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ChatMessage
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMChatRoom m_ChatRoom;
	HPMString m_Message;
	HPMChangeCallbackData_ChatMessage()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ChatMessage(HPMChangeCallbackData_ChatMessage const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_ChatRoom(_Right.m_ChatRoom)
		, m_Message(_Right.m_Message)
	{
	}
	HPMChangeCallbackData_ChatMessage(HPMChangeCallbackData_ChatMessage &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_ChatRoom(std::move(_Right.m_ChatRoom))
		, m_Message(std::move(_Right.m_Message))
	{
	}
	HPMChangeCallbackData_ChatMessage &operator =(HPMChangeCallbackData_ChatMessage const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_ChatRoom = _Right.m_ChatRoom;
		m_Message = _Right.m_Message;
		return *this;
	}
	HPMChangeCallbackData_ChatMessage &operator =(HPMChangeCallbackData_ChatMessage &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_ChatRoom = std::move(_Right.m_ChatRoom);
		m_Message = std::move(_Right.m_Message);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_ChatRoom != _Right.m_ChatRoom)
			return false;
		if (m_Message != _Right.m_Message)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_ChatRoom < _Right.m_ChatRoom)
			return true;
		if (m_ChatRoom > _Right.m_ChatRoom)
			return false;
		if (m_Message < _Right.m_Message)
			return true;
		if (m_Message > _Right.m_Message)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ChatMessage &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ChatMessageLastID
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMInt64 m_LastChatID;
	HPMChatRoom m_ChatRoom;
	HPMChangeCallbackData_ChatMessageLastID()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ChatMessageLastID(HPMChangeCallbackData_ChatMessageLastID const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_LastChatID(_Right.m_LastChatID)
		, m_ChatRoom(_Right.m_ChatRoom)
	{
	}
	HPMChangeCallbackData_ChatMessageLastID(HPMChangeCallbackData_ChatMessageLastID &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_LastChatID(std::move(_Right.m_LastChatID))
		, m_ChatRoom(std::move(_Right.m_ChatRoom))
	{
	}
	HPMChangeCallbackData_ChatMessageLastID &operator =(HPMChangeCallbackData_ChatMessageLastID const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_LastChatID = _Right.m_LastChatID;
		m_ChatRoom = _Right.m_ChatRoom;
		return *this;
	}
	HPMChangeCallbackData_ChatMessageLastID &operator =(HPMChangeCallbackData_ChatMessageLastID &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_LastChatID = std::move(_Right.m_LastChatID);
		m_ChatRoom = std::move(_Right.m_ChatRoom);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_LastChatID != _Right.m_LastChatID)
			return false;
		if (m_ChatRoom != _Right.m_ChatRoom)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_LastChatID < _Right.m_LastChatID)
			return true;
		if (m_LastChatID > _Right.m_LastChatID)
			return false;
		if (m_ChatRoom < _Right.m_ChatRoom)
			return true;
		if (m_ChatRoom > _Right.m_ChatRoom)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ChatMessageLastID &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ChatMessageLastReadID
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMInt64 m_LastReadChatID;
	HPMChatRoom m_ChatRoom;
	HPMChangeCallbackData_ChatMessageLastReadID()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ChatMessageLastReadID(HPMChangeCallbackData_ChatMessageLastReadID const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_LastReadChatID(_Right.m_LastReadChatID)
		, m_ChatRoom(_Right.m_ChatRoom)
	{
	}
	HPMChangeCallbackData_ChatMessageLastReadID(HPMChangeCallbackData_ChatMessageLastReadID &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_LastReadChatID(std::move(_Right.m_LastReadChatID))
		, m_ChatRoom(std::move(_Right.m_ChatRoom))
	{
	}
	HPMChangeCallbackData_ChatMessageLastReadID &operator =(HPMChangeCallbackData_ChatMessageLastReadID const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_LastReadChatID = _Right.m_LastReadChatID;
		m_ChatRoom = _Right.m_ChatRoom;
		return *this;
	}
	HPMChangeCallbackData_ChatMessageLastReadID &operator =(HPMChangeCallbackData_ChatMessageLastReadID &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_LastReadChatID = std::move(_Right.m_LastReadChatID);
		m_ChatRoom = std::move(_Right.m_ChatRoom);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_LastReadChatID != _Right.m_LastReadChatID)
			return false;
		if (m_ChatRoom != _Right.m_ChatRoom)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_LastReadChatID < _Right.m_LastReadChatID)
			return true;
		if (m_LastReadChatID > _Right.m_LastReadChatID)
			return false;
		if (m_ChatRoom < _Right.m_ChatRoom)
			return true;
		if (m_ChatRoom > _Right.m_ChatRoom)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ChatMessageLastReadID &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ChatOnlineStatusChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	EHPMChatOnlineStatus m_Status;
	HPMChangeCallbackData_ChatOnlineStatusChange()
		: m_Status(EHPMChatOnlineStatus_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ChatOnlineStatusChange(HPMChangeCallbackData_ChatOnlineStatusChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Status(_Right.m_Status)
	{
	}
	HPMChangeCallbackData_ChatOnlineStatusChange(HPMChangeCallbackData_ChatOnlineStatusChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Status(std::move(_Right.m_Status))
	{
	}
	HPMChangeCallbackData_ChatOnlineStatusChange &operator =(HPMChangeCallbackData_ChatOnlineStatusChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_Status = _Right.m_Status;
		return *this;
	}
	HPMChangeCallbackData_ChatOnlineStatusChange &operator =(HPMChangeCallbackData_ChatOnlineStatusChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Status = std::move(_Right.m_Status);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Status != _Right.m_Status)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Status < _Right.m_Status)
			return true;
		if (m_Status > _Right.m_Status)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ChatOnlineStatusChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceDoNotDisturbChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	bool m_bIsDoNotDisturb;
	HPMChangeCallbackData_ResourceDoNotDisturbChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceDoNotDisturbChange(HPMChangeCallbackData_ResourceDoNotDisturbChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_bIsDoNotDisturb(_Right.m_bIsDoNotDisturb)
	{
	}
	HPMChangeCallbackData_ResourceDoNotDisturbChange(HPMChangeCallbackData_ResourceDoNotDisturbChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_bIsDoNotDisturb(std::move(_Right.m_bIsDoNotDisturb))
	{
	}
	HPMChangeCallbackData_ResourceDoNotDisturbChange &operator =(HPMChangeCallbackData_ResourceDoNotDisturbChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_bIsDoNotDisturb = _Right.m_bIsDoNotDisturb;
		return *this;
	}
	HPMChangeCallbackData_ResourceDoNotDisturbChange &operator =(HPMChangeCallbackData_ResourceDoNotDisturbChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_bIsDoNotDisturb = std::move(_Right.m_bIsDoNotDisturb);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_bIsDoNotDisturb != _Right.m_bIsDoNotDisturb)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_bIsDoNotDisturb < _Right.m_bIsDoNotDisturb)
			return true;
		if (m_bIsDoNotDisturb > _Right.m_bIsDoNotDisturb)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceDoNotDisturbChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalEmailSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalEmailSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalEmailSettingsChange(HPMChangeCallbackData_GlobalEmailSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalEmailSettingsChange(HPMChangeCallbackData_GlobalEmailSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalEmailSettingsChange &operator =(HPMChangeCallbackData_GlobalEmailSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalEmailSettingsChange &operator =(HPMChangeCallbackData_GlobalEmailSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalEmailSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCreate
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_TemporaryProjectID;
	HPMChangeCallbackData_ProjectCreate()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCreate(HPMChangeCallbackData_ProjectCreate const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_TemporaryProjectID(_Right.m_TemporaryProjectID)
	{
	}
	HPMChangeCallbackData_ProjectCreate(HPMChangeCallbackData_ProjectCreate &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_TemporaryProjectID(std::move(_Right.m_TemporaryProjectID))
	{
	}
	HPMChangeCallbackData_ProjectCreate &operator =(HPMChangeCallbackData_ProjectCreate const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_TemporaryProjectID = _Right.m_TemporaryProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectCreate &operator =(HPMChangeCallbackData_ProjectCreate &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_TemporaryProjectID = std::move(_Right.m_TemporaryProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_TemporaryProjectID != _Right.m_TemporaryProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_TemporaryProjectID < _Right.m_TemporaryProjectID)
			return true;
		if (m_TemporaryProjectID > _Right.m_TemporaryProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCreate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectDelete(HPMChangeCallbackData_ProjectDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectDelete(HPMChangeCallbackData_ProjectDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectDelete &operator =(HPMChangeCallbackData_ProjectDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectDelete &operator =(HPMChangeCallbackData_ProjectDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectPropertiesChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectPropertiesChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectPropertiesChange(HPMChangeCallbackData_ProjectPropertiesChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectPropertiesChange(HPMChangeCallbackData_ProjectPropertiesChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectPropertiesChange &operator =(HPMChangeCallbackData_ProjectPropertiesChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectPropertiesChange &operator =(HPMChangeCallbackData_ProjectPropertiesChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectPropertiesChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectSettingsChange(HPMChangeCallbackData_ProjectSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectSettingsChange(HPMChangeCallbackData_ProjectSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectSettingsChange &operator =(HPMChangeCallbackData_ProjectSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectSettingsChange &operator =(HPMChangeCallbackData_ProjectSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectStatisticsSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectStatisticsSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectStatisticsSettingsChange(HPMChangeCallbackData_ProjectStatisticsSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectStatisticsSettingsChange(HPMChangeCallbackData_ProjectStatisticsSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectStatisticsSettingsChange &operator =(HPMChangeCallbackData_ProjectStatisticsSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectStatisticsSettingsChange &operator =(HPMChangeCallbackData_ProjectStatisticsSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectStatisticsSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWorkflowChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_WorkflowID;
	HPMChangeCallbackData_ProjectWorkflowChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWorkflowChange(HPMChangeCallbackData_ProjectWorkflowChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_WorkflowID(_Right.m_WorkflowID)
	{
	}
	HPMChangeCallbackData_ProjectWorkflowChange(HPMChangeCallbackData_ProjectWorkflowChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
	{
	}
	HPMChangeCallbackData_ProjectWorkflowChange &operator =(HPMChangeCallbackData_ProjectWorkflowChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_WorkflowID = _Right.m_WorkflowID;
		return *this;
	}
	HPMChangeCallbackData_ProjectWorkflowChange &operator =(HPMChangeCallbackData_ProjectWorkflowChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWorkflowChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWorkflowCreate
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_WorkflowID;
	HPMChangeCallbackData_ProjectWorkflowCreate()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWorkflowCreate(HPMChangeCallbackData_ProjectWorkflowCreate const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_WorkflowID(_Right.m_WorkflowID)
	{
	}
	HPMChangeCallbackData_ProjectWorkflowCreate(HPMChangeCallbackData_ProjectWorkflowCreate &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
	{
	}
	HPMChangeCallbackData_ProjectWorkflowCreate &operator =(HPMChangeCallbackData_ProjectWorkflowCreate const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_WorkflowID = _Right.m_WorkflowID;
		return *this;
	}
	HPMChangeCallbackData_ProjectWorkflowCreate &operator =(HPMChangeCallbackData_ProjectWorkflowCreate &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWorkflowCreate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_WorkflowUpdateData
{
	public:
	HPMUInt32 m_WorkflowOldID;
	HPMUInt32 m_WorkflowNewID;
	bool m_bReferencesChanged;
	HPMChangeCallbackData_WorkflowUpdateData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_WorkflowUpdateData(HPMChangeCallbackData_WorkflowUpdateData const &_Right)
		: m_WorkflowOldID(_Right.m_WorkflowOldID)
		, m_WorkflowNewID(_Right.m_WorkflowNewID)
		, m_bReferencesChanged(_Right.m_bReferencesChanged)
	{
	}
	HPMChangeCallbackData_WorkflowUpdateData(HPMChangeCallbackData_WorkflowUpdateData &&_Right)
		: m_WorkflowOldID(std::move(_Right.m_WorkflowOldID))
		, m_WorkflowNewID(std::move(_Right.m_WorkflowNewID))
		, m_bReferencesChanged(std::move(_Right.m_bReferencesChanged))
	{
	}
	HPMChangeCallbackData_WorkflowUpdateData &operator =(HPMChangeCallbackData_WorkflowUpdateData const &_Right)
	{
		m_WorkflowOldID = _Right.m_WorkflowOldID;
		m_WorkflowNewID = _Right.m_WorkflowNewID;
		m_bReferencesChanged = _Right.m_bReferencesChanged;
		return *this;
	}
	HPMChangeCallbackData_WorkflowUpdateData &operator =(HPMChangeCallbackData_WorkflowUpdateData &&_Right)
	{
		m_WorkflowOldID = std::move(_Right.m_WorkflowOldID);
		m_WorkflowNewID = std::move(_Right.m_WorkflowNewID);
		m_bReferencesChanged = std::move(_Right.m_bReferencesChanged);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		if (m_WorkflowOldID != _Right.m_WorkflowOldID)
			return false;
		if (m_WorkflowNewID != _Right.m_WorkflowNewID)
			return false;
		if (m_bReferencesChanged != _Right.m_bReferencesChanged)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		if (m_WorkflowOldID < _Right.m_WorkflowOldID)
			return true;
		if (m_WorkflowOldID > _Right.m_WorkflowOldID)
			return false;
		if (m_WorkflowNewID < _Right.m_WorkflowNewID)
			return true;
		if (m_WorkflowNewID > _Right.m_WorkflowNewID)
			return false;
		if (m_bReferencesChanged < _Right.m_bReferencesChanged)
			return true;
		if (m_bReferencesChanged > _Right.m_bReferencesChanged)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_WorkflowUpdateData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWorkflowDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	std::vector<HPMChangeCallbackData_WorkflowUpdateData> m_Workflows;
	HPMChangeCallbackData_ProjectWorkflowDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWorkflowDelete(HPMChangeCallbackData_ProjectWorkflowDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_Workflows(_Right.m_Workflows)
	{
	}
	HPMChangeCallbackData_ProjectWorkflowDelete(HPMChangeCallbackData_ProjectWorkflowDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_Workflows(std::move(_Right.m_Workflows))
	{
	}
	HPMChangeCallbackData_ProjectWorkflowDelete &operator =(HPMChangeCallbackData_ProjectWorkflowDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_Workflows = _Right.m_Workflows;
		return *this;
	}
	HPMChangeCallbackData_ProjectWorkflowDelete &operator =(HPMChangeCallbackData_ProjectWorkflowDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_Workflows = std::move(_Right.m_Workflows);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_Workflows.size() != _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
			if (m_Workflows[i] != _Right.m_Workflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_Workflows.size() < _Right.m_Workflows.size())
			return true;
		if (m_Workflows.size() > _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
		{
			if (m_Workflows[i] < _Right.m_Workflows[i])
				return true;
			if (m_Workflows[i] > _Right.m_Workflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWorkflowDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_WorkflowsDeletedData
{
	public:
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_WorkflowID;
	HPMChangeCallbackData_WorkflowsDeletedData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_WorkflowsDeletedData(HPMChangeCallbackData_WorkflowsDeletedData const &_Right)
		: m_ProjectID(_Right.m_ProjectID)
		, m_WorkflowID(_Right.m_WorkflowID)
	{
	}
	HPMChangeCallbackData_WorkflowsDeletedData(HPMChangeCallbackData_WorkflowsDeletedData &&_Right)
		: m_ProjectID(std::move(_Right.m_ProjectID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
	{
	}
	HPMChangeCallbackData_WorkflowsDeletedData &operator =(HPMChangeCallbackData_WorkflowsDeletedData const &_Right)
	{
		m_ProjectID = _Right.m_ProjectID;
		m_WorkflowID = _Right.m_WorkflowID;
		return *this;
	}
	HPMChangeCallbackData_WorkflowsDeletedData &operator =(HPMChangeCallbackData_WorkflowsDeletedData &&_Right)
	{
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_WorkflowsDeletedData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalWorkflowsDeleted
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	std::vector<HPMChangeCallbackData_WorkflowsDeletedData> m_DeletedWorkflows;
	HPMChangeCallbackData_GlobalWorkflowsDeleted()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalWorkflowsDeleted(HPMChangeCallbackData_GlobalWorkflowsDeleted const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_DeletedWorkflows(_Right.m_DeletedWorkflows)
	{
	}
	HPMChangeCallbackData_GlobalWorkflowsDeleted(HPMChangeCallbackData_GlobalWorkflowsDeleted &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_DeletedWorkflows(std::move(_Right.m_DeletedWorkflows))
	{
	}
	HPMChangeCallbackData_GlobalWorkflowsDeleted &operator =(HPMChangeCallbackData_GlobalWorkflowsDeleted const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_DeletedWorkflows = _Right.m_DeletedWorkflows;
		return *this;
	}
	HPMChangeCallbackData_GlobalWorkflowsDeleted &operator =(HPMChangeCallbackData_GlobalWorkflowsDeleted &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_DeletedWorkflows = std::move(_Right.m_DeletedWorkflows);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_DeletedWorkflows.size() != _Right.m_DeletedWorkflows.size())
			return false;
		for (size_t i = 0; i < m_DeletedWorkflows.size(); ++i)
			if (m_DeletedWorkflows[i] != _Right.m_DeletedWorkflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_DeletedWorkflows.size() < _Right.m_DeletedWorkflows.size())
			return true;
		if (m_DeletedWorkflows.size() > _Right.m_DeletedWorkflows.size())
			return false;
		for (size_t i = 0; i < m_DeletedWorkflows.size(); ++i)
		{
			if (m_DeletedWorkflows[i] < _Right.m_DeletedWorkflows[i])
				return true;
			if (m_DeletedWorkflows[i] > _Right.m_DeletedWorkflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalWorkflowsDeleted &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectReportsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectReportsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectReportsChange(HPMChangeCallbackData_ProjectReportsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectReportsChange(HPMChangeCallbackData_ProjectReportsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectReportsChange &operator =(HPMChangeCallbackData_ProjectReportsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectReportsChange &operator =(HPMChangeCallbackData_ProjectReportsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectReportsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange(HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange(HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &operator =(HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &operator =(HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectAgilePriorityCustomColumnChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalReportsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMChangeCallbackData_GlobalReportsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalReportsChange(HPMChangeCallbackData_GlobalReportsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
	{
	}
	HPMChangeCallbackData_GlobalReportsChange(HPMChangeCallbackData_GlobalReportsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
	{
	}
	HPMChangeCallbackData_GlobalReportsChange &operator =(HPMChangeCallbackData_GlobalReportsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		return *this;
	}
	HPMChangeCallbackData_GlobalReportsChange &operator =(HPMChangeCallbackData_GlobalReportsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalReportsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWorkflowStatusStatsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_WorkflowObjectID;
	HPMUInt32 m_WorkflowStatusID;
	HPMChangeCallbackData_ProjectWorkflowStatusStatsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWorkflowStatusStatsChange(HPMChangeCallbackData_ProjectWorkflowStatusStatsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
		, m_WorkflowStatusID(_Right.m_WorkflowStatusID)
	{
	}
	HPMChangeCallbackData_ProjectWorkflowStatusStatsChange(HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
		, m_WorkflowStatusID(std::move(_Right.m_WorkflowStatusID))
	{
	}
	HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &operator =(HPMChangeCallbackData_ProjectWorkflowStatusStatsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		m_WorkflowStatusID = _Right.m_WorkflowStatusID;
		return *this;
	}
	HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &operator =(HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		m_WorkflowStatusID = std::move(_Right.m_WorkflowStatusID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		if (m_WorkflowStatusID != _Right.m_WorkflowStatusID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		if (m_WorkflowStatusID < _Right.m_WorkflowStatusID)
			return true;
		if (m_WorkflowStatusID > _Right.m_WorkflowStatusID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWorkflowStatusStatsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWorkflowNewVersion
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	std::vector<HPMChangeCallbackData_WorkflowUpdateData> m_Workflows;
	HPMChangeCallbackData_ProjectWorkflowNewVersion()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWorkflowNewVersion(HPMChangeCallbackData_ProjectWorkflowNewVersion const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_Workflows(_Right.m_Workflows)
	{
	}
	HPMChangeCallbackData_ProjectWorkflowNewVersion(HPMChangeCallbackData_ProjectWorkflowNewVersion &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_Workflows(std::move(_Right.m_Workflows))
	{
	}
	HPMChangeCallbackData_ProjectWorkflowNewVersion &operator =(HPMChangeCallbackData_ProjectWorkflowNewVersion const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_Workflows = _Right.m_Workflows;
		return *this;
	}
	HPMChangeCallbackData_ProjectWorkflowNewVersion &operator =(HPMChangeCallbackData_ProjectWorkflowNewVersion &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_Workflows = std::move(_Right.m_Workflows);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_Workflows.size() != _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
			if (m_Workflows[i] != _Right.m_Workflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_Workflows.size() < _Right.m_Workflows.size())
			return true;
		if (m_Workflows.size() > _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
		{
			if (m_Workflows[i] < _Right.m_Workflows[i])
				return true;
			if (m_Workflows[i] > _Right.m_Workflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWorkflowNewVersion &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_FieldUpdateData
{
	public:
	HPMInt32 m_FieldID;
	HPMUInt32 m_FieldData;
	HPMChangeCallbackData_FieldUpdateData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_FieldUpdateData(HPMChangeCallbackData_FieldUpdateData const &_Right)
		: m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
	{
	}
	HPMChangeCallbackData_FieldUpdateData(HPMChangeCallbackData_FieldUpdateData &&_Right)
		: m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
	{
	}
	HPMChangeCallbackData_FieldUpdateData &operator =(HPMChangeCallbackData_FieldUpdateData const &_Right)
	{
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		return *this;
	}
	HPMChangeCallbackData_FieldUpdateData &operator =(HPMChangeCallbackData_FieldUpdateData &&_Right)
	{
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_FieldUpdateData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskUpdateData
{
	public:
	HPMUniqueID m_ID;
	std::vector<HPMChangeCallbackData_FieldUpdateData> m_Fields;
	HPMChangeCallbackData_TaskUpdateData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskUpdateData(HPMChangeCallbackData_TaskUpdateData const &_Right)
		: m_ID(_Right.m_ID)
		, m_Fields(_Right.m_Fields)
	{
	}
	HPMChangeCallbackData_TaskUpdateData(HPMChangeCallbackData_TaskUpdateData &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_Fields(std::move(_Right.m_Fields))
	{
	}
	HPMChangeCallbackData_TaskUpdateData &operator =(HPMChangeCallbackData_TaskUpdateData const &_Right)
	{
		m_ID = _Right.m_ID;
		m_Fields = _Right.m_Fields;
		return *this;
	}
	HPMChangeCallbackData_TaskUpdateData &operator =(HPMChangeCallbackData_TaskUpdateData &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_Fields = std::move(_Right.m_Fields);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_Fields.size() != _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
			if (m_Fields[i] != _Right.m_Fields[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_Fields.size() < _Right.m_Fields.size())
			return true;
		if (m_Fields.size() > _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
		{
			if (m_Fields[i] < _Right.m_Fields[i])
				return true;
			if (m_Fields[i] > _Right.m_Fields[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskUpdateData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	std::vector<HPMChangeCallbackData_TaskUpdateData> m_Tasks;
	HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion(HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_Tasks(_Right.m_Tasks)
	{
	}
	HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion(HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_Tasks(std::move(_Right.m_Tasks))
	{
	}
	HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &operator =(HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_Tasks = _Right.m_Tasks;
		return *this;
	}
	HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &operator =(HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_Tasks = std::move(_Right.m_Tasks);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_Tasks.size() != _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
			if (m_Tasks[i] != _Right.m_Tasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_Tasks.size() < _Right.m_Tasks.size())
			return true;
		if (m_Tasks.size() > _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
		{
			if (m_Tasks[i] < _Right.m_Tasks[i])
				return true;
			if (m_Tasks[i] > _Right.m_Tasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskUpdatePipelineWorkflowToNewestVersion &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectEmailSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectEmailSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectEmailSettingsChange(HPMChangeCallbackData_ProjectEmailSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectEmailSettingsChange(HPMChangeCallbackData_ProjectEmailSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectEmailSettingsChange &operator =(HPMChangeCallbackData_ProjectEmailSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectEmailSettingsChange &operator =(HPMChangeCallbackData_ProjectEmailSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectEmailSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectOpenBacklogProject
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	bool m_bSuccess;
	HPMUniqueID m_BacklogProjectID;
	HPMChangeCallbackData_ProjectOpenBacklogProject()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectOpenBacklogProject(HPMChangeCallbackData_ProjectOpenBacklogProject const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_bSuccess(_Right.m_bSuccess)
		, m_BacklogProjectID(_Right.m_BacklogProjectID)
	{
	}
	HPMChangeCallbackData_ProjectOpenBacklogProject(HPMChangeCallbackData_ProjectOpenBacklogProject &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_bSuccess(std::move(_Right.m_bSuccess))
		, m_BacklogProjectID(std::move(_Right.m_BacklogProjectID))
	{
	}
	HPMChangeCallbackData_ProjectOpenBacklogProject &operator =(HPMChangeCallbackData_ProjectOpenBacklogProject const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_bSuccess = _Right.m_bSuccess;
		m_BacklogProjectID = _Right.m_BacklogProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectOpenBacklogProject &operator =(HPMChangeCallbackData_ProjectOpenBacklogProject &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_bSuccess = std::move(_Right.m_bSuccess);
		m_BacklogProjectID = std::move(_Right.m_BacklogProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_bSuccess != _Right.m_bSuccess)
			return false;
		if (m_BacklogProjectID != _Right.m_BacklogProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_bSuccess < _Right.m_bSuccess)
			return true;
		if (m_bSuccess > _Right.m_bSuccess)
			return false;
		if (m_BacklogProjectID < _Right.m_BacklogProjectID)
			return true;
		if (m_BacklogProjectID > _Right.m_BacklogProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectOpenBacklogProject &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectOpenQAProject
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	bool m_bSuccess;
	HPMUniqueID m_QAProjectID;
	HPMChangeCallbackData_ProjectOpenQAProject()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectOpenQAProject(HPMChangeCallbackData_ProjectOpenQAProject const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_bSuccess(_Right.m_bSuccess)
		, m_QAProjectID(_Right.m_QAProjectID)
	{
	}
	HPMChangeCallbackData_ProjectOpenQAProject(HPMChangeCallbackData_ProjectOpenQAProject &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_bSuccess(std::move(_Right.m_bSuccess))
		, m_QAProjectID(std::move(_Right.m_QAProjectID))
	{
	}
	HPMChangeCallbackData_ProjectOpenQAProject &operator =(HPMChangeCallbackData_ProjectOpenQAProject const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_bSuccess = _Right.m_bSuccess;
		m_QAProjectID = _Right.m_QAProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectOpenQAProject &operator =(HPMChangeCallbackData_ProjectOpenQAProject &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_bSuccess = std::move(_Right.m_bSuccess);
		m_QAProjectID = std::move(_Right.m_QAProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_bSuccess != _Right.m_bSuccess)
			return false;
		if (m_QAProjectID != _Right.m_QAProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_bSuccess < _Right.m_bSuccess)
			return true;
		if (m_bSuccess > _Right.m_bSuccess)
			return false;
		if (m_QAProjectID < _Right.m_QAProjectID)
			return true;
		if (m_QAProjectID > _Right.m_QAProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectOpenQAProject &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange(HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange(HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &operator =(HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &operator =(HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectHistoryAutoSaveSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomColumnsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectCustomColumnsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomColumnsChange(HPMChangeCallbackData_ProjectCustomColumnsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsChange(HPMChangeCallbackData_ProjectCustomColumnsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsChange &operator =(HPMChangeCallbackData_ProjectCustomColumnsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomColumnsChange &operator =(HPMChangeCallbackData_ProjectCustomColumnsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomColumnsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomColumnsCreate
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_ColumnHash;
	HPMChangeCallbackData_ProjectCustomColumnsCreate()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomColumnsCreate(HPMChangeCallbackData_ProjectCustomColumnsCreate const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ColumnHash(_Right.m_ColumnHash)
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsCreate(HPMChangeCallbackData_ProjectCustomColumnsCreate &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ColumnHash(std::move(_Right.m_ColumnHash))
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsCreate &operator =(HPMChangeCallbackData_ProjectCustomColumnsCreate const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ColumnHash = _Right.m_ColumnHash;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomColumnsCreate &operator =(HPMChangeCallbackData_ProjectCustomColumnsCreate &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ColumnHash = std::move(_Right.m_ColumnHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ColumnHash != _Right.m_ColumnHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ColumnHash < _Right.m_ColumnHash)
			return true;
		if (m_ColumnHash > _Right.m_ColumnHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomColumnsCreate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_ColumnHash;
	HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData(HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ColumnHash(_Right.m_ColumnHash)
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData(HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ColumnHash(std::move(_Right.m_ColumnHash))
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &operator =(HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ColumnHash = _Right.m_ColumnHash;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &operator =(HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ColumnHash = std::move(_Right.m_ColumnHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ColumnHash != _Right.m_ColumnHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ColumnHash < _Right.m_ColumnHash)
			return true;
		if (m_ColumnHash > _Right.m_ColumnHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomColumnsDeleteTaskData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_ColumnHashFrom;
	HPMUInt32 m_ColumnHashTo;
	HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData(HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ColumnHashFrom(_Right.m_ColumnHashFrom)
		, m_ColumnHashTo(_Right.m_ColumnHashTo)
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData(HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ColumnHashFrom(std::move(_Right.m_ColumnHashFrom))
		, m_ColumnHashTo(std::move(_Right.m_ColumnHashTo))
	{
	}
	HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &operator =(HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ColumnHashFrom = _Right.m_ColumnHashFrom;
		m_ColumnHashTo = _Right.m_ColumnHashTo;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &operator =(HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ColumnHashFrom = std::move(_Right.m_ColumnHashFrom);
		m_ColumnHashTo = std::move(_Right.m_ColumnHashTo);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ColumnHashFrom != _Right.m_ColumnHashFrom)
			return false;
		if (m_ColumnHashTo != _Right.m_ColumnHashTo)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ColumnHashFrom < _Right.m_ColumnHashFrom)
			return true;
		if (m_ColumnHashFrom > _Right.m_ColumnHashFrom)
			return false;
		if (m_ColumnHashTo < _Right.m_ColumnHashTo)
			return true;
		if (m_ColumnHashTo > _Right.m_ColumnHashTo)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomColumnsRenameTaskData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectActiveDefaultColumnsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectActiveDefaultColumnsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectActiveDefaultColumnsChange(HPMChangeCallbackData_ProjectActiveDefaultColumnsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectActiveDefaultColumnsChange(HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &operator =(HPMChangeCallbackData_ProjectActiveDefaultColumnsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &operator =(HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectActiveDefaultColumnsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWallSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectWallSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWallSettingsChange(HPMChangeCallbackData_ProjectWallSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectWallSettingsChange(HPMChangeCallbackData_ProjectWallSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectWallSettingsChange &operator =(HPMChangeCallbackData_ProjectWallSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectWallSettingsChange &operator =(HPMChangeCallbackData_ProjectWallSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWallSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectWallGroupsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectWallGroupsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectWallGroupsChange(HPMChangeCallbackData_ProjectWallGroupsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectWallGroupsChange(HPMChangeCallbackData_ProjectWallGroupsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectWallGroupsChange &operator =(HPMChangeCallbackData_ProjectWallGroupsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectWallGroupsChange &operator =(HPMChangeCallbackData_ProjectWallGroupsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectWallGroupsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectDetailedAccessRulesChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectDetailedAccessRulesChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectDetailedAccessRulesChange(HPMChangeCallbackData_ProjectDetailedAccessRulesChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectDetailedAccessRulesChange(HPMChangeCallbackData_ProjectDetailedAccessRulesChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectDetailedAccessRulesChange &operator =(HPMChangeCallbackData_ProjectDetailedAccessRulesChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectDetailedAccessRulesChange &operator =(HPMChangeCallbackData_ProjectDetailedAccessRulesChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectDetailedAccessRulesChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange(HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange(HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &operator =(HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &operator =(HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomStatisticsSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectResourceAdd
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ProjectResourceAdd()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectResourceAdd(HPMChangeCallbackData_ProjectResourceAdd const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ProjectResourceAdd(HPMChangeCallbackData_ProjectResourceAdd &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ProjectResourceAdd &operator =(HPMChangeCallbackData_ProjectResourceAdd const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ProjectResourceAdd &operator =(HPMChangeCallbackData_ProjectResourceAdd &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectResourceAdd &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectResourceRemove
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ProjectResourceRemove()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectResourceRemove(HPMChangeCallbackData_ProjectResourceRemove const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ProjectResourceRemove(HPMChangeCallbackData_ProjectResourceRemove &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ProjectResourceRemove &operator =(HPMChangeCallbackData_ProjectResourceRemove const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ProjectResourceRemove &operator =(HPMChangeCallbackData_ProjectResourceRemove &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectResourceRemove &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectResourcePropertiesChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ProjectResourcePropertiesChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectResourcePropertiesChange(HPMChangeCallbackData_ProjectResourcePropertiesChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ProjectResourcePropertiesChange(HPMChangeCallbackData_ProjectResourcePropertiesChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ProjectResourcePropertiesChange &operator =(HPMChangeCallbackData_ProjectResourcePropertiesChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ProjectResourcePropertiesChange &operator =(HPMChangeCallbackData_ProjectResourcePropertiesChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectResourcePropertiesChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskCreateUnifiedTask
{
	public:
	bool m_bIsProxy;
	HPMUniqueID m_LocalID;
	HPMUniqueID m_TaskRefID;
	HPMChangeCallbackData_TaskCreateUnifiedTask()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskCreateUnifiedTask(HPMChangeCallbackData_TaskCreateUnifiedTask const &_Right)
		: m_bIsProxy(_Right.m_bIsProxy)
		, m_LocalID(_Right.m_LocalID)
		, m_TaskRefID(_Right.m_TaskRefID)
	{
	}
	HPMChangeCallbackData_TaskCreateUnifiedTask(HPMChangeCallbackData_TaskCreateUnifiedTask &&_Right)
		: m_bIsProxy(std::move(_Right.m_bIsProxy))
		, m_LocalID(std::move(_Right.m_LocalID))
		, m_TaskRefID(std::move(_Right.m_TaskRefID))
	{
	}
	HPMChangeCallbackData_TaskCreateUnifiedTask &operator =(HPMChangeCallbackData_TaskCreateUnifiedTask const &_Right)
	{
		m_bIsProxy = _Right.m_bIsProxy;
		m_LocalID = _Right.m_LocalID;
		m_TaskRefID = _Right.m_TaskRefID;
		return *this;
	}
	HPMChangeCallbackData_TaskCreateUnifiedTask &operator =(HPMChangeCallbackData_TaskCreateUnifiedTask &&_Right)
	{
		m_bIsProxy = std::move(_Right.m_bIsProxy);
		m_LocalID = std::move(_Right.m_LocalID);
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		if (m_bIsProxy != _Right.m_bIsProxy)
			return false;
		if (m_LocalID != _Right.m_LocalID)
			return false;
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		if (m_bIsProxy < _Right.m_bIsProxy)
			return true;
		if (m_bIsProxy > _Right.m_bIsProxy)
			return false;
		if (m_LocalID < _Right.m_LocalID)
			return true;
		if (m_LocalID > _Right.m_LocalID)
			return false;
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskCreateUnifiedTask &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskCreateUnified
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	std::vector<HPMChangeCallbackData_TaskCreateUnifiedTask> m_Tasks;
	HPMChangeCallbackData_TaskCreateUnified()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskCreateUnified(HPMChangeCallbackData_TaskCreateUnified const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_Tasks(_Right.m_Tasks)
	{
	}
	HPMChangeCallbackData_TaskCreateUnified(HPMChangeCallbackData_TaskCreateUnified &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_Tasks(std::move(_Right.m_Tasks))
	{
	}
	HPMChangeCallbackData_TaskCreateUnified &operator =(HPMChangeCallbackData_TaskCreateUnified const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_Tasks = _Right.m_Tasks;
		return *this;
	}
	HPMChangeCallbackData_TaskCreateUnified &operator =(HPMChangeCallbackData_TaskCreateUnified &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_Tasks = std::move(_Right.m_Tasks);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_Tasks.size() != _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
			if (m_Tasks[i] != _Right.m_Tasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_Tasks.size() < _Right.m_Tasks.size())
			return true;
		if (m_Tasks.size() > _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
		{
			if (m_Tasks[i] < _Right.m_Tasks[i])
				return true;
			if (m_Tasks[i] > _Right.m_Tasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskCreateUnified &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangeDisposition
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	bool m_bChangeWorkPriorityDisposition;
	bool m_bDispositionChangedRejected;
	HPMString m_RejectedDebugData;
	std::vector<HPMUniqueID> m_TasksRejected;
	HPMChangeCallbackData_TaskChangeDisposition()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangeDisposition(HPMChangeCallbackData_TaskChangeDisposition const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_bChangeWorkPriorityDisposition(_Right.m_bChangeWorkPriorityDisposition)
		, m_bDispositionChangedRejected(_Right.m_bDispositionChangedRejected)
		, m_RejectedDebugData(_Right.m_RejectedDebugData)
		, m_TasksRejected(_Right.m_TasksRejected)
	{
	}
	HPMChangeCallbackData_TaskChangeDisposition(HPMChangeCallbackData_TaskChangeDisposition &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_bChangeWorkPriorityDisposition(std::move(_Right.m_bChangeWorkPriorityDisposition))
		, m_bDispositionChangedRejected(std::move(_Right.m_bDispositionChangedRejected))
		, m_RejectedDebugData(std::move(_Right.m_RejectedDebugData))
		, m_TasksRejected(std::move(_Right.m_TasksRejected))
	{
	}
	HPMChangeCallbackData_TaskChangeDisposition &operator =(HPMChangeCallbackData_TaskChangeDisposition const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_bChangeWorkPriorityDisposition = _Right.m_bChangeWorkPriorityDisposition;
		m_bDispositionChangedRejected = _Right.m_bDispositionChangedRejected;
		m_RejectedDebugData = _Right.m_RejectedDebugData;
		m_TasksRejected = _Right.m_TasksRejected;
		return *this;
	}
	HPMChangeCallbackData_TaskChangeDisposition &operator =(HPMChangeCallbackData_TaskChangeDisposition &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_bChangeWorkPriorityDisposition = std::move(_Right.m_bChangeWorkPriorityDisposition);
		m_bDispositionChangedRejected = std::move(_Right.m_bDispositionChangedRejected);
		m_RejectedDebugData = std::move(_Right.m_RejectedDebugData);
		m_TasksRejected = std::move(_Right.m_TasksRejected);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_bChangeWorkPriorityDisposition != _Right.m_bChangeWorkPriorityDisposition)
			return false;
		if (m_bDispositionChangedRejected != _Right.m_bDispositionChangedRejected)
			return false;
		if (m_RejectedDebugData != _Right.m_RejectedDebugData)
			return false;
		if (m_TasksRejected.size() != _Right.m_TasksRejected.size())
			return false;
		for (size_t i = 0; i < m_TasksRejected.size(); ++i)
			if (m_TasksRejected[i] != _Right.m_TasksRejected[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_bChangeWorkPriorityDisposition < _Right.m_bChangeWorkPriorityDisposition)
			return true;
		if (m_bChangeWorkPriorityDisposition > _Right.m_bChangeWorkPriorityDisposition)
			return false;
		if (m_bDispositionChangedRejected < _Right.m_bDispositionChangedRejected)
			return true;
		if (m_bDispositionChangedRejected > _Right.m_bDispositionChangedRejected)
			return false;
		if (m_RejectedDebugData < _Right.m_RejectedDebugData)
			return true;
		if (m_RejectedDebugData > _Right.m_RejectedDebugData)
			return false;
		if (m_TasksRejected.size() < _Right.m_TasksRejected.size())
			return true;
		if (m_TasksRejected.size() > _Right.m_TasksRejected.size())
			return false;
		for (size_t i = 0; i < m_TasksRejected.size(); ++i)
		{
			if (m_TasksRejected[i] < _Right.m_TasksRejected[i])
				return true;
			if (m_TasksRejected[i] > _Right.m_TasksRejected[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangeDisposition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMChangeCallbackData_TaskDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskDelete(HPMChangeCallbackData_TaskDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
	{
	}
	HPMChangeCallbackData_TaskDelete(HPMChangeCallbackData_TaskDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
	{
	}
	HPMChangeCallbackData_TaskDelete &operator =(HPMChangeCallbackData_TaskDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		return *this;
	}
	HPMChangeCallbackData_TaskDelete &operator =(HPMChangeCallbackData_TaskDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskCreateComment
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMInt32 m_PostID;
	HPMChangeCallbackData_TaskCreateComment()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskCreateComment(HPMChangeCallbackData_TaskCreateComment const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_PostID(_Right.m_PostID)
	{
	}
	HPMChangeCallbackData_TaskCreateComment(HPMChangeCallbackData_TaskCreateComment &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_PostID(std::move(_Right.m_PostID))
	{
	}
	HPMChangeCallbackData_TaskCreateComment &operator =(HPMChangeCallbackData_TaskCreateComment const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_PostID = _Right.m_PostID;
		return *this;
	}
	HPMChangeCallbackData_TaskCreateComment &operator =(HPMChangeCallbackData_TaskCreateComment &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_PostID = std::move(_Right.m_PostID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_PostID != _Right.m_PostID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_PostID < _Right.m_PostID)
			return true;
		if (m_PostID > _Right.m_PostID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskCreateComment &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskCommentSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMInt32 m_PostID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_TaskCommentSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskCommentSDKInternalDataChange(HPMChangeCallbackData_TaskCommentSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_PostID(_Right.m_PostID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_TaskCommentSDKInternalDataChange(HPMChangeCallbackData_TaskCommentSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_PostID(std::move(_Right.m_PostID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_TaskCommentSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskCommentSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_PostID = _Right.m_PostID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_TaskCommentSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskCommentSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_PostID = std::move(_Right.m_PostID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_PostID != _Right.m_PostID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_PostID < _Right.m_PostID)
			return true;
		if (m_PostID > _Right.m_PostID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskCommentSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskEditComment
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMInt32 m_PostID;
	HPMChangeCallbackData_TaskEditComment()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskEditComment(HPMChangeCallbackData_TaskEditComment const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_PostID(_Right.m_PostID)
	{
	}
	HPMChangeCallbackData_TaskEditComment(HPMChangeCallbackData_TaskEditComment &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_PostID(std::move(_Right.m_PostID))
	{
	}
	HPMChangeCallbackData_TaskEditComment &operator =(HPMChangeCallbackData_TaskEditComment const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_PostID = _Right.m_PostID;
		return *this;
	}
	HPMChangeCallbackData_TaskEditComment &operator =(HPMChangeCallbackData_TaskEditComment &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_PostID = std::move(_Right.m_PostID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_PostID != _Right.m_PostID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_PostID < _Right.m_PostID)
			return true;
		if (m_PostID > _Right.m_PostID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskEditComment &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskDeleteComment
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMInt32 m_PostID;
	HPMChangeCallbackData_TaskDeleteComment()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskDeleteComment(HPMChangeCallbackData_TaskDeleteComment const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_PostID(_Right.m_PostID)
	{
	}
	HPMChangeCallbackData_TaskDeleteComment(HPMChangeCallbackData_TaskDeleteComment &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_PostID(std::move(_Right.m_PostID))
	{
	}
	HPMChangeCallbackData_TaskDeleteComment &operator =(HPMChangeCallbackData_TaskDeleteComment const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_PostID = _Right.m_PostID;
		return *this;
	}
	HPMChangeCallbackData_TaskDeleteComment &operator =(HPMChangeCallbackData_TaskDeleteComment &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_PostID = std::move(_Right.m_PostID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_PostID != _Right.m_PostID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_PostID < _Right.m_PostID)
			return true;
		if (m_PostID > _Right.m_PostID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskDeleteComment &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskCommentPosted
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMInt32 m_PostID;
	HPMChangeCallbackData_TaskCommentPosted()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskCommentPosted(HPMChangeCallbackData_TaskCommentPosted const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_PostID(_Right.m_PostID)
	{
	}
	HPMChangeCallbackData_TaskCommentPosted(HPMChangeCallbackData_TaskCommentPosted &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_PostID(std::move(_Right.m_PostID))
	{
	}
	HPMChangeCallbackData_TaskCommentPosted &operator =(HPMChangeCallbackData_TaskCommentPosted const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_PostID = _Right.m_PostID;
		return *this;
	}
	HPMChangeCallbackData_TaskCommentPosted &operator =(HPMChangeCallbackData_TaskCommentPosted &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_PostID = std::move(_Right.m_PostID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_PostID != _Right.m_PostID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_PostID < _Right.m_PostID)
			return true;
		if (m_PostID > _Right.m_PostID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskCommentPosted &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	EHPMTaskField m_FieldChanged;
	HPMChangeCallbackData_TaskChange()
		: m_FieldChanged(EHPMTaskField_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChange(HPMChangeCallbackData_TaskChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_FieldChanged(_Right.m_FieldChanged)
	{
	}
	HPMChangeCallbackData_TaskChange(HPMChangeCallbackData_TaskChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_FieldChanged(std::move(_Right.m_FieldChanged))
	{
	}
	HPMChangeCallbackData_TaskChange &operator =(HPMChangeCallbackData_TaskChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_FieldChanged = _Right.m_FieldChanged;
		return *this;
	}
	HPMChangeCallbackData_TaskChange &operator =(HPMChangeCallbackData_TaskChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_FieldChanged = std::move(_Right.m_FieldChanged);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_FieldChanged != _Right.m_FieldChanged)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_FieldChanged < _Right.m_FieldChanged)
			return true;
		if (m_FieldChanged > _Right.m_FieldChanged)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskLastExitWorkflowStatusChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMChangeCallbackData_TaskLastExitWorkflowStatusChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskLastExitWorkflowStatusChange(HPMChangeCallbackData_TaskLastExitWorkflowStatusChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
	{
	}
	HPMChangeCallbackData_TaskLastExitWorkflowStatusChange(HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
	{
	}
	HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastExitWorkflowStatusChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		return *this;
	}
	HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskLastExitWorkflowStatusChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange(HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
	{
	}
	HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange(HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
	{
	}
	HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		return *this;
	}
	HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskLastEnterWorkflowStatusChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange(HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
	{
	}
	HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange(HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
	{
	}
	HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		return *this;
	}
	HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &operator =(HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskLastAssignedInWorkflowStatusChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangeCustomColumnData
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_ColumnHash;
	HPMChangeCallbackData_TaskChangeCustomColumnData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangeCustomColumnData(HPMChangeCallbackData_TaskChangeCustomColumnData const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_ColumnHash(_Right.m_ColumnHash)
	{
	}
	HPMChangeCallbackData_TaskChangeCustomColumnData(HPMChangeCallbackData_TaskChangeCustomColumnData &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_ColumnHash(std::move(_Right.m_ColumnHash))
	{
	}
	HPMChangeCallbackData_TaskChangeCustomColumnData &operator =(HPMChangeCallbackData_TaskChangeCustomColumnData const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_ColumnHash = _Right.m_ColumnHash;
		return *this;
	}
	HPMChangeCallbackData_TaskChangeCustomColumnData &operator =(HPMChangeCallbackData_TaskChangeCustomColumnData &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_ColumnHash = std::move(_Right.m_ColumnHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_ColumnHash != _Right.m_ColumnHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_ColumnHash < _Right.m_ColumnHash)
			return true;
		if (m_ColumnHash > _Right.m_ColumnHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangeCustomColumnData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime(HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime(HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &operator =(HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &operator =(HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangeLastResourceCommentReadTime &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangeWorkRemainingHistory
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_DayInSprint;
	HPMChangeCallbackData_TaskChangeWorkRemainingHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangeWorkRemainingHistory(HPMChangeCallbackData_TaskChangeWorkRemainingHistory const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_DayInSprint(_Right.m_DayInSprint)
	{
	}
	HPMChangeCallbackData_TaskChangeWorkRemainingHistory(HPMChangeCallbackData_TaskChangeWorkRemainingHistory &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_DayInSprint(std::move(_Right.m_DayInSprint))
	{
	}
	HPMChangeCallbackData_TaskChangeWorkRemainingHistory &operator =(HPMChangeCallbackData_TaskChangeWorkRemainingHistory const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_DayInSprint = _Right.m_DayInSprint;
		return *this;
	}
	HPMChangeCallbackData_TaskChangeWorkRemainingHistory &operator =(HPMChangeCallbackData_TaskChangeWorkRemainingHistory &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_DayInSprint = std::move(_Right.m_DayInSprint);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_DayInSprint != _Right.m_DayInSprint)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_DayInSprint < _Right.m_DayInSprint)
			return true;
		if (m_DayInSprint > _Right.m_DayInSprint)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangeWorkRemainingHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangePointsHistory
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_DayInSprint;
	HPMChangeCallbackData_TaskChangePointsHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangePointsHistory(HPMChangeCallbackData_TaskChangePointsHistory const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_DayInSprint(_Right.m_DayInSprint)
	{
	}
	HPMChangeCallbackData_TaskChangePointsHistory(HPMChangeCallbackData_TaskChangePointsHistory &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_DayInSprint(std::move(_Right.m_DayInSprint))
	{
	}
	HPMChangeCallbackData_TaskChangePointsHistory &operator =(HPMChangeCallbackData_TaskChangePointsHistory const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_DayInSprint = _Right.m_DayInSprint;
		return *this;
	}
	HPMChangeCallbackData_TaskChangePointsHistory &operator =(HPMChangeCallbackData_TaskChangePointsHistory &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_DayInSprint = std::move(_Right.m_DayInSprint);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_DayInSprint != _Right.m_DayInSprint)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_DayInSprint < _Right.m_DayInSprint)
			return true;
		if (m_DayInSprint > _Right.m_DayInSprint)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangePointsHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskChangeIdealDaysHistory
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_DayInSprint;
	HPMChangeCallbackData_TaskChangeIdealDaysHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskChangeIdealDaysHistory(HPMChangeCallbackData_TaskChangeIdealDaysHistory const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_DayInSprint(_Right.m_DayInSprint)
	{
	}
	HPMChangeCallbackData_TaskChangeIdealDaysHistory(HPMChangeCallbackData_TaskChangeIdealDaysHistory &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_DayInSprint(std::move(_Right.m_DayInSprint))
	{
	}
	HPMChangeCallbackData_TaskChangeIdealDaysHistory &operator =(HPMChangeCallbackData_TaskChangeIdealDaysHistory const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_DayInSprint = _Right.m_DayInSprint;
		return *this;
	}
	HPMChangeCallbackData_TaskChangeIdealDaysHistory &operator =(HPMChangeCallbackData_TaskChangeIdealDaysHistory &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_DayInSprint = std::move(_Right.m_DayInSprint);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_DayInSprint != _Right.m_DayInSprint)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_DayInSprint < _Right.m_DayInSprint)
			return true;
		if (m_DayInSprint > _Right.m_DayInSprint)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskChangeIdealDaysHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskRefChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskRefID;
	EHPMTaskRefField m_FieldChanged;
	HPMChangeCallbackData_TaskRefChange()
		: m_FieldChanged(EHPMTaskRefField_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskRefChange(HPMChangeCallbackData_TaskRefChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskRefID(_Right.m_TaskRefID)
		, m_FieldChanged(_Right.m_FieldChanged)
	{
	}
	HPMChangeCallbackData_TaskRefChange(HPMChangeCallbackData_TaskRefChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_FieldChanged(std::move(_Right.m_FieldChanged))
	{
	}
	HPMChangeCallbackData_TaskRefChange &operator =(HPMChangeCallbackData_TaskRefChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskRefID = _Right.m_TaskRefID;
		m_FieldChanged = _Right.m_FieldChanged;
		return *this;
	}
	HPMChangeCallbackData_TaskRefChange &operator =(HPMChangeCallbackData_TaskRefChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_FieldChanged = std::move(_Right.m_FieldChanged);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_FieldChanged != _Right.m_FieldChanged)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_FieldChanged < _Right.m_FieldChanged)
			return true;
		if (m_FieldChanged > _Right.m_FieldChanged)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskRefChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskRefDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskRefID;
	HPMChangeCallbackData_TaskRefDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskRefDelete(HPMChangeCallbackData_TaskRefDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskRefID(_Right.m_TaskRefID)
	{
	}
	HPMChangeCallbackData_TaskRefDelete(HPMChangeCallbackData_TaskRefDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskRefID(std::move(_Right.m_TaskRefID))
	{
	}
	HPMChangeCallbackData_TaskRefDelete &operator =(HPMChangeCallbackData_TaskRefDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskRefID = _Right.m_TaskRefID;
		return *this;
	}
	HPMChangeCallbackData_TaskRefDelete &operator =(HPMChangeCallbackData_TaskRefDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskRefDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskRefConnect
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_LocalTempConnectionID;
	HPMUniqueID m_ConnectionID;
	HPMUniqueID m_TaskRefIDFrom;
	HPMUniqueID m_TaskRefIDTo;
	HPMChangeCallbackData_TaskRefConnect()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskRefConnect(HPMChangeCallbackData_TaskRefConnect const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_LocalTempConnectionID(_Right.m_LocalTempConnectionID)
		, m_ConnectionID(_Right.m_ConnectionID)
		, m_TaskRefIDFrom(_Right.m_TaskRefIDFrom)
		, m_TaskRefIDTo(_Right.m_TaskRefIDTo)
	{
	}
	HPMChangeCallbackData_TaskRefConnect(HPMChangeCallbackData_TaskRefConnect &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_LocalTempConnectionID(std::move(_Right.m_LocalTempConnectionID))
		, m_ConnectionID(std::move(_Right.m_ConnectionID))
		, m_TaskRefIDFrom(std::move(_Right.m_TaskRefIDFrom))
		, m_TaskRefIDTo(std::move(_Right.m_TaskRefIDTo))
	{
	}
	HPMChangeCallbackData_TaskRefConnect &operator =(HPMChangeCallbackData_TaskRefConnect const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_LocalTempConnectionID = _Right.m_LocalTempConnectionID;
		m_ConnectionID = _Right.m_ConnectionID;
		m_TaskRefIDFrom = _Right.m_TaskRefIDFrom;
		m_TaskRefIDTo = _Right.m_TaskRefIDTo;
		return *this;
	}
	HPMChangeCallbackData_TaskRefConnect &operator =(HPMChangeCallbackData_TaskRefConnect &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_LocalTempConnectionID = std::move(_Right.m_LocalTempConnectionID);
		m_ConnectionID = std::move(_Right.m_ConnectionID);
		m_TaskRefIDFrom = std::move(_Right.m_TaskRefIDFrom);
		m_TaskRefIDTo = std::move(_Right.m_TaskRefIDTo);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_LocalTempConnectionID != _Right.m_LocalTempConnectionID)
			return false;
		if (m_ConnectionID != _Right.m_ConnectionID)
			return false;
		if (m_TaskRefIDFrom != _Right.m_TaskRefIDFrom)
			return false;
		if (m_TaskRefIDTo != _Right.m_TaskRefIDTo)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_LocalTempConnectionID < _Right.m_LocalTempConnectionID)
			return true;
		if (m_LocalTempConnectionID > _Right.m_LocalTempConnectionID)
			return false;
		if (m_ConnectionID < _Right.m_ConnectionID)
			return true;
		if (m_ConnectionID > _Right.m_ConnectionID)
			return false;
		if (m_TaskRefIDFrom < _Right.m_TaskRefIDFrom)
			return true;
		if (m_TaskRefIDFrom > _Right.m_TaskRefIDFrom)
			return false;
		if (m_TaskRefIDTo < _Right.m_TaskRefIDTo)
			return true;
		if (m_TaskRefIDTo > _Right.m_TaskRefIDTo)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskRefConnect &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskConnectionDelete
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ConnectionID;
	HPMChangeCallbackData_TaskConnectionDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskConnectionDelete(HPMChangeCallbackData_TaskConnectionDelete const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ConnectionID(_Right.m_ConnectionID)
	{
	}
	HPMChangeCallbackData_TaskConnectionDelete(HPMChangeCallbackData_TaskConnectionDelete &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ConnectionID(std::move(_Right.m_ConnectionID))
	{
	}
	HPMChangeCallbackData_TaskConnectionDelete &operator =(HPMChangeCallbackData_TaskConnectionDelete const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ConnectionID = _Right.m_ConnectionID;
		return *this;
	}
	HPMChangeCallbackData_TaskConnectionDelete &operator =(HPMChangeCallbackData_TaskConnectionDelete &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ConnectionID = std::move(_Right.m_ConnectionID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID != _Right.m_ConnectionID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID < _Right.m_ConnectionID)
			return true;
		if (m_ConnectionID > _Right.m_ConnectionID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskConnectionDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskConnectionChangeType
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ConnectionID;
	HPMChangeCallbackData_TaskConnectionChangeType()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskConnectionChangeType(HPMChangeCallbackData_TaskConnectionChangeType const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ConnectionID(_Right.m_ConnectionID)
	{
	}
	HPMChangeCallbackData_TaskConnectionChangeType(HPMChangeCallbackData_TaskConnectionChangeType &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ConnectionID(std::move(_Right.m_ConnectionID))
	{
	}
	HPMChangeCallbackData_TaskConnectionChangeType &operator =(HPMChangeCallbackData_TaskConnectionChangeType const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ConnectionID = _Right.m_ConnectionID;
		return *this;
	}
	HPMChangeCallbackData_TaskConnectionChangeType &operator =(HPMChangeCallbackData_TaskConnectionChangeType &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ConnectionID = std::move(_Right.m_ConnectionID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID != _Right.m_ConnectionID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID < _Right.m_ConnectionID)
			return true;
		if (m_ConnectionID > _Right.m_ConnectionID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskConnectionChangeType &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskConnectionChangeLeadLagTime
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ConnectionID;
	HPMChangeCallbackData_TaskConnectionChangeLeadLagTime()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskConnectionChangeLeadLagTime(HPMChangeCallbackData_TaskConnectionChangeLeadLagTime const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ConnectionID(_Right.m_ConnectionID)
	{
	}
	HPMChangeCallbackData_TaskConnectionChangeLeadLagTime(HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ConnectionID(std::move(_Right.m_ConnectionID))
	{
	}
	HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &operator =(HPMChangeCallbackData_TaskConnectionChangeLeadLagTime const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ConnectionID = _Right.m_ConnectionID;
		return *this;
	}
	HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &operator =(HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ConnectionID = std::move(_Right.m_ConnectionID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID != _Right.m_ConnectionID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ConnectionID < _Right.m_ConnectionID)
			return true;
		if (m_ConnectionID > _Right.m_ConnectionID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskConnectionChangeLeadLagTime &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_DataHistoryReceived
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_UniqueIdentifier;
	HPMInt32 m_FieldID;
	HPMUInt32 m_FieldData;
	HPMUInt32 m_DataIdent0;
	HPMUInt32 m_DataIdent1;
	HPMChangeCallbackData_DataHistoryReceived()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_DataHistoryReceived(HPMChangeCallbackData_DataHistoryReceived const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_UniqueIdentifier(_Right.m_UniqueIdentifier)
		, m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
		, m_DataIdent0(_Right.m_DataIdent0)
		, m_DataIdent1(_Right.m_DataIdent1)
	{
	}
	HPMChangeCallbackData_DataHistoryReceived(HPMChangeCallbackData_DataHistoryReceived &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_UniqueIdentifier(std::move(_Right.m_UniqueIdentifier))
		, m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
		, m_DataIdent0(std::move(_Right.m_DataIdent0))
		, m_DataIdent1(std::move(_Right.m_DataIdent1))
	{
	}
	HPMChangeCallbackData_DataHistoryReceived &operator =(HPMChangeCallbackData_DataHistoryReceived const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_UniqueIdentifier = _Right.m_UniqueIdentifier;
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		m_DataIdent0 = _Right.m_DataIdent0;
		m_DataIdent1 = _Right.m_DataIdent1;
		return *this;
	}
	HPMChangeCallbackData_DataHistoryReceived &operator =(HPMChangeCallbackData_DataHistoryReceived &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_UniqueIdentifier = std::move(_Right.m_UniqueIdentifier);
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		m_DataIdent0 = std::move(_Right.m_DataIdent0);
		m_DataIdent1 = std::move(_Right.m_DataIdent1);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_UniqueIdentifier != _Right.m_UniqueIdentifier)
			return false;
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		if (m_DataIdent0 != _Right.m_DataIdent0)
			return false;
		if (m_DataIdent1 != _Right.m_DataIdent1)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_UniqueIdentifier < _Right.m_UniqueIdentifier)
			return true;
		if (m_UniqueIdentifier > _Right.m_UniqueIdentifier)
			return false;
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		if (m_DataIdent0 < _Right.m_DataIdent0)
			return true;
		if (m_DataIdent0 > _Right.m_DataIdent0)
			return false;
		if (m_DataIdent1 < _Right.m_DataIdent1)
			return true;
		if (m_DataIdent1 > _Right.m_DataIdent1)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_DataHistoryReceived &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ChatHistoryReceived
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_UniqueIdentifier;
	HPMChatRoom m_ChatRoom;
	HPMChangeCallbackData_ChatHistoryReceived()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ChatHistoryReceived(HPMChangeCallbackData_ChatHistoryReceived const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_UniqueIdentifier(_Right.m_UniqueIdentifier)
		, m_ChatRoom(_Right.m_ChatRoom)
	{
	}
	HPMChangeCallbackData_ChatHistoryReceived(HPMChangeCallbackData_ChatHistoryReceived &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_UniqueIdentifier(std::move(_Right.m_UniqueIdentifier))
		, m_ChatRoom(std::move(_Right.m_ChatRoom))
	{
	}
	HPMChangeCallbackData_ChatHistoryReceived &operator =(HPMChangeCallbackData_ChatHistoryReceived const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_UniqueIdentifier = _Right.m_UniqueIdentifier;
		m_ChatRoom = _Right.m_ChatRoom;
		return *this;
	}
	HPMChangeCallbackData_ChatHistoryReceived &operator =(HPMChangeCallbackData_ChatHistoryReceived &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_UniqueIdentifier = std::move(_Right.m_UniqueIdentifier);
		m_ChatRoom = std::move(_Right.m_ChatRoom);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_UniqueIdentifier != _Right.m_UniqueIdentifier)
			return false;
		if (m_ChatRoom != _Right.m_ChatRoom)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_UniqueIdentifier < _Right.m_UniqueIdentifier)
			return true;
		if (m_UniqueIdentifier > _Right.m_UniqueIdentifier)
			return false;
		if (m_ChatRoom < _Right.m_ChatRoom)
			return true;
		if (m_ChatRoom > _Right.m_ChatRoom)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ChatHistoryReceived &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CalendarChangeHolidays
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_CalendarChangeHolidays()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CalendarChangeHolidays(HPMChangeCallbackData_CalendarChangeHolidays const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_CalendarChangeHolidays(HPMChangeCallbackData_CalendarChangeHolidays &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_CalendarChangeHolidays &operator =(HPMChangeCallbackData_CalendarChangeHolidays const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_CalendarChangeHolidays &operator =(HPMChangeCallbackData_CalendarChangeHolidays &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CalendarChangeHolidays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CalendarChangeCustomWorkingHours
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_CalendarChangeCustomWorkingHours()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CalendarChangeCustomWorkingHours(HPMChangeCallbackData_CalendarChangeCustomWorkingHours const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingHours(HPMChangeCallbackData_CalendarChangeCustomWorkingHours &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingHours &operator =(HPMChangeCallbackData_CalendarChangeCustomWorkingHours const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingHours &operator =(HPMChangeCallbackData_CalendarChangeCustomWorkingHours &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CalendarChangeCustomWorkingHours &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CalendarChangeWorkingHours
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_CalendarChangeWorkingHours()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CalendarChangeWorkingHours(HPMChangeCallbackData_CalendarChangeWorkingHours const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_CalendarChangeWorkingHours(HPMChangeCallbackData_CalendarChangeWorkingHours &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_CalendarChangeWorkingHours &operator =(HPMChangeCallbackData_CalendarChangeWorkingHours const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_CalendarChangeWorkingHours &operator =(HPMChangeCallbackData_CalendarChangeWorkingHours &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CalendarChangeWorkingHours &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CalendarChangeCustomWorkingDays
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_CalendarChangeCustomWorkingDays()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CalendarChangeCustomWorkingDays(HPMChangeCallbackData_CalendarChangeCustomWorkingDays const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingDays(HPMChangeCallbackData_CalendarChangeCustomWorkingDays &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingDays &operator =(HPMChangeCallbackData_CalendarChangeCustomWorkingDays const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_CalendarChangeCustomWorkingDays &operator =(HPMChangeCallbackData_CalendarChangeCustomWorkingDays &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CalendarChangeCustomWorkingDays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CalendarChangeWorkingDays
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMChangeCallbackData_CalendarChangeWorkingDays()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CalendarChangeWorkingDays(HPMChangeCallbackData_CalendarChangeWorkingDays const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
	{
	}
	HPMChangeCallbackData_CalendarChangeWorkingDays(HPMChangeCallbackData_CalendarChangeWorkingDays &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
	{
	}
	HPMChangeCallbackData_CalendarChangeWorkingDays &operator =(HPMChangeCallbackData_CalendarChangeWorkingDays const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		return *this;
	}
	HPMChangeCallbackData_CalendarChangeWorkingDays &operator =(HPMChangeCallbackData_CalendarChangeWorkingDays &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CalendarChangeWorkingDays &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlAllCommandsFinished
{
	public:
	HPMChangeCallbackData_VersionControlAllCommandsFinished()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlAllCommandsFinished(HPMChangeCallbackData_VersionControlAllCommandsFinished const &_Right)
	{
	}
	HPMChangeCallbackData_VersionControlAllCommandsFinished(HPMChangeCallbackData_VersionControlAllCommandsFinished &&_Right)
	{
	}
	HPMChangeCallbackData_VersionControlAllCommandsFinished &operator =(HPMChangeCallbackData_VersionControlAllCommandsFinished const &_Right)
	{
		return *this;
	}
	HPMChangeCallbackData_VersionControlAllCommandsFinished &operator =(HPMChangeCallbackData_VersionControlAllCommandsFinished &&_Right)
	{
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlAllCommandsFinished &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlFileInfoChanged
{
	public:
	HPMChangeCallbackData_VersionControlFileInfoChanged()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlFileInfoChanged(HPMChangeCallbackData_VersionControlFileInfoChanged const &_Right)
	{
	}
	HPMChangeCallbackData_VersionControlFileInfoChanged(HPMChangeCallbackData_VersionControlFileInfoChanged &&_Right)
	{
	}
	HPMChangeCallbackData_VersionControlFileInfoChanged &operator =(HPMChangeCallbackData_VersionControlFileInfoChanged const &_Right)
	{
		return *this;
	}
	HPMChangeCallbackData_VersionControlFileInfoChanged &operator =(HPMChangeCallbackData_VersionControlFileInfoChanged &&_Right)
	{
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlFileInfoChanged &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlFileTreeAvailable
{
	public:
	HPMChangeCallbackData_VersionControlFileTreeAvailable()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlFileTreeAvailable(HPMChangeCallbackData_VersionControlFileTreeAvailable const &_Right)
	{
	}
	HPMChangeCallbackData_VersionControlFileTreeAvailable(HPMChangeCallbackData_VersionControlFileTreeAvailable &&_Right)
	{
	}
	HPMChangeCallbackData_VersionControlFileTreeAvailable &operator =(HPMChangeCallbackData_VersionControlFileTreeAvailable const &_Right)
	{
		return *this;
	}
	HPMChangeCallbackData_VersionControlFileTreeAvailable &operator =(HPMChangeCallbackData_VersionControlFileTreeAvailable &&_Right)
	{
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlFileTreeAvailable &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete
{
	public:
	std::vector<HPMString> m_FilesToDelete;
	std::vector<HPMString> m_FilesToOverwrite;
	HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete(HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete const &_Right)
		: m_FilesToDelete(_Right.m_FilesToDelete)
		, m_FilesToOverwrite(_Right.m_FilesToOverwrite)
	{
	}
	HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete(HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &&_Right)
		: m_FilesToDelete(std::move(_Right.m_FilesToDelete))
		, m_FilesToOverwrite(std::move(_Right.m_FilesToOverwrite))
	{
	}
	HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &operator =(HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete const &_Right)
	{
		m_FilesToDelete = _Right.m_FilesToDelete;
		m_FilesToOverwrite = _Right.m_FilesToOverwrite;
		return *this;
	}
	HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &operator =(HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &&_Right)
	{
		m_FilesToDelete = std::move(_Right.m_FilesToDelete);
		m_FilesToOverwrite = std::move(_Right.m_FilesToOverwrite);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		if (m_FilesToDelete.size() != _Right.m_FilesToDelete.size())
			return false;
		for (size_t i = 0; i < m_FilesToDelete.size(); ++i)
			if (m_FilesToDelete[i] != _Right.m_FilesToDelete[i])
				return false;
		if (m_FilesToOverwrite.size() != _Right.m_FilesToOverwrite.size())
			return false;
		for (size_t i = 0; i < m_FilesToOverwrite.size(); ++i)
			if (m_FilesToOverwrite[i] != _Right.m_FilesToOverwrite[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		if (m_FilesToDelete.size() < _Right.m_FilesToDelete.size())
			return true;
		if (m_FilesToDelete.size() > _Right.m_FilesToDelete.size())
			return false;
		for (size_t i = 0; i < m_FilesToDelete.size(); ++i)
		{
			if (m_FilesToDelete[i] < _Right.m_FilesToDelete[i])
				return true;
			if (m_FilesToDelete[i] > _Right.m_FilesToDelete[i])
				return false;
		}
		if (m_FilesToOverwrite.size() < _Right.m_FilesToOverwrite.size())
			return true;
		if (m_FilesToOverwrite.size() > _Right.m_FilesToOverwrite.size())
			return false;
		for (size_t i = 0; i < m_FilesToOverwrite.size(); ++i)
		{
			if (m_FilesToOverwrite[i] < _Right.m_FilesToOverwrite[i])
				return true;
			if (m_FilesToOverwrite[i] > _Right.m_FilesToOverwrite[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlWarnFileOverwriteDelete &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync
{
	public:
	std::vector<HPMString> m_FilesToDelete;
	std::vector<HPMString> m_FilesToOverwrite;
	HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync(HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync const &_Right)
		: m_FilesToDelete(_Right.m_FilesToDelete)
		, m_FilesToOverwrite(_Right.m_FilesToOverwrite)
	{
	}
	HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync(HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &&_Right)
		: m_FilesToDelete(std::move(_Right.m_FilesToDelete))
		, m_FilesToOverwrite(std::move(_Right.m_FilesToOverwrite))
	{
	}
	HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &operator =(HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync const &_Right)
	{
		m_FilesToDelete = _Right.m_FilesToDelete;
		m_FilesToOverwrite = _Right.m_FilesToOverwrite;
		return *this;
	}
	HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &operator =(HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &&_Right)
	{
		m_FilesToDelete = std::move(_Right.m_FilesToDelete);
		m_FilesToOverwrite = std::move(_Right.m_FilesToOverwrite);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		if (m_FilesToDelete.size() != _Right.m_FilesToDelete.size())
			return false;
		for (size_t i = 0; i < m_FilesToDelete.size(); ++i)
			if (m_FilesToDelete[i] != _Right.m_FilesToDelete[i])
				return false;
		if (m_FilesToOverwrite.size() != _Right.m_FilesToOverwrite.size())
			return false;
		for (size_t i = 0; i < m_FilesToOverwrite.size(); ++i)
			if (m_FilesToOverwrite[i] != _Right.m_FilesToOverwrite[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		if (m_FilesToDelete.size() < _Right.m_FilesToDelete.size())
			return true;
		if (m_FilesToDelete.size() > _Right.m_FilesToDelete.size())
			return false;
		for (size_t i = 0; i < m_FilesToDelete.size(); ++i)
		{
			if (m_FilesToDelete[i] < _Right.m_FilesToDelete[i])
				return true;
			if (m_FilesToDelete[i] > _Right.m_FilesToDelete[i])
				return false;
		}
		if (m_FilesToOverwrite.size() < _Right.m_FilesToOverwrite.size())
			return true;
		if (m_FilesToOverwrite.size() > _Right.m_FilesToOverwrite.size())
			return false;
		for (size_t i = 0; i < m_FilesToOverwrite.size(); ++i)
		{
			if (m_FilesToOverwrite[i] < _Right.m_FilesToOverwrite[i])
				return true;
			if (m_FilesToOverwrite[i] > _Right.m_FilesToOverwrite[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlWarnCheckOutShouldSync &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlErrorResponse
{
	public:
	HPMString m_File;
	HPMUInt64 m_FileID;
	EHPMVersionControlError m_Error;
	HPMUntranslatedString m_CustomError;
	HPMChangeCallbackData_VersionControlErrorResponse()
		: m_Error(EHPMVersionControlError_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlErrorResponse(HPMChangeCallbackData_VersionControlErrorResponse const &_Right)
		: m_File(_Right.m_File)
		, m_FileID(_Right.m_FileID)
		, m_Error(_Right.m_Error)
		, m_CustomError(_Right.m_CustomError)
	{
	}
	HPMChangeCallbackData_VersionControlErrorResponse(HPMChangeCallbackData_VersionControlErrorResponse &&_Right)
		: m_File(std::move(_Right.m_File))
		, m_FileID(std::move(_Right.m_FileID))
		, m_Error(std::move(_Right.m_Error))
		, m_CustomError(std::move(_Right.m_CustomError))
	{
	}
	HPMChangeCallbackData_VersionControlErrorResponse &operator =(HPMChangeCallbackData_VersionControlErrorResponse const &_Right)
	{
		m_File = _Right.m_File;
		m_FileID = _Right.m_FileID;
		m_Error = _Right.m_Error;
		m_CustomError = _Right.m_CustomError;
		return *this;
	}
	HPMChangeCallbackData_VersionControlErrorResponse &operator =(HPMChangeCallbackData_VersionControlErrorResponse &&_Right)
	{
		m_File = std::move(_Right.m_File);
		m_FileID = std::move(_Right.m_FileID);
		m_Error = std::move(_Right.m_Error);
		m_CustomError = std::move(_Right.m_CustomError);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		if (m_File != _Right.m_File)
			return false;
		if (m_FileID != _Right.m_FileID)
			return false;
		if (m_Error != _Right.m_Error)
			return false;
		if (m_CustomError != _Right.m_CustomError)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		if (m_File < _Right.m_File)
			return true;
		if (m_File > _Right.m_File)
			return false;
		if (m_FileID < _Right.m_FileID)
			return true;
		if (m_FileID > _Right.m_FileID)
			return false;
		if (m_Error < _Right.m_Error)
			return true;
		if (m_Error > _Right.m_Error)
			return false;
		if (m_CustomError < _Right.m_CustomError)
			return true;
		if (m_CustomError > _Right.m_CustomError)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlErrorResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlSyncFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_NotSyncedBecauseCheckedOut;
	std::vector<HPMString> m_LocalFiles;
	HPMChangeCallbackData_VersionControlSyncFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlSyncFilesResponse(HPMChangeCallbackData_VersionControlSyncFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_NotSyncedBecauseCheckedOut(_Right.m_NotSyncedBecauseCheckedOut)
		, m_LocalFiles(_Right.m_LocalFiles)
	{
	}
	HPMChangeCallbackData_VersionControlSyncFilesResponse(HPMChangeCallbackData_VersionControlSyncFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_NotSyncedBecauseCheckedOut(std::move(_Right.m_NotSyncedBecauseCheckedOut))
		, m_LocalFiles(std::move(_Right.m_LocalFiles))
	{
	}
	HPMChangeCallbackData_VersionControlSyncFilesResponse &operator =(HPMChangeCallbackData_VersionControlSyncFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_NotSyncedBecauseCheckedOut = _Right.m_NotSyncedBecauseCheckedOut;
		m_LocalFiles = _Right.m_LocalFiles;
		return *this;
	}
	HPMChangeCallbackData_VersionControlSyncFilesResponse &operator =(HPMChangeCallbackData_VersionControlSyncFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_NotSyncedBecauseCheckedOut = std::move(_Right.m_NotSyncedBecauseCheckedOut);
		m_LocalFiles = std::move(_Right.m_LocalFiles);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_NotSyncedBecauseCheckedOut.size() != _Right.m_NotSyncedBecauseCheckedOut.size())
			return false;
		for (size_t i = 0; i < m_NotSyncedBecauseCheckedOut.size(); ++i)
			if (m_NotSyncedBecauseCheckedOut[i] != _Right.m_NotSyncedBecauseCheckedOut[i])
				return false;
		if (m_LocalFiles.size() != _Right.m_LocalFiles.size())
			return false;
		for (size_t i = 0; i < m_LocalFiles.size(); ++i)
			if (m_LocalFiles[i] != _Right.m_LocalFiles[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_NotSyncedBecauseCheckedOut.size() < _Right.m_NotSyncedBecauseCheckedOut.size())
			return true;
		if (m_NotSyncedBecauseCheckedOut.size() > _Right.m_NotSyncedBecauseCheckedOut.size())
			return false;
		for (size_t i = 0; i < m_NotSyncedBecauseCheckedOut.size(); ++i)
		{
			if (m_NotSyncedBecauseCheckedOut[i] < _Right.m_NotSyncedBecauseCheckedOut[i])
				return true;
			if (m_NotSyncedBecauseCheckedOut[i] > _Right.m_NotSyncedBecauseCheckedOut[i])
				return false;
		}
		if (m_LocalFiles.size() < _Right.m_LocalFiles.size())
			return true;
		if (m_LocalFiles.size() > _Right.m_LocalFiles.size())
			return false;
		for (size_t i = 0; i < m_LocalFiles.size(); ++i)
		{
			if (m_LocalFiles[i] < _Right.m_LocalFiles[i])
				return true;
			if (m_LocalFiles[i] > _Right.m_LocalFiles[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlSyncFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlAddFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_AlreadyExists;
	std::vector<HPMUInt8> m_ExtraData;
	HPMChangeCallbackData_VersionControlAddFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlAddFilesResponse(HPMChangeCallbackData_VersionControlAddFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
		, m_AlreadyExists(_Right.m_AlreadyExists)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMChangeCallbackData_VersionControlAddFilesResponse(HPMChangeCallbackData_VersionControlAddFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
		, m_AlreadyExists(std::move(_Right.m_AlreadyExists))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMChangeCallbackData_VersionControlAddFilesResponse &operator =(HPMChangeCallbackData_VersionControlAddFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		m_AlreadyExists = _Right.m_AlreadyExists;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMChangeCallbackData_VersionControlAddFilesResponse &operator =(HPMChangeCallbackData_VersionControlAddFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		m_AlreadyExists = std::move(_Right.m_AlreadyExists);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		if (m_AlreadyExists.size() != _Right.m_AlreadyExists.size())
			return false;
		for (size_t i = 0; i < m_AlreadyExists.size(); ++i)
			if (m_AlreadyExists[i] != _Right.m_AlreadyExists[i])
				return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		if (m_AlreadyExists.size() < _Right.m_AlreadyExists.size())
			return true;
		if (m_AlreadyExists.size() > _Right.m_AlreadyExists.size())
			return false;
		for (size_t i = 0; i < m_AlreadyExists.size(); ++i)
		{
			if (m_AlreadyExists[i] < _Right.m_AlreadyExists[i])
				return true;
			if (m_AlreadyExists[i] > _Right.m_AlreadyExists[i])
				return false;
		}
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlAddFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_DeleteErrors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_DeleteSucceeded;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_AlreadyExists;
	std::vector<HPMUInt8> m_ExtraData;
	HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse(HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse const &_Right)
		: m_DeleteErrors(_Right.m_DeleteErrors)
		, m_DeleteSucceeded(_Right.m_DeleteSucceeded)
		, m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
		, m_AlreadyExists(_Right.m_AlreadyExists)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse(HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &&_Right)
		: m_DeleteErrors(std::move(_Right.m_DeleteErrors))
		, m_DeleteSucceeded(std::move(_Right.m_DeleteSucceeded))
		, m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
		, m_AlreadyExists(std::move(_Right.m_AlreadyExists))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &operator =(HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse const &_Right)
	{
		m_DeleteErrors = _Right.m_DeleteErrors;
		m_DeleteSucceeded = _Right.m_DeleteSucceeded;
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		m_AlreadyExists = _Right.m_AlreadyExists;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &operator =(HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &&_Right)
	{
		m_DeleteErrors = std::move(_Right.m_DeleteErrors);
		m_DeleteSucceeded = std::move(_Right.m_DeleteSucceeded);
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		m_AlreadyExists = std::move(_Right.m_AlreadyExists);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		if (m_DeleteErrors.size() != _Right.m_DeleteErrors.size())
			return false;
		for (size_t i = 0; i < m_DeleteErrors.size(); ++i)
			if (m_DeleteErrors[i] != _Right.m_DeleteErrors[i])
				return false;
		if (m_DeleteSucceeded.size() != _Right.m_DeleteSucceeded.size())
			return false;
		for (size_t i = 0; i < m_DeleteSucceeded.size(); ++i)
			if (m_DeleteSucceeded[i] != _Right.m_DeleteSucceeded[i])
				return false;
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		if (m_AlreadyExists.size() != _Right.m_AlreadyExists.size())
			return false;
		for (size_t i = 0; i < m_AlreadyExists.size(); ++i)
			if (m_AlreadyExists[i] != _Right.m_AlreadyExists[i])
				return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		if (m_DeleteErrors.size() < _Right.m_DeleteErrors.size())
			return true;
		if (m_DeleteErrors.size() > _Right.m_DeleteErrors.size())
			return false;
		for (size_t i = 0; i < m_DeleteErrors.size(); ++i)
		{
			if (m_DeleteErrors[i] < _Right.m_DeleteErrors[i])
				return true;
			if (m_DeleteErrors[i] > _Right.m_DeleteErrors[i])
				return false;
		}
		if (m_DeleteSucceeded.size() < _Right.m_DeleteSucceeded.size())
			return true;
		if (m_DeleteSucceeded.size() > _Right.m_DeleteSucceeded.size())
			return false;
		for (size_t i = 0; i < m_DeleteSucceeded.size(); ++i)
		{
			if (m_DeleteSucceeded[i] < _Right.m_DeleteSucceeded[i])
				return true;
			if (m_DeleteSucceeded[i] > _Right.m_DeleteSucceeded[i])
				return false;
		}
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		if (m_AlreadyExists.size() < _Right.m_AlreadyExists.size())
			return true;
		if (m_AlreadyExists.size() > _Right.m_AlreadyExists.size())
			return false;
		for (size_t i = 0; i < m_AlreadyExists.size(); ++i)
		{
			if (m_AlreadyExists[i] < _Right.m_AlreadyExists[i])
				return true;
			if (m_AlreadyExists[i] > _Right.m_AlreadyExists[i])
				return false;
		}
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlUploadAvatarFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlCheckInFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMUInt32 m_nSkippedFiles;
	bool m_bForceReverted;
	std::vector<HPMUInt8> m_ExtraData;
	HPMChangeCallbackData_VersionControlCheckInFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlCheckInFilesResponse(HPMChangeCallbackData_VersionControlCheckInFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
		, m_nSkippedFiles(_Right.m_nSkippedFiles)
		, m_bForceReverted(_Right.m_bForceReverted)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMChangeCallbackData_VersionControlCheckInFilesResponse(HPMChangeCallbackData_VersionControlCheckInFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
		, m_nSkippedFiles(std::move(_Right.m_nSkippedFiles))
		, m_bForceReverted(std::move(_Right.m_bForceReverted))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMChangeCallbackData_VersionControlCheckInFilesResponse &operator =(HPMChangeCallbackData_VersionControlCheckInFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		m_nSkippedFiles = _Right.m_nSkippedFiles;
		m_bForceReverted = _Right.m_bForceReverted;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMChangeCallbackData_VersionControlCheckInFilesResponse &operator =(HPMChangeCallbackData_VersionControlCheckInFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		m_nSkippedFiles = std::move(_Right.m_nSkippedFiles);
		m_bForceReverted = std::move(_Right.m_bForceReverted);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		if (m_nSkippedFiles != _Right.m_nSkippedFiles)
			return false;
		if (m_bForceReverted != _Right.m_bForceReverted)
			return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		if (m_nSkippedFiles < _Right.m_nSkippedFiles)
			return true;
		if (m_nSkippedFiles > _Right.m_nSkippedFiles)
			return false;
		if (m_bForceReverted < _Right.m_bForceReverted)
			return true;
		if (m_bForceReverted > _Right.m_bForceReverted)
			return false;
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlCheckInFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlCheckOutFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_AlreadyCheckedOut;
	HPMChangeCallbackData_VersionControlCheckOutFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlCheckOutFilesResponse(HPMChangeCallbackData_VersionControlCheckOutFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
		, m_AlreadyCheckedOut(_Right.m_AlreadyCheckedOut)
	{
	}
	HPMChangeCallbackData_VersionControlCheckOutFilesResponse(HPMChangeCallbackData_VersionControlCheckOutFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
		, m_AlreadyCheckedOut(std::move(_Right.m_AlreadyCheckedOut))
	{
	}
	HPMChangeCallbackData_VersionControlCheckOutFilesResponse &operator =(HPMChangeCallbackData_VersionControlCheckOutFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		m_AlreadyCheckedOut = _Right.m_AlreadyCheckedOut;
		return *this;
	}
	HPMChangeCallbackData_VersionControlCheckOutFilesResponse &operator =(HPMChangeCallbackData_VersionControlCheckOutFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		m_AlreadyCheckedOut = std::move(_Right.m_AlreadyCheckedOut);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		if (m_AlreadyCheckedOut.size() != _Right.m_AlreadyCheckedOut.size())
			return false;
		for (size_t i = 0; i < m_AlreadyCheckedOut.size(); ++i)
			if (m_AlreadyCheckedOut[i] != _Right.m_AlreadyCheckedOut[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		if (m_AlreadyCheckedOut.size() < _Right.m_AlreadyCheckedOut.size())
			return true;
		if (m_AlreadyCheckedOut.size() > _Right.m_AlreadyCheckedOut.size())
			return false;
		for (size_t i = 0; i < m_AlreadyCheckedOut.size(); ++i)
		{
			if (m_AlreadyCheckedOut[i] < _Right.m_AlreadyCheckedOut[i])
				return true;
			if (m_AlreadyCheckedOut[i] > _Right.m_AlreadyCheckedOut[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlCheckOutFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlRenameResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlRenameResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlRenameResponse(HPMChangeCallbackData_VersionControlRenameResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlRenameResponse(HPMChangeCallbackData_VersionControlRenameResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlRenameResponse &operator =(HPMChangeCallbackData_VersionControlRenameResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlRenameResponse &operator =(HPMChangeCallbackData_VersionControlRenameResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlRenameResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlDeleteFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlDeleteFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlDeleteFilesResponse(HPMChangeCallbackData_VersionControlDeleteFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlDeleteFilesResponse(HPMChangeCallbackData_VersionControlDeleteFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlDeleteFilesResponse &operator =(HPMChangeCallbackData_VersionControlDeleteFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlDeleteFilesResponse &operator =(HPMChangeCallbackData_VersionControlDeleteFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlDeleteFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse(HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse(HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &operator =(HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &operator =(HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlRestoreDeletedFilesResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlSetAccessRightsResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlSetAccessRightsResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlSetAccessRightsResponse(HPMChangeCallbackData_VersionControlSetAccessRightsResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlSetAccessRightsResponse(HPMChangeCallbackData_VersionControlSetAccessRightsResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlSetAccessRightsResponse &operator =(HPMChangeCallbackData_VersionControlSetAccessRightsResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlSetAccessRightsResponse &operator =(HPMChangeCallbackData_VersionControlSetAccessRightsResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlSetAccessRightsResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlRollbackFileResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlRollbackFileResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlRollbackFileResponse(HPMChangeCallbackData_VersionControlRollbackFileResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlRollbackFileResponse(HPMChangeCallbackData_VersionControlRollbackFileResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlRollbackFileResponse &operator =(HPMChangeCallbackData_VersionControlRollbackFileResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlRollbackFileResponse &operator =(HPMChangeCallbackData_VersionControlRollbackFileResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlRollbackFileResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlDeleteVersionsResponse
{
	public:
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Errors;
	std::vector<HPMChangeCallbackData_VersionControlErrorResponse> m_Succeeded;
	HPMChangeCallbackData_VersionControlDeleteVersionsResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlDeleteVersionsResponse(HPMChangeCallbackData_VersionControlDeleteVersionsResponse const &_Right)
		: m_Errors(_Right.m_Errors)
		, m_Succeeded(_Right.m_Succeeded)
	{
	}
	HPMChangeCallbackData_VersionControlDeleteVersionsResponse(HPMChangeCallbackData_VersionControlDeleteVersionsResponse &&_Right)
		: m_Errors(std::move(_Right.m_Errors))
		, m_Succeeded(std::move(_Right.m_Succeeded))
	{
	}
	HPMChangeCallbackData_VersionControlDeleteVersionsResponse &operator =(HPMChangeCallbackData_VersionControlDeleteVersionsResponse const &_Right)
	{
		m_Errors = _Right.m_Errors;
		m_Succeeded = _Right.m_Succeeded;
		return *this;
	}
	HPMChangeCallbackData_VersionControlDeleteVersionsResponse &operator =(HPMChangeCallbackData_VersionControlDeleteVersionsResponse &&_Right)
	{
		m_Errors = std::move(_Right.m_Errors);
		m_Succeeded = std::move(_Right.m_Succeeded);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		if (m_Errors.size() != _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
			if (m_Errors[i] != _Right.m_Errors[i])
				return false;
		if (m_Succeeded.size() != _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
			if (m_Succeeded[i] != _Right.m_Succeeded[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		if (m_Errors.size() < _Right.m_Errors.size())
			return true;
		if (m_Errors.size() > _Right.m_Errors.size())
			return false;
		for (size_t i = 0; i < m_Errors.size(); ++i)
		{
			if (m_Errors[i] < _Right.m_Errors[i])
				return true;
			if (m_Errors[i] > _Right.m_Errors[i])
				return false;
		}
		if (m_Succeeded.size() < _Right.m_Succeeded.size())
			return true;
		if (m_Succeeded.size() > _Right.m_Succeeded.size())
			return false;
		for (size_t i = 0; i < m_Succeeded.size(); ++i)
		{
			if (m_Succeeded[i] < _Right.m_Succeeded[i])
				return true;
			if (m_Succeeded[i] > _Right.m_Succeeded[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlDeleteVersionsResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlGetAccessRightsResponse
{
	public:
	HPMString m_File;
	bool m_bAccessDenied;
	HPMChangeCallbackData_VersionControlGetAccessRightsResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlGetAccessRightsResponse(HPMChangeCallbackData_VersionControlGetAccessRightsResponse const &_Right)
		: m_File(_Right.m_File)
		, m_bAccessDenied(_Right.m_bAccessDenied)
	{
	}
	HPMChangeCallbackData_VersionControlGetAccessRightsResponse(HPMChangeCallbackData_VersionControlGetAccessRightsResponse &&_Right)
		: m_File(std::move(_Right.m_File))
		, m_bAccessDenied(std::move(_Right.m_bAccessDenied))
	{
	}
	HPMChangeCallbackData_VersionControlGetAccessRightsResponse &operator =(HPMChangeCallbackData_VersionControlGetAccessRightsResponse const &_Right)
	{
		m_File = _Right.m_File;
		m_bAccessDenied = _Right.m_bAccessDenied;
		return *this;
	}
	HPMChangeCallbackData_VersionControlGetAccessRightsResponse &operator =(HPMChangeCallbackData_VersionControlGetAccessRightsResponse &&_Right)
	{
		m_File = std::move(_Right.m_File);
		m_bAccessDenied = std::move(_Right.m_bAccessDenied);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		if (m_File != _Right.m_File)
			return false;
		if (m_bAccessDenied != _Right.m_bAccessDenied)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		if (m_File < _Right.m_File)
			return true;
		if (m_File > _Right.m_File)
			return false;
		if (m_bAccessDenied < _Right.m_bAccessDenied)
			return true;
		if (m_bAccessDenied > _Right.m_bAccessDenied)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlGetAccessRightsResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_VersionControlGetFileHistoryResponse
{
	public:
	HPMString m_File;
	bool m_bAccessDenied;
	HPMChangeCallbackData_VersionControlGetFileHistoryResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_VersionControlGetFileHistoryResponse(HPMChangeCallbackData_VersionControlGetFileHistoryResponse const &_Right)
		: m_File(_Right.m_File)
		, m_bAccessDenied(_Right.m_bAccessDenied)
	{
	}
	HPMChangeCallbackData_VersionControlGetFileHistoryResponse(HPMChangeCallbackData_VersionControlGetFileHistoryResponse &&_Right)
		: m_File(std::move(_Right.m_File))
		, m_bAccessDenied(std::move(_Right.m_bAccessDenied))
	{
	}
	HPMChangeCallbackData_VersionControlGetFileHistoryResponse &operator =(HPMChangeCallbackData_VersionControlGetFileHistoryResponse const &_Right)
	{
		m_File = _Right.m_File;
		m_bAccessDenied = _Right.m_bAccessDenied;
		return *this;
	}
	HPMChangeCallbackData_VersionControlGetFileHistoryResponse &operator =(HPMChangeCallbackData_VersionControlGetFileHistoryResponse &&_Right)
	{
		m_File = std::move(_Right.m_File);
		m_bAccessDenied = std::move(_Right.m_bAccessDenied);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		if (m_File != _Right.m_File)
			return false;
		if (m_bAccessDenied != _Right.m_bAccessDenied)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		if (m_File < _Right.m_File)
			return true;
		if (m_File > _Right.m_File)
			return false;
		if (m_bAccessDenied < _Right.m_bAccessDenied)
			return true;
		if (m_bAccessDenied > _Right.m_bAccessDenied)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_VersionControlGetFileHistoryResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalCustomSettingsChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_GlobalCustomSettingsChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalCustomSettingsChange(HPMChangeCallbackData_GlobalCustomSettingsChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsChange(HPMChangeCallbackData_GlobalCustomSettingsChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsChange &operator =(HPMChangeCallbackData_GlobalCustomSettingsChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_GlobalCustomSettingsChange &operator =(HPMChangeCallbackData_GlobalCustomSettingsChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalCustomSettingsChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalCustomSettingsUnregister
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_GlobalCustomSettingsUnregister()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalCustomSettingsUnregister(HPMChangeCallbackData_GlobalCustomSettingsUnregister const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsUnregister(HPMChangeCallbackData_GlobalCustomSettingsUnregister &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsUnregister &operator =(HPMChangeCallbackData_GlobalCustomSettingsUnregister const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_GlobalCustomSettingsUnregister &operator =(HPMChangeCallbackData_GlobalCustomSettingsUnregister &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalCustomSettingsUnregister &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalCustomSettingsValueChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	EHPMCustomSettingsType m_SettingsType;
	HPMUInt32 m_IdentifierHash;
	HPMString m_SettingsPath;
	HPMChangeCallbackData_GlobalCustomSettingsValueChange()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalCustomSettingsValueChange(HPMChangeCallbackData_GlobalCustomSettingsValueChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_IdentifierHash(_Right.m_IdentifierHash)
		, m_SettingsPath(_Right.m_SettingsPath)
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsValueChange(HPMChangeCallbackData_GlobalCustomSettingsValueChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
		, m_SettingsPath(std::move(_Right.m_SettingsPath))
	{
	}
	HPMChangeCallbackData_GlobalCustomSettingsValueChange &operator =(HPMChangeCallbackData_GlobalCustomSettingsValueChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_IdentifierHash = _Right.m_IdentifierHash;
		m_SettingsPath = _Right.m_SettingsPath;
		return *this;
	}
	HPMChangeCallbackData_GlobalCustomSettingsValueChange &operator =(HPMChangeCallbackData_GlobalCustomSettingsValueChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		m_SettingsPath = std::move(_Right.m_SettingsPath);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath != _Right.m_SettingsPath)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath < _Right.m_SettingsPath)
			return true;
		if (m_SettingsPath > _Right.m_SettingsPath)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalCustomSettingsValueChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectCustomSettingsValueChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	EHPMCustomSettingsType m_SettingsType;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_IdentifierHash;
	HPMString m_SettingsPath;
	HPMChangeCallbackData_ProjectCustomSettingsValueChange()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectCustomSettingsValueChange(HPMChangeCallbackData_ProjectCustomSettingsValueChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_ProjectID(_Right.m_ProjectID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
		, m_SettingsPath(_Right.m_SettingsPath)
	{
	}
	HPMChangeCallbackData_ProjectCustomSettingsValueChange(HPMChangeCallbackData_ProjectCustomSettingsValueChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
		, m_SettingsPath(std::move(_Right.m_SettingsPath))
	{
	}
	HPMChangeCallbackData_ProjectCustomSettingsValueChange &operator =(HPMChangeCallbackData_ProjectCustomSettingsValueChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_ProjectID = _Right.m_ProjectID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		m_SettingsPath = _Right.m_SettingsPath;
		return *this;
	}
	HPMChangeCallbackData_ProjectCustomSettingsValueChange &operator =(HPMChangeCallbackData_ProjectCustomSettingsValueChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		m_SettingsPath = std::move(_Right.m_SettingsPath);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath != _Right.m_SettingsPath)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath < _Right.m_SettingsPath)
			return true;
		if (m_SettingsPath > _Right.m_SettingsPath)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectCustomSettingsValueChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	EHPMCustomSettingsType m_SettingsType;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMString m_SettingsPath;
	HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange(HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
		, m_SettingsPath(_Right.m_SettingsPath)
	{
	}
	HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange(HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
		, m_SettingsPath(std::move(_Right.m_SettingsPath))
	{
	}
	HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &operator =(HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		m_SettingsPath = _Right.m_SettingsPath;
		return *this;
	}
	HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &operator =(HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		m_SettingsPath = std::move(_Right.m_SettingsPath);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath != _Right.m_SettingsPath)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath < _Right.m_SettingsPath)
			return true;
		if (m_SettingsPath > _Right.m_SettingsPath)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectResourceCustomSettingsValueChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceCustomSettingsValueChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	EHPMCustomSettingsType m_SettingsType;
	HPMUniqueID m_ResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMString m_SettingsPath;
	HPMChangeCallbackData_ResourceCustomSettingsValueChange()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceCustomSettingsValueChange(HPMChangeCallbackData_ResourceCustomSettingsValueChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_ResourceID(_Right.m_ResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
		, m_SettingsPath(_Right.m_SettingsPath)
	{
	}
	HPMChangeCallbackData_ResourceCustomSettingsValueChange(HPMChangeCallbackData_ResourceCustomSettingsValueChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
		, m_SettingsPath(std::move(_Right.m_SettingsPath))
	{
	}
	HPMChangeCallbackData_ResourceCustomSettingsValueChange &operator =(HPMChangeCallbackData_ResourceCustomSettingsValueChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_ResourceID = _Right.m_ResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		m_SettingsPath = _Right.m_SettingsPath;
		return *this;
	}
	HPMChangeCallbackData_ResourceCustomSettingsValueChange &operator =(HPMChangeCallbackData_ResourceCustomSettingsValueChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		m_SettingsPath = std::move(_Right.m_SettingsPath);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath != _Right.m_SettingsPath)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		if (m_SettingsPath < _Right.m_SettingsPath)
			return true;
		if (m_SettingsPath > _Right.m_SettingsPath)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceCustomSettingsValueChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_GlobalSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_GlobalSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_GlobalSDKInternalDataChange(HPMChangeCallbackData_GlobalSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_GlobalSDKInternalDataChange(HPMChangeCallbackData_GlobalSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_GlobalSDKInternalDataChange &operator =(HPMChangeCallbackData_GlobalSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_GlobalSDKInternalDataChange &operator =(HPMChangeCallbackData_GlobalSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_GlobalSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_ProjectSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectSDKInternalDataChange(HPMChangeCallbackData_ProjectSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_ProjectSDKInternalDataChange(HPMChangeCallbackData_ProjectSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_ProjectSDKInternalDataChange &operator =(HPMChangeCallbackData_ProjectSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_ProjectSDKInternalDataChange &operator =(HPMChangeCallbackData_ProjectSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ProjectResourceSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_ProjectResourceSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ProjectResourceSDKInternalDataChange(HPMChangeCallbackData_ProjectResourceSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_ProjectResourceSDKInternalDataChange(HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &operator =(HPMChangeCallbackData_ProjectResourceSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &operator =(HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ProjectResourceSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ResourceSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_ResourceID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_ResourceSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ResourceSDKInternalDataChange(HPMChangeCallbackData_ResourceSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_ResourceSDKInternalDataChange(HPMChangeCallbackData_ResourceSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_ResourceSDKInternalDataChange &operator =(HPMChangeCallbackData_ResourceSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_ResourceID = _Right.m_ResourceID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_ResourceSDKInternalDataChange &operator =(HPMChangeCallbackData_ResourceSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ResourceSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_TaskSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskSDKInternalDataChange(HPMChangeCallbackData_TaskSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskID(_Right.m_TaskID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_TaskSDKInternalDataChange(HPMChangeCallbackData_TaskSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskID(std::move(_Right.m_TaskID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_TaskSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskID = _Right.m_TaskID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_TaskSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskID = std::move(_Right.m_TaskID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID != _Right.m_TaskID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskID < _Right.m_TaskID)
			return true;
		if (m_TaskID > _Right.m_TaskID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_TaskRefSDKInternalDataChange
{
	public:
	bool m_bChangeInitiatedFromThisSession;
	HPMUniqueID m_ChangedByResourceID;
	HPMUniqueID m_ChangedByImpersonatedResourceID;
	HPMUniqueID m_TaskRefID;
	HPMUInt32 m_IdentifierHash;
	HPMChangeCallbackData_TaskRefSDKInternalDataChange()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_TaskRefSDKInternalDataChange(HPMChangeCallbackData_TaskRefSDKInternalDataChange const &_Right)
		: m_bChangeInitiatedFromThisSession(_Right.m_bChangeInitiatedFromThisSession)
		, m_ChangedByResourceID(_Right.m_ChangedByResourceID)
		, m_ChangedByImpersonatedResourceID(_Right.m_ChangedByImpersonatedResourceID)
		, m_TaskRefID(_Right.m_TaskRefID)
		, m_IdentifierHash(_Right.m_IdentifierHash)
	{
	}
	HPMChangeCallbackData_TaskRefSDKInternalDataChange(HPMChangeCallbackData_TaskRefSDKInternalDataChange &&_Right)
		: m_bChangeInitiatedFromThisSession(std::move(_Right.m_bChangeInitiatedFromThisSession))
		, m_ChangedByResourceID(std::move(_Right.m_ChangedByResourceID))
		, m_ChangedByImpersonatedResourceID(std::move(_Right.m_ChangedByImpersonatedResourceID))
		, m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_IdentifierHash(std::move(_Right.m_IdentifierHash))
	{
	}
	HPMChangeCallbackData_TaskRefSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskRefSDKInternalDataChange const &_Right)
	{
		m_bChangeInitiatedFromThisSession = _Right.m_bChangeInitiatedFromThisSession;
		m_ChangedByResourceID = _Right.m_ChangedByResourceID;
		m_ChangedByImpersonatedResourceID = _Right.m_ChangedByImpersonatedResourceID;
		m_TaskRefID = _Right.m_TaskRefID;
		m_IdentifierHash = _Right.m_IdentifierHash;
		return *this;
	}
	HPMChangeCallbackData_TaskRefSDKInternalDataChange &operator =(HPMChangeCallbackData_TaskRefSDKInternalDataChange &&_Right)
	{
		m_bChangeInitiatedFromThisSession = std::move(_Right.m_bChangeInitiatedFromThisSession);
		m_ChangedByResourceID = std::move(_Right.m_ChangedByResourceID);
		m_ChangedByImpersonatedResourceID = std::move(_Right.m_ChangedByImpersonatedResourceID);
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_IdentifierHash = std::move(_Right.m_IdentifierHash);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession != _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID != _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID != _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_IdentifierHash != _Right.m_IdentifierHash)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		if (m_bChangeInitiatedFromThisSession < _Right.m_bChangeInitiatedFromThisSession)
			return true;
		if (m_bChangeInitiatedFromThisSession > _Right.m_bChangeInitiatedFromThisSession)
			return false;
		if (m_ChangedByResourceID < _Right.m_ChangedByResourceID)
			return true;
		if (m_ChangedByResourceID > _Right.m_ChangedByResourceID)
			return false;
		if (m_ChangedByImpersonatedResourceID < _Right.m_ChangedByImpersonatedResourceID)
			return true;
		if (m_ChangedByImpersonatedResourceID > _Right.m_ChangedByImpersonatedResourceID)
			return false;
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_IdentifierHash < _Right.m_IdentifierHash)
			return true;
		if (m_IdentifierHash > _Right.m_IdentifierHash)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_TaskRefSDKInternalDataChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ClientExecuteURL
{
	public:
	HPMString m_URL;
	HPMChangeCallbackData_ClientExecuteURL()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ClientExecuteURL(HPMChangeCallbackData_ClientExecuteURL const &_Right)
		: m_URL(_Right.m_URL)
	{
	}
	HPMChangeCallbackData_ClientExecuteURL(HPMChangeCallbackData_ClientExecuteURL &&_Right)
		: m_URL(std::move(_Right.m_URL))
	{
	}
	HPMChangeCallbackData_ClientExecuteURL &operator =(HPMChangeCallbackData_ClientExecuteURL const &_Right)
	{
		m_URL = _Right.m_URL;
		return *this;
	}
	HPMChangeCallbackData_ClientExecuteURL &operator =(HPMChangeCallbackData_ClientExecuteURL &&_Right)
	{
		m_URL = std::move(_Right.m_URL);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		if (m_URL != _Right.m_URL)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		if (m_URL < _Right.m_URL)
			return true;
		if (m_URL > _Right.m_URL)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ClientExecuteURL &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_DynamicCustomSettingsValueChanged
{
	public:
	HPMDynamicCustomSettingsContext m_DynamicContext;
	HPMUserContext m_UserContext;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	EHPMCustomSettingsType m_SettingsType;
	bool m_bTemporary;
	HPMString m_Path;
	HPMString m_Value;
	HPMChangeCallbackData_DynamicCustomSettingsValueChanged()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_DynamicCustomSettingsValueChanged(HPMChangeCallbackData_DynamicCustomSettingsValueChanged const &_Right)
		: m_DynamicContext(_Right.m_DynamicContext)
		, m_UserContext(_Right.m_UserContext)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_bTemporary(_Right.m_bTemporary)
		, m_Path(_Right.m_Path)
		, m_Value(_Right.m_Value)
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsValueChanged(HPMChangeCallbackData_DynamicCustomSettingsValueChanged &&_Right)
		: m_DynamicContext(std::move(_Right.m_DynamicContext))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_bTemporary(std::move(_Right.m_bTemporary))
		, m_Path(std::move(_Right.m_Path))
		, m_Value(std::move(_Right.m_Value))
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsValueChanged &operator =(HPMChangeCallbackData_DynamicCustomSettingsValueChanged const &_Right)
	{
		m_DynamicContext = _Right.m_DynamicContext;
		m_UserContext = _Right.m_UserContext;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_bTemporary = _Right.m_bTemporary;
		m_Path = _Right.m_Path;
		m_Value = _Right.m_Value;
		return *this;
	}
	HPMChangeCallbackData_DynamicCustomSettingsValueChanged &operator =(HPMChangeCallbackData_DynamicCustomSettingsValueChanged &&_Right)
	{
		m_DynamicContext = std::move(_Right.m_DynamicContext);
		m_UserContext = std::move(_Right.m_UserContext);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_bTemporary = std::move(_Right.m_bTemporary);
		m_Path = std::move(_Right.m_Path);
		m_Value = std::move(_Right.m_Value);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		if (m_DynamicContext != _Right.m_DynamicContext)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_bTemporary != _Right.m_bTemporary)
			return false;
		if (m_Path != _Right.m_Path)
			return false;
		if (m_Value != _Right.m_Value)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		if (m_DynamicContext < _Right.m_DynamicContext)
			return true;
		if (m_DynamicContext > _Right.m_DynamicContext)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_bTemporary < _Right.m_bTemporary)
			return true;
		if (m_bTemporary > _Right.m_bTemporary)
			return false;
		if (m_Path < _Right.m_Path)
			return true;
		if (m_Path > _Right.m_Path)
			return false;
		if (m_Value < _Right.m_Value)
			return true;
		if (m_Value > _Right.m_Value)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_DynamicCustomSettingsValueChanged &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse
{
	public:
	HPMDynamicCustomSettingsContext m_DynamicContext;
	HPMUserContext m_UserContext;
	HPMDynamicCustomSettingsValues m_Values;
	HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse(HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse const &_Right)
		: m_DynamicContext(_Right.m_DynamicContext)
		, m_UserContext(_Right.m_UserContext)
		, m_Values(_Right.m_Values)
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse(HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &&_Right)
		: m_DynamicContext(std::move(_Right.m_DynamicContext))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_Values(std::move(_Right.m_Values))
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &operator =(HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse const &_Right)
	{
		m_DynamicContext = _Right.m_DynamicContext;
		m_UserContext = _Right.m_UserContext;
		m_Values = _Right.m_Values;
		return *this;
	}
	HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &operator =(HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &&_Right)
	{
		m_DynamicContext = std::move(_Right.m_DynamicContext);
		m_UserContext = std::move(_Right.m_UserContext);
		m_Values = std::move(_Right.m_Values);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		if (m_DynamicContext != _Right.m_DynamicContext)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_Values != _Right.m_Values)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		if (m_DynamicContext < _Right.m_DynamicContext)
			return true;
		if (m_DynamicContext > _Right.m_DynamicContext)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_Values < _Right.m_Values)
			return true;
		if (m_Values > _Right.m_Values)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_DynamicCustomSettingsValuesRequestResponse &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_DynamicCustomSettingsNotification
{
	public:
	HPMDynamicCustomSettingsContext m_DynamicContext;
	HPMUserContext m_UserContext;
	HPMUniqueID m_ProjectID;
	HPMUniqueID m_ResourceID;
	EHPMCustomSettingsType m_SettingsType;
	EHPMDynamicCustomSettingsNotification m_Notification;
	HPMInt32 m_CustomNotification;
	std::vector<HPMString> m_TabIdentifiers;
	HPMChangeCallbackData_DynamicCustomSettingsNotification()
		: m_SettingsType(EHPMCustomSettingsType_NewVersionOfSDKRequired)
		, m_Notification(EHPMDynamicCustomSettingsNotification_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_DynamicCustomSettingsNotification(HPMChangeCallbackData_DynamicCustomSettingsNotification const &_Right)
		: m_DynamicContext(_Right.m_DynamicContext)
		, m_UserContext(_Right.m_UserContext)
		, m_ProjectID(_Right.m_ProjectID)
		, m_ResourceID(_Right.m_ResourceID)
		, m_SettingsType(_Right.m_SettingsType)
		, m_Notification(_Right.m_Notification)
		, m_CustomNotification(_Right.m_CustomNotification)
		, m_TabIdentifiers(_Right.m_TabIdentifiers)
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsNotification(HPMChangeCallbackData_DynamicCustomSettingsNotification &&_Right)
		: m_DynamicContext(std::move(_Right.m_DynamicContext))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_SettingsType(std::move(_Right.m_SettingsType))
		, m_Notification(std::move(_Right.m_Notification))
		, m_CustomNotification(std::move(_Right.m_CustomNotification))
		, m_TabIdentifiers(std::move(_Right.m_TabIdentifiers))
	{
	}
	HPMChangeCallbackData_DynamicCustomSettingsNotification &operator =(HPMChangeCallbackData_DynamicCustomSettingsNotification const &_Right)
	{
		m_DynamicContext = _Right.m_DynamicContext;
		m_UserContext = _Right.m_UserContext;
		m_ProjectID = _Right.m_ProjectID;
		m_ResourceID = _Right.m_ResourceID;
		m_SettingsType = _Right.m_SettingsType;
		m_Notification = _Right.m_Notification;
		m_CustomNotification = _Right.m_CustomNotification;
		m_TabIdentifiers = _Right.m_TabIdentifiers;
		return *this;
	}
	HPMChangeCallbackData_DynamicCustomSettingsNotification &operator =(HPMChangeCallbackData_DynamicCustomSettingsNotification &&_Right)
	{
		m_DynamicContext = std::move(_Right.m_DynamicContext);
		m_UserContext = std::move(_Right.m_UserContext);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_SettingsType = std::move(_Right.m_SettingsType);
		m_Notification = std::move(_Right.m_Notification);
		m_CustomNotification = std::move(_Right.m_CustomNotification);
		m_TabIdentifiers = std::move(_Right.m_TabIdentifiers);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		if (m_DynamicContext != _Right.m_DynamicContext)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_SettingsType != _Right.m_SettingsType)
			return false;
		if (m_Notification != _Right.m_Notification)
			return false;
		if (m_CustomNotification != _Right.m_CustomNotification)
			return false;
		if (m_TabIdentifiers.size() != _Right.m_TabIdentifiers.size())
			return false;
		for (size_t i = 0; i < m_TabIdentifiers.size(); ++i)
			if (m_TabIdentifiers[i] != _Right.m_TabIdentifiers[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		if (m_DynamicContext < _Right.m_DynamicContext)
			return true;
		if (m_DynamicContext > _Right.m_DynamicContext)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_SettingsType < _Right.m_SettingsType)
			return true;
		if (m_SettingsType > _Right.m_SettingsType)
			return false;
		if (m_Notification < _Right.m_Notification)
			return true;
		if (m_Notification > _Right.m_Notification)
			return false;
		if (m_CustomNotification < _Right.m_CustomNotification)
			return true;
		if (m_CustomNotification > _Right.m_CustomNotification)
			return false;
		if (m_TabIdentifiers.size() < _Right.m_TabIdentifiers.size())
			return true;
		if (m_TabIdentifiers.size() > _Right.m_TabIdentifiers.size())
			return false;
		for (size_t i = 0; i < m_TabIdentifiers.size(); ++i)
		{
			if (m_TabIdentifiers[i] < _Right.m_TabIdentifiers[i])
				return true;
			if (m_TabIdentifiers[i] > _Right.m_TabIdentifiers[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_DynamicCustomSettingsNotification &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_CustomTaskStatusNotification
{
	public:
	HPMDynamicCustomSettingsContext m_DynamicContext;
	HPMUserContext m_UserContext;
	EHPMCustomTaskStatusNotification m_Notification;
	std::vector<HPMUniqueID> m_SelectedTasks;
	HPMChangeCallbackData_CustomTaskStatusNotification()
		: m_Notification(EHPMCustomTaskStatusNotification_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_CustomTaskStatusNotification(HPMChangeCallbackData_CustomTaskStatusNotification const &_Right)
		: m_DynamicContext(_Right.m_DynamicContext)
		, m_UserContext(_Right.m_UserContext)
		, m_Notification(_Right.m_Notification)
		, m_SelectedTasks(_Right.m_SelectedTasks)
	{
	}
	HPMChangeCallbackData_CustomTaskStatusNotification(HPMChangeCallbackData_CustomTaskStatusNotification &&_Right)
		: m_DynamicContext(std::move(_Right.m_DynamicContext))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_Notification(std::move(_Right.m_Notification))
		, m_SelectedTasks(std::move(_Right.m_SelectedTasks))
	{
	}
	HPMChangeCallbackData_CustomTaskStatusNotification &operator =(HPMChangeCallbackData_CustomTaskStatusNotification const &_Right)
	{
		m_DynamicContext = _Right.m_DynamicContext;
		m_UserContext = _Right.m_UserContext;
		m_Notification = _Right.m_Notification;
		m_SelectedTasks = _Right.m_SelectedTasks;
		return *this;
	}
	HPMChangeCallbackData_CustomTaskStatusNotification &operator =(HPMChangeCallbackData_CustomTaskStatusNotification &&_Right)
	{
		m_DynamicContext = std::move(_Right.m_DynamicContext);
		m_UserContext = std::move(_Right.m_UserContext);
		m_Notification = std::move(_Right.m_Notification);
		m_SelectedTasks = std::move(_Right.m_SelectedTasks);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		if (m_DynamicContext != _Right.m_DynamicContext)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_Notification != _Right.m_Notification)
			return false;
		if (m_SelectedTasks.size() != _Right.m_SelectedTasks.size())
			return false;
		for (size_t i = 0; i < m_SelectedTasks.size(); ++i)
			if (m_SelectedTasks[i] != _Right.m_SelectedTasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		if (m_DynamicContext < _Right.m_DynamicContext)
			return true;
		if (m_DynamicContext > _Right.m_DynamicContext)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_Notification < _Right.m_Notification)
			return true;
		if (m_Notification > _Right.m_Notification)
			return false;
		if (m_SelectedTasks.size() < _Right.m_SelectedTasks.size())
			return true;
		if (m_SelectedTasks.size() > _Right.m_SelectedTasks.size())
			return false;
		for (size_t i = 0; i < m_SelectedTasks.size(); ++i)
		{
			if (m_SelectedTasks[i] < _Right.m_SelectedTasks[i])
				return true;
			if (m_SelectedTasks[i] > _Right.m_SelectedTasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_CustomTaskStatusNotification &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_RightClickDisplayTaskMenu
{
	public:
	HPMRightClickContext m_RightClickContext;
	bool m_bMenuDisplayed;
	HPMUserContext m_UserContext;
	HPMUniqueID m_ProjectID;
	std::vector<HPMUniqueID> m_SelectedTasks;
	HPMChangeCallbackData_RightClickDisplayTaskMenu()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_RightClickDisplayTaskMenu(HPMChangeCallbackData_RightClickDisplayTaskMenu const &_Right)
		: m_RightClickContext(_Right.m_RightClickContext)
		, m_bMenuDisplayed(_Right.m_bMenuDisplayed)
		, m_UserContext(_Right.m_UserContext)
		, m_ProjectID(_Right.m_ProjectID)
		, m_SelectedTasks(_Right.m_SelectedTasks)
	{
	}
	HPMChangeCallbackData_RightClickDisplayTaskMenu(HPMChangeCallbackData_RightClickDisplayTaskMenu &&_Right)
		: m_RightClickContext(std::move(_Right.m_RightClickContext))
		, m_bMenuDisplayed(std::move(_Right.m_bMenuDisplayed))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_SelectedTasks(std::move(_Right.m_SelectedTasks))
	{
	}
	HPMChangeCallbackData_RightClickDisplayTaskMenu &operator =(HPMChangeCallbackData_RightClickDisplayTaskMenu const &_Right)
	{
		m_RightClickContext = _Right.m_RightClickContext;
		m_bMenuDisplayed = _Right.m_bMenuDisplayed;
		m_UserContext = _Right.m_UserContext;
		m_ProjectID = _Right.m_ProjectID;
		m_SelectedTasks = _Right.m_SelectedTasks;
		return *this;
	}
	HPMChangeCallbackData_RightClickDisplayTaskMenu &operator =(HPMChangeCallbackData_RightClickDisplayTaskMenu &&_Right)
	{
		m_RightClickContext = std::move(_Right.m_RightClickContext);
		m_bMenuDisplayed = std::move(_Right.m_bMenuDisplayed);
		m_UserContext = std::move(_Right.m_UserContext);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_SelectedTasks = std::move(_Right.m_SelectedTasks);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		if (m_RightClickContext != _Right.m_RightClickContext)
			return false;
		if (m_bMenuDisplayed != _Right.m_bMenuDisplayed)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_SelectedTasks.size() != _Right.m_SelectedTasks.size())
			return false;
		for (size_t i = 0; i < m_SelectedTasks.size(); ++i)
			if (m_SelectedTasks[i] != _Right.m_SelectedTasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		if (m_RightClickContext < _Right.m_RightClickContext)
			return true;
		if (m_RightClickContext > _Right.m_RightClickContext)
			return false;
		if (m_bMenuDisplayed < _Right.m_bMenuDisplayed)
			return true;
		if (m_bMenuDisplayed > _Right.m_bMenuDisplayed)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_SelectedTasks.size() < _Right.m_SelectedTasks.size())
			return true;
		if (m_SelectedTasks.size() > _Right.m_SelectedTasks.size())
			return false;
		for (size_t i = 0; i < m_SelectedTasks.size(); ++i)
		{
			if (m_SelectedTasks[i] < _Right.m_SelectedTasks[i])
				return true;
			if (m_SelectedTasks[i] > _Right.m_SelectedTasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_RightClickDisplayTaskMenu &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu
{
	public:
	HPMRightClickContext m_RightClickContext;
	bool m_bMenuDisplayed;
	HPMUserContext m_UserContext;
	HPMUniqueID m_ProjectID;
	HPMUInt32 m_WorkflowID;
	HPMUInt32 m_WorkflowObjectID;
	HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu(HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu const &_Right)
		: m_RightClickContext(_Right.m_RightClickContext)
		, m_bMenuDisplayed(_Right.m_bMenuDisplayed)
		, m_UserContext(_Right.m_UserContext)
		, m_ProjectID(_Right.m_ProjectID)
		, m_WorkflowID(_Right.m_WorkflowID)
		, m_WorkflowObjectID(_Right.m_WorkflowObjectID)
	{
	}
	HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu(HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &&_Right)
		: m_RightClickContext(std::move(_Right.m_RightClickContext))
		, m_bMenuDisplayed(std::move(_Right.m_bMenuDisplayed))
		, m_UserContext(std::move(_Right.m_UserContext))
		, m_ProjectID(std::move(_Right.m_ProjectID))
		, m_WorkflowID(std::move(_Right.m_WorkflowID))
		, m_WorkflowObjectID(std::move(_Right.m_WorkflowObjectID))
	{
	}
	HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &operator =(HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu const &_Right)
	{
		m_RightClickContext = _Right.m_RightClickContext;
		m_bMenuDisplayed = _Right.m_bMenuDisplayed;
		m_UserContext = _Right.m_UserContext;
		m_ProjectID = _Right.m_ProjectID;
		m_WorkflowID = _Right.m_WorkflowID;
		m_WorkflowObjectID = _Right.m_WorkflowObjectID;
		return *this;
	}
	HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &operator =(HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &&_Right)
	{
		m_RightClickContext = std::move(_Right.m_RightClickContext);
		m_bMenuDisplayed = std::move(_Right.m_bMenuDisplayed);
		m_UserContext = std::move(_Right.m_UserContext);
		m_ProjectID = std::move(_Right.m_ProjectID);
		m_WorkflowID = std::move(_Right.m_WorkflowID);
		m_WorkflowObjectID = std::move(_Right.m_WorkflowObjectID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		if (m_RightClickContext != _Right.m_RightClickContext)
			return false;
		if (m_bMenuDisplayed != _Right.m_bMenuDisplayed)
			return false;
		if (m_UserContext != _Right.m_UserContext)
			return false;
		if (m_ProjectID != _Right.m_ProjectID)
			return false;
		if (m_WorkflowID != _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID != _Right.m_WorkflowObjectID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		if (m_RightClickContext < _Right.m_RightClickContext)
			return true;
		if (m_RightClickContext > _Right.m_RightClickContext)
			return false;
		if (m_bMenuDisplayed < _Right.m_bMenuDisplayed)
			return true;
		if (m_bMenuDisplayed > _Right.m_bMenuDisplayed)
			return false;
		if (m_UserContext < _Right.m_UserContext)
			return true;
		if (m_UserContext > _Right.m_UserContext)
			return false;
		if (m_ProjectID < _Right.m_ProjectID)
			return true;
		if (m_ProjectID > _Right.m_ProjectID)
			return false;
		if (m_WorkflowID < _Right.m_WorkflowID)
			return true;
		if (m_WorkflowID > _Right.m_WorkflowID)
			return false;
		if (m_WorkflowObjectID < _Right.m_WorkflowObjectID)
			return true;
		if (m_WorkflowObjectID > _Right.m_WorkflowObjectID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_RightClickDisplayWorkflowStepMenu &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_RightClickMenuItemSelected
{
	public:
	HPMString m_UniqueName;
	HPMUserContext m_MenuItemContext;
	HPMChangeCallbackData_RightClickMenuItemSelected()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_RightClickMenuItemSelected(HPMChangeCallbackData_RightClickMenuItemSelected const &_Right)
		: m_UniqueName(_Right.m_UniqueName)
		, m_MenuItemContext(_Right.m_MenuItemContext)
	{
	}
	HPMChangeCallbackData_RightClickMenuItemSelected(HPMChangeCallbackData_RightClickMenuItemSelected &&_Right)
		: m_UniqueName(std::move(_Right.m_UniqueName))
		, m_MenuItemContext(std::move(_Right.m_MenuItemContext))
	{
	}
	HPMChangeCallbackData_RightClickMenuItemSelected &operator =(HPMChangeCallbackData_RightClickMenuItemSelected const &_Right)
	{
		m_UniqueName = _Right.m_UniqueName;
		m_MenuItemContext = _Right.m_MenuItemContext;
		return *this;
	}
	HPMChangeCallbackData_RightClickMenuItemSelected &operator =(HPMChangeCallbackData_RightClickMenuItemSelected &&_Right)
	{
		m_UniqueName = std::move(_Right.m_UniqueName);
		m_MenuItemContext = std::move(_Right.m_MenuItemContext);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		if (m_UniqueName != _Right.m_UniqueName)
			return false;
		if (m_MenuItemContext != _Right.m_MenuItemContext)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		if (m_UniqueName < _Right.m_UniqueName)
			return true;
		if (m_UniqueName > _Right.m_UniqueName)
			return false;
		if (m_MenuItemContext < _Right.m_MenuItemContext)
			return true;
		if (m_MenuItemContext > _Right.m_MenuItemContext)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_RightClickMenuItemSelected &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMChangeCallbackData_ClientSyncDone
{
	public:
	HPMUniqueID m_ResourceID;
	HPMChangeCallbackData_ClientSyncDone()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMChangeCallbackData_ClientSyncDone(HPMChangeCallbackData_ClientSyncDone const &_Right)
		: m_ResourceID(_Right.m_ResourceID)
	{
	}
	HPMChangeCallbackData_ClientSyncDone(HPMChangeCallbackData_ClientSyncDone &&_Right)
		: m_ResourceID(std::move(_Right.m_ResourceID))
	{
	}
	HPMChangeCallbackData_ClientSyncDone &operator =(HPMChangeCallbackData_ClientSyncDone const &_Right)
	{
		m_ResourceID = _Right.m_ResourceID;
		return *this;
	}
	HPMChangeCallbackData_ClientSyncDone &operator =(HPMChangeCallbackData_ClientSyncDone &&_Right)
	{
		m_ResourceID = std::move(_Right.m_ResourceID);
		return *this;
	}
#endif
	bool operator == (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		return true;
	}
	bool operator != (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		return false;
	}
	bool operator > (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMChangeCallbackData_ClientSyncDone &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceEnum
{
	public:
	std::vector<HPMUniqueID> m_Resources;
	HPMResourceEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceEnum(HPMResourceEnum const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMResourceEnum(HPMResourceEnum &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMResourceEnum &operator =(HPMResourceEnum const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMResourceEnum &operator =(HPMResourceEnum &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMResourceEnum &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMResourceEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceEnum &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMResourceEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceProperties
{
	public:
	HPMString m_Name;
	HPMString m_SortName;
	HPMString m_Title;
	HPMString m_EmailAddress;
	EHPMResourceFlag m_Flags;
	EHPMResourceType m_ResourceType;
	EHPMResourcePasswordFlag m_PasswordFlags;
	HPMUniqueID m_RemoteID;
	HPMString m_RemoteGUID;
	std::vector<HPMUniqueID> m_MemberOfResourceGroups;
	HPMResourceProperties()
		: m_Flags(EHPMResourceFlag_None)
		, m_ResourceType(EHPMResourceType_Normal)
		, m_PasswordFlags(EHPMResourcePasswordFlag_MustChangePasswordNextLogon)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceProperties(HPMResourceProperties const &_Right)
		: m_Name(_Right.m_Name)
		, m_SortName(_Right.m_SortName)
		, m_Title(_Right.m_Title)
		, m_EmailAddress(_Right.m_EmailAddress)
		, m_Flags(_Right.m_Flags)
		, m_ResourceType(_Right.m_ResourceType)
		, m_PasswordFlags(_Right.m_PasswordFlags)
		, m_RemoteID(_Right.m_RemoteID)
		, m_RemoteGUID(_Right.m_RemoteGUID)
		, m_MemberOfResourceGroups(_Right.m_MemberOfResourceGroups)
	{
	}
	HPMResourceProperties(HPMResourceProperties &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_SortName(std::move(_Right.m_SortName))
		, m_Title(std::move(_Right.m_Title))
		, m_EmailAddress(std::move(_Right.m_EmailAddress))
		, m_Flags(std::move(_Right.m_Flags))
		, m_ResourceType(std::move(_Right.m_ResourceType))
		, m_PasswordFlags(std::move(_Right.m_PasswordFlags))
		, m_RemoteID(std::move(_Right.m_RemoteID))
		, m_RemoteGUID(std::move(_Right.m_RemoteGUID))
		, m_MemberOfResourceGroups(std::move(_Right.m_MemberOfResourceGroups))
	{
	}
	HPMResourceProperties &operator =(HPMResourceProperties const &_Right)
	{
		m_Name = _Right.m_Name;
		m_SortName = _Right.m_SortName;
		m_Title = _Right.m_Title;
		m_EmailAddress = _Right.m_EmailAddress;
		m_Flags = _Right.m_Flags;
		m_ResourceType = _Right.m_ResourceType;
		m_PasswordFlags = _Right.m_PasswordFlags;
		m_RemoteID = _Right.m_RemoteID;
		m_RemoteGUID = _Right.m_RemoteGUID;
		m_MemberOfResourceGroups = _Right.m_MemberOfResourceGroups;
		return *this;
	}
	HPMResourceProperties &operator =(HPMResourceProperties &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_SortName = std::move(_Right.m_SortName);
		m_Title = std::move(_Right.m_Title);
		m_EmailAddress = std::move(_Right.m_EmailAddress);
		m_Flags = std::move(_Right.m_Flags);
		m_ResourceType = std::move(_Right.m_ResourceType);
		m_PasswordFlags = std::move(_Right.m_PasswordFlags);
		m_RemoteID = std::move(_Right.m_RemoteID);
		m_RemoteGUID = std::move(_Right.m_RemoteGUID);
		m_MemberOfResourceGroups = std::move(_Right.m_MemberOfResourceGroups);
		return *this;
	}
#endif
	bool operator == (const HPMResourceProperties &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_SortName != _Right.m_SortName)
			return false;
		if (m_Title != _Right.m_Title)
			return false;
		if (m_EmailAddress != _Right.m_EmailAddress)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_ResourceType != _Right.m_ResourceType)
			return false;
		if (m_PasswordFlags != _Right.m_PasswordFlags)
			return false;
		if (m_RemoteID != _Right.m_RemoteID)
			return false;
		if (m_RemoteGUID != _Right.m_RemoteGUID)
			return false;
		if (m_MemberOfResourceGroups.size() != _Right.m_MemberOfResourceGroups.size())
			return false;
		for (size_t i = 0; i < m_MemberOfResourceGroups.size(); ++i)
			if (m_MemberOfResourceGroups[i] != _Right.m_MemberOfResourceGroups[i])
				return false;
		return true;
	}
	bool operator != (const HPMResourceProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceProperties &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_SortName < _Right.m_SortName)
			return true;
		if (m_SortName > _Right.m_SortName)
			return false;
		if (m_Title < _Right.m_Title)
			return true;
		if (m_Title > _Right.m_Title)
			return false;
		if (m_EmailAddress < _Right.m_EmailAddress)
			return true;
		if (m_EmailAddress > _Right.m_EmailAddress)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_ResourceType < _Right.m_ResourceType)
			return true;
		if (m_ResourceType > _Right.m_ResourceType)
			return false;
		if (m_PasswordFlags < _Right.m_PasswordFlags)
			return true;
		if (m_PasswordFlags > _Right.m_PasswordFlags)
			return false;
		if (m_RemoteID < _Right.m_RemoteID)
			return true;
		if (m_RemoteID > _Right.m_RemoteID)
			return false;
		if (m_RemoteGUID < _Right.m_RemoteGUID)
			return true;
		if (m_RemoteGUID > _Right.m_RemoteGUID)
			return false;
		if (m_MemberOfResourceGroups.size() < _Right.m_MemberOfResourceGroups.size())
			return true;
		if (m_MemberOfResourceGroups.size() > _Right.m_MemberOfResourceGroups.size())
			return false;
		for (size_t i = 0; i < m_MemberOfResourceGroups.size(); ++i)
		{
			if (m_MemberOfResourceGroups[i] < _Right.m_MemberOfResourceGroups[i])
				return true;
			if (m_MemberOfResourceGroups[i] > _Right.m_MemberOfResourceGroups[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMResourceProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceGlobalSettings
{
	public:
	EHPMResourceGlobalSettingsFlag m_Flags;
	EHPMDateFormat m_DateFormat;
	HPMResourceGlobalSettings()
		: m_Flags(EHPMResourceGlobalSettingsFlag_None)
		, m_DateFormat(EHPMDateFormat_YYYY_MM_DD_ISO8601)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceGlobalSettings(HPMResourceGlobalSettings const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_DateFormat(_Right.m_DateFormat)
	{
	}
	HPMResourceGlobalSettings(HPMResourceGlobalSettings &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_DateFormat(std::move(_Right.m_DateFormat))
	{
	}
	HPMResourceGlobalSettings &operator =(HPMResourceGlobalSettings const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_DateFormat = _Right.m_DateFormat;
		return *this;
	}
	HPMResourceGlobalSettings &operator =(HPMResourceGlobalSettings &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_DateFormat = std::move(_Right.m_DateFormat);
		return *this;
	}
#endif
	bool operator == (const HPMResourceGlobalSettings &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_DateFormat != _Right.m_DateFormat)
			return false;
		return true;
	}
	bool operator != (const HPMResourceGlobalSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceGlobalSettings &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_DateFormat < _Right.m_DateFormat)
			return true;
		if (m_DateFormat > _Right.m_DateFormat)
			return false;
		return false;
	}
	bool operator > (const HPMResourceGlobalSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceGlobalSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceGlobalSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceGroupProperties
{
	public:
	HPMString m_Name;
	HPMString m_SortName;
	EHPMResourceGroupFlag m_Flags;
	HPMResourceGroupProperties()
		: m_Flags(EHPMResourceGroupFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceGroupProperties(HPMResourceGroupProperties const &_Right)
		: m_Name(_Right.m_Name)
		, m_SortName(_Right.m_SortName)
		, m_Flags(_Right.m_Flags)
	{
	}
	HPMResourceGroupProperties(HPMResourceGroupProperties &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_SortName(std::move(_Right.m_SortName))
		, m_Flags(std::move(_Right.m_Flags))
	{
	}
	HPMResourceGroupProperties &operator =(HPMResourceGroupProperties const &_Right)
	{
		m_Name = _Right.m_Name;
		m_SortName = _Right.m_SortName;
		m_Flags = _Right.m_Flags;
		return *this;
	}
	HPMResourceGroupProperties &operator =(HPMResourceGroupProperties &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_SortName = std::move(_Right.m_SortName);
		m_Flags = std::move(_Right.m_Flags);
		return *this;
	}
#endif
	bool operator == (const HPMResourceGroupProperties &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_SortName != _Right.m_SortName)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		return true;
	}
	bool operator != (const HPMResourceGroupProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceGroupProperties &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_SortName < _Right.m_SortName)
			return true;
		if (m_SortName > _Right.m_SortName)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		return false;
	}
	bool operator > (const HPMResourceGroupProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceGroupProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceGroupProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceGroupEnum
{
	public:
	std::vector<HPMUniqueID> m_ResourceGroups;
	HPMResourceGroupEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceGroupEnum(HPMResourceGroupEnum const &_Right)
		: m_ResourceGroups(_Right.m_ResourceGroups)
	{
	}
	HPMResourceGroupEnum(HPMResourceGroupEnum &&_Right)
		: m_ResourceGroups(std::move(_Right.m_ResourceGroups))
	{
	}
	HPMResourceGroupEnum &operator =(HPMResourceGroupEnum const &_Right)
	{
		m_ResourceGroups = _Right.m_ResourceGroups;
		return *this;
	}
	HPMResourceGroupEnum &operator =(HPMResourceGroupEnum &&_Right)
	{
		m_ResourceGroups = std::move(_Right.m_ResourceGroups);
		return *this;
	}
#endif
	bool operator == (const HPMResourceGroupEnum &_Right) const
	{
		if (m_ResourceGroups.size() != _Right.m_ResourceGroups.size())
			return false;
		for (size_t i = 0; i < m_ResourceGroups.size(); ++i)
			if (m_ResourceGroups[i] != _Right.m_ResourceGroups[i])
				return false;
		return true;
	}
	bool operator != (const HPMResourceGroupEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceGroupEnum &_Right) const
	{
		if (m_ResourceGroups.size() < _Right.m_ResourceGroups.size())
			return true;
		if (m_ResourceGroups.size() > _Right.m_ResourceGroups.size())
			return false;
		for (size_t i = 0; i < m_ResourceGroups.size(); ++i)
		{
			if (m_ResourceGroups[i] < _Right.m_ResourceGroups[i])
				return true;
			if (m_ResourceGroups[i] > _Right.m_ResourceGroups[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMResourceGroupEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceGroupEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceGroupEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceImpersonate
{
	public:
	HPMUniqueID m_ResourceID;
	EHPMDataHistoryClientOrigin m_ClientOrigin;
	HPMUntranslatedString m_CustomClientOrigin;
	HPMResourceImpersonate()
		: m_ClientOrigin(EHPMDataHistoryClientOrigin_Unknown)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceImpersonate(HPMResourceImpersonate const &_Right)
		: m_ResourceID(_Right.m_ResourceID)
		, m_ClientOrigin(_Right.m_ClientOrigin)
		, m_CustomClientOrigin(_Right.m_CustomClientOrigin)
	{
	}
	HPMResourceImpersonate(HPMResourceImpersonate &&_Right)
		: m_ResourceID(std::move(_Right.m_ResourceID))
		, m_ClientOrigin(std::move(_Right.m_ClientOrigin))
		, m_CustomClientOrigin(std::move(_Right.m_CustomClientOrigin))
	{
	}
	HPMResourceImpersonate &operator =(HPMResourceImpersonate const &_Right)
	{
		m_ResourceID = _Right.m_ResourceID;
		m_ClientOrigin = _Right.m_ClientOrigin;
		m_CustomClientOrigin = _Right.m_CustomClientOrigin;
		return *this;
	}
	HPMResourceImpersonate &operator =(HPMResourceImpersonate &&_Right)
	{
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_ClientOrigin = std::move(_Right.m_ClientOrigin);
		m_CustomClientOrigin = std::move(_Right.m_CustomClientOrigin);
		return *this;
	}
#endif
	bool operator == (const HPMResourceImpersonate &_Right) const
	{
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_ClientOrigin != _Right.m_ClientOrigin)
			return false;
		if (m_CustomClientOrigin != _Right.m_CustomClientOrigin)
			return false;
		return true;
	}
	bool operator != (const HPMResourceImpersonate &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceImpersonate &_Right) const
	{
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_ClientOrigin < _Right.m_ClientOrigin)
			return true;
		if (m_ClientOrigin > _Right.m_ClientOrigin)
			return false;
		if (m_CustomClientOrigin < _Right.m_CustomClientOrigin)
			return true;
		if (m_CustomClientOrigin > _Right.m_CustomClientOrigin)
			return false;
		return false;
	}
	bool operator > (const HPMResourceImpersonate &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceImpersonate &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceImpersonate &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectEnum
{
	public:
	std::vector<HPMUniqueID> m_Projects;
	HPMProjectEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectEnum(HPMProjectEnum const &_Right)
		: m_Projects(_Right.m_Projects)
	{
	}
	HPMProjectEnum(HPMProjectEnum &&_Right)
		: m_Projects(std::move(_Right.m_Projects))
	{
	}
	HPMProjectEnum &operator =(HPMProjectEnum const &_Right)
	{
		m_Projects = _Right.m_Projects;
		return *this;
	}
	HPMProjectEnum &operator =(HPMProjectEnum &&_Right)
	{
		m_Projects = std::move(_Right.m_Projects);
		return *this;
	}
#endif
	bool operator == (const HPMProjectEnum &_Right) const
	{
		if (m_Projects.size() != _Right.m_Projects.size())
			return false;
		for (size_t i = 0; i < m_Projects.size(); ++i)
			if (m_Projects[i] != _Right.m_Projects[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectEnum &_Right) const
	{
		if (m_Projects.size() < _Right.m_Projects.size())
			return true;
		if (m_Projects.size() > _Right.m_Projects.size())
			return false;
		for (size_t i = 0; i < m_Projects.size(); ++i)
		{
			if (m_Projects[i] < _Right.m_Projects[i])
				return true;
			if (m_Projects[i] > _Right.m_Projects[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectProperties
{
	public:
	HPMString m_Name;
	HPMString m_NiceName;
	HPMString m_SortName;
	bool m_bArchivedStatus;
	EHPMProjectMethod m_ProjectMethod;
	EHPMProjectTaskCompletionStyle m_CompletionStyle;
	EHPMProjectDefaultEditorMode m_DefaultEditorMode;
	EHPMProjectAgileTemplate m_AgileTemplate;
	HPMProjectProperties()
		: m_bArchivedStatus(0)
		, m_ProjectMethod(EHPMProjectMethod_FixedDuration)
		, m_CompletionStyle(EHPMProjectTaskCompletionStyle_Auto)
		, m_DefaultEditorMode(EHPMProjectDefaultEditorMode_Agile)
		, m_AgileTemplate(EHPMProjectAgileTemplate_SCRUM)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectProperties(HPMProjectProperties const &_Right)
		: m_Name(_Right.m_Name)
		, m_NiceName(_Right.m_NiceName)
		, m_SortName(_Right.m_SortName)
		, m_bArchivedStatus(_Right.m_bArchivedStatus)
		, m_ProjectMethod(_Right.m_ProjectMethod)
		, m_CompletionStyle(_Right.m_CompletionStyle)
		, m_DefaultEditorMode(_Right.m_DefaultEditorMode)
		, m_AgileTemplate(_Right.m_AgileTemplate)
	{
	}
	HPMProjectProperties(HPMProjectProperties &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_NiceName(std::move(_Right.m_NiceName))
		, m_SortName(std::move(_Right.m_SortName))
		, m_bArchivedStatus(std::move(_Right.m_bArchivedStatus))
		, m_ProjectMethod(std::move(_Right.m_ProjectMethod))
		, m_CompletionStyle(std::move(_Right.m_CompletionStyle))
		, m_DefaultEditorMode(std::move(_Right.m_DefaultEditorMode))
		, m_AgileTemplate(std::move(_Right.m_AgileTemplate))
	{
	}
	HPMProjectProperties &operator =(HPMProjectProperties const &_Right)
	{
		m_Name = _Right.m_Name;
		m_NiceName = _Right.m_NiceName;
		m_SortName = _Right.m_SortName;
		m_bArchivedStatus = _Right.m_bArchivedStatus;
		m_ProjectMethod = _Right.m_ProjectMethod;
		m_CompletionStyle = _Right.m_CompletionStyle;
		m_DefaultEditorMode = _Right.m_DefaultEditorMode;
		m_AgileTemplate = _Right.m_AgileTemplate;
		return *this;
	}
	HPMProjectProperties &operator =(HPMProjectProperties &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_NiceName = std::move(_Right.m_NiceName);
		m_SortName = std::move(_Right.m_SortName);
		m_bArchivedStatus = std::move(_Right.m_bArchivedStatus);
		m_ProjectMethod = std::move(_Right.m_ProjectMethod);
		m_CompletionStyle = std::move(_Right.m_CompletionStyle);
		m_DefaultEditorMode = std::move(_Right.m_DefaultEditorMode);
		m_AgileTemplate = std::move(_Right.m_AgileTemplate);
		return *this;
	}
#endif
	bool operator == (const HPMProjectProperties &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_NiceName != _Right.m_NiceName)
			return false;
		if (m_SortName != _Right.m_SortName)
			return false;
		if (m_bArchivedStatus != _Right.m_bArchivedStatus)
			return false;
		if (m_ProjectMethod != _Right.m_ProjectMethod)
			return false;
		if (m_CompletionStyle != _Right.m_CompletionStyle)
			return false;
		if (m_DefaultEditorMode != _Right.m_DefaultEditorMode)
			return false;
		if (m_AgileTemplate != _Right.m_AgileTemplate)
			return false;
		return true;
	}
	bool operator != (const HPMProjectProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectProperties &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_NiceName < _Right.m_NiceName)
			return true;
		if (m_NiceName > _Right.m_NiceName)
			return false;
		if (m_SortName < _Right.m_SortName)
			return true;
		if (m_SortName > _Right.m_SortName)
			return false;
		if (m_bArchivedStatus < _Right.m_bArchivedStatus)
			return true;
		if (m_bArchivedStatus > _Right.m_bArchivedStatus)
			return false;
		if (m_ProjectMethod < _Right.m_ProjectMethod)
			return true;
		if (m_ProjectMethod > _Right.m_ProjectMethod)
			return false;
		if (m_CompletionStyle < _Right.m_CompletionStyle)
			return true;
		if (m_CompletionStyle > _Right.m_CompletionStyle)
			return false;
		if (m_DefaultEditorMode < _Right.m_DefaultEditorMode)
			return true;
		if (m_DefaultEditorMode > _Right.m_DefaultEditorMode)
			return false;
		if (m_AgileTemplate < _Right.m_AgileTemplate)
			return true;
		if (m_AgileTemplate > _Right.m_AgileTemplate)
			return false;
		return false;
	}
	bool operator > (const HPMProjectProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectSettings
{
	public:
	EHPMProjectSettingsFlag m_Flags;
	HPMUInt32 m_ParentTaskDisplayDepth;
	EHPMProjectSprintPredictionMethod m_SprintPredictionMethod;
	HPMUInt32 m_SprintDefaultLength;
	HPMFP64 m_EstimatedHours;
	HPMColumn m_ColumnForPriorityInToDoList;
	HPMUInt32 m_CustomColumnHashForTimeSpentColumnInToDolist;
	bool m_bNewSprintsHaveNoMembers;
	HPMString m_WorkflowDesignation;
	HPMProjectSettings()
		: m_Flags(EHPMProjectSettingsFlag_None)
		, m_ParentTaskDisplayDepth(1)
		, m_SprintPredictionMethod(EHPMProjectSprintPredictionMethod_5Days_WeightedAverage)
		, m_SprintDefaultLength(10)
		, m_EstimatedHours(8.0)
		, m_CustomColumnHashForTimeSpentColumnInToDolist(0)
		, m_bNewSprintsHaveNoMembers(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectSettings(HPMProjectSettings const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_ParentTaskDisplayDepth(_Right.m_ParentTaskDisplayDepth)
		, m_SprintPredictionMethod(_Right.m_SprintPredictionMethod)
		, m_SprintDefaultLength(_Right.m_SprintDefaultLength)
		, m_EstimatedHours(_Right.m_EstimatedHours)
		, m_ColumnForPriorityInToDoList(_Right.m_ColumnForPriorityInToDoList)
		, m_CustomColumnHashForTimeSpentColumnInToDolist(_Right.m_CustomColumnHashForTimeSpentColumnInToDolist)
		, m_bNewSprintsHaveNoMembers(_Right.m_bNewSprintsHaveNoMembers)
		, m_WorkflowDesignation(_Right.m_WorkflowDesignation)
	{
	}
	HPMProjectSettings(HPMProjectSettings &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_ParentTaskDisplayDepth(std::move(_Right.m_ParentTaskDisplayDepth))
		, m_SprintPredictionMethod(std::move(_Right.m_SprintPredictionMethod))
		, m_SprintDefaultLength(std::move(_Right.m_SprintDefaultLength))
		, m_EstimatedHours(std::move(_Right.m_EstimatedHours))
		, m_ColumnForPriorityInToDoList(std::move(_Right.m_ColumnForPriorityInToDoList))
		, m_CustomColumnHashForTimeSpentColumnInToDolist(std::move(_Right.m_CustomColumnHashForTimeSpentColumnInToDolist))
		, m_bNewSprintsHaveNoMembers(std::move(_Right.m_bNewSprintsHaveNoMembers))
		, m_WorkflowDesignation(std::move(_Right.m_WorkflowDesignation))
	{
	}
	HPMProjectSettings &operator =(HPMProjectSettings const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_ParentTaskDisplayDepth = _Right.m_ParentTaskDisplayDepth;
		m_SprintPredictionMethod = _Right.m_SprintPredictionMethod;
		m_SprintDefaultLength = _Right.m_SprintDefaultLength;
		m_EstimatedHours = _Right.m_EstimatedHours;
		m_ColumnForPriorityInToDoList = _Right.m_ColumnForPriorityInToDoList;
		m_CustomColumnHashForTimeSpentColumnInToDolist = _Right.m_CustomColumnHashForTimeSpentColumnInToDolist;
		m_bNewSprintsHaveNoMembers = _Right.m_bNewSprintsHaveNoMembers;
		m_WorkflowDesignation = _Right.m_WorkflowDesignation;
		return *this;
	}
	HPMProjectSettings &operator =(HPMProjectSettings &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_ParentTaskDisplayDepth = std::move(_Right.m_ParentTaskDisplayDepth);
		m_SprintPredictionMethod = std::move(_Right.m_SprintPredictionMethod);
		m_SprintDefaultLength = std::move(_Right.m_SprintDefaultLength);
		m_EstimatedHours = std::move(_Right.m_EstimatedHours);
		m_ColumnForPriorityInToDoList = std::move(_Right.m_ColumnForPriorityInToDoList);
		m_CustomColumnHashForTimeSpentColumnInToDolist = std::move(_Right.m_CustomColumnHashForTimeSpentColumnInToDolist);
		m_bNewSprintsHaveNoMembers = std::move(_Right.m_bNewSprintsHaveNoMembers);
		m_WorkflowDesignation = std::move(_Right.m_WorkflowDesignation);
		return *this;
	}
#endif
	bool operator == (const HPMProjectSettings &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_ParentTaskDisplayDepth != _Right.m_ParentTaskDisplayDepth)
			return false;
		if (m_SprintPredictionMethod != _Right.m_SprintPredictionMethod)
			return false;
		if (m_SprintDefaultLength != _Right.m_SprintDefaultLength)
			return false;
		if (m_EstimatedHours != _Right.m_EstimatedHours)
			return false;
		if (m_ColumnForPriorityInToDoList != _Right.m_ColumnForPriorityInToDoList)
			return false;
		if (m_CustomColumnHashForTimeSpentColumnInToDolist != _Right.m_CustomColumnHashForTimeSpentColumnInToDolist)
			return false;
		if (m_bNewSprintsHaveNoMembers != _Right.m_bNewSprintsHaveNoMembers)
			return false;
		if (m_WorkflowDesignation != _Right.m_WorkflowDesignation)
			return false;
		return true;
	}
	bool operator != (const HPMProjectSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectSettings &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_ParentTaskDisplayDepth < _Right.m_ParentTaskDisplayDepth)
			return true;
		if (m_ParentTaskDisplayDepth > _Right.m_ParentTaskDisplayDepth)
			return false;
		if (m_SprintPredictionMethod < _Right.m_SprintPredictionMethod)
			return true;
		if (m_SprintPredictionMethod > _Right.m_SprintPredictionMethod)
			return false;
		if (m_SprintDefaultLength < _Right.m_SprintDefaultLength)
			return true;
		if (m_SprintDefaultLength > _Right.m_SprintDefaultLength)
			return false;
		if (m_EstimatedHours < _Right.m_EstimatedHours)
			return true;
		if (m_EstimatedHours > _Right.m_EstimatedHours)
			return false;
		if (m_ColumnForPriorityInToDoList < _Right.m_ColumnForPriorityInToDoList)
			return true;
		if (m_ColumnForPriorityInToDoList > _Right.m_ColumnForPriorityInToDoList)
			return false;
		if (m_CustomColumnHashForTimeSpentColumnInToDolist < _Right.m_CustomColumnHashForTimeSpentColumnInToDolist)
			return true;
		if (m_CustomColumnHashForTimeSpentColumnInToDolist > _Right.m_CustomColumnHashForTimeSpentColumnInToDolist)
			return false;
		if (m_bNewSprintsHaveNoMembers < _Right.m_bNewSprintsHaveNoMembers)
			return true;
		if (m_bNewSprintsHaveNoMembers > _Right.m_bNewSprintsHaveNoMembers)
			return false;
		if (m_WorkflowDesignation < _Right.m_WorkflowDesignation)
			return true;
		if (m_WorkflowDesignation > _Right.m_WorkflowDesignation)
			return false;
		return false;
	}
	bool operator > (const HPMProjectSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectHistoryAutoSaveSettings
{
	public:
	EHPMPeriodicityType m_Type;
	HPMUInt32 m_DayOfWeek;
	HPMUInt32 m_HourOfDay;
	HPMProjectHistoryAutoSaveSettings()
		: m_Type(EHPMPeriodicityType_Weekly)
		, m_DayOfWeek(6)
		, m_HourOfDay(4)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectHistoryAutoSaveSettings(HPMProjectHistoryAutoSaveSettings const &_Right)
		: m_Type(_Right.m_Type)
		, m_DayOfWeek(_Right.m_DayOfWeek)
		, m_HourOfDay(_Right.m_HourOfDay)
	{
	}
	HPMProjectHistoryAutoSaveSettings(HPMProjectHistoryAutoSaveSettings &&_Right)
		: m_Type(std::move(_Right.m_Type))
		, m_DayOfWeek(std::move(_Right.m_DayOfWeek))
		, m_HourOfDay(std::move(_Right.m_HourOfDay))
	{
	}
	HPMProjectHistoryAutoSaveSettings &operator =(HPMProjectHistoryAutoSaveSettings const &_Right)
	{
		m_Type = _Right.m_Type;
		m_DayOfWeek = _Right.m_DayOfWeek;
		m_HourOfDay = _Right.m_HourOfDay;
		return *this;
	}
	HPMProjectHistoryAutoSaveSettings &operator =(HPMProjectHistoryAutoSaveSettings &&_Right)
	{
		m_Type = std::move(_Right.m_Type);
		m_DayOfWeek = std::move(_Right.m_DayOfWeek);
		m_HourOfDay = std::move(_Right.m_HourOfDay);
		return *this;
	}
#endif
	bool operator == (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		if (m_Type != _Right.m_Type)
			return false;
		if (m_DayOfWeek != _Right.m_DayOfWeek)
			return false;
		if (m_HourOfDay != _Right.m_HourOfDay)
			return false;
		return true;
	}
	bool operator != (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_DayOfWeek < _Right.m_DayOfWeek)
			return true;
		if (m_DayOfWeek > _Right.m_DayOfWeek)
			return false;
		if (m_HourOfDay < _Right.m_HourOfDay)
			return true;
		if (m_HourOfDay > _Right.m_HourOfDay)
			return false;
		return false;
	}
	bool operator > (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectHistoryAutoSaveSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomColumnsColumnDropListItem
{
	public:
	HPMString m_Name;
	EHPMListIcon m_Icon;
	HPMUInt32 m_Id;
	std::vector<HPMResourceDefinition> m_AutoAssignResources;
	HPMProjectCustomColumnsColumnDropListItem()
		: m_Icon(EHPMListIcon_Default)
		, m_Id(1)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomColumnsColumnDropListItem(HPMProjectCustomColumnsColumnDropListItem const &_Right)
		: m_Name(_Right.m_Name)
		, m_Icon(_Right.m_Icon)
		, m_Id(_Right.m_Id)
		, m_AutoAssignResources(_Right.m_AutoAssignResources)
	{
	}
	HPMProjectCustomColumnsColumnDropListItem(HPMProjectCustomColumnsColumnDropListItem &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_Icon(std::move(_Right.m_Icon))
		, m_Id(std::move(_Right.m_Id))
		, m_AutoAssignResources(std::move(_Right.m_AutoAssignResources))
	{
	}
	HPMProjectCustomColumnsColumnDropListItem &operator =(HPMProjectCustomColumnsColumnDropListItem const &_Right)
	{
		m_Name = _Right.m_Name;
		m_Icon = _Right.m_Icon;
		m_Id = _Right.m_Id;
		m_AutoAssignResources = _Right.m_AutoAssignResources;
		return *this;
	}
	HPMProjectCustomColumnsColumnDropListItem &operator =(HPMProjectCustomColumnsColumnDropListItem &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_Icon = std::move(_Right.m_Icon);
		m_Id = std::move(_Right.m_Id);
		m_AutoAssignResources = std::move(_Right.m_AutoAssignResources);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_Icon != _Right.m_Icon)
			return false;
		if (m_Id != _Right.m_Id)
			return false;
		if (m_AutoAssignResources.size() != _Right.m_AutoAssignResources.size())
			return false;
		for (size_t i = 0; i < m_AutoAssignResources.size(); ++i)
			if (m_AutoAssignResources[i] != _Right.m_AutoAssignResources[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_Icon < _Right.m_Icon)
			return true;
		if (m_Icon > _Right.m_Icon)
			return false;
		if (m_Id < _Right.m_Id)
			return true;
		if (m_Id > _Right.m_Id)
			return false;
		if (m_AutoAssignResources.size() < _Right.m_AutoAssignResources.size())
			return true;
		if (m_AutoAssignResources.size() > _Right.m_AutoAssignResources.size())
			return false;
		for (size_t i = 0; i < m_AutoAssignResources.size(); ++i)
		{
			if (m_AutoAssignResources[i] < _Right.m_AutoAssignResources[i])
				return true;
			if (m_AutoAssignResources[i] > _Right.m_AutoAssignResources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomColumnsColumnDropListItem &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomColumnsColumnSDKData
{
	public:
	HPMString m_Key;
	std::vector<HPMUInt8> m_Value;
	HPMProjectCustomColumnsColumnSDKData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomColumnsColumnSDKData(HPMProjectCustomColumnsColumnSDKData const &_Right)
		: m_Key(_Right.m_Key)
		, m_Value(_Right.m_Value)
	{
	}
	HPMProjectCustomColumnsColumnSDKData(HPMProjectCustomColumnsColumnSDKData &&_Right)
		: m_Key(std::move(_Right.m_Key))
		, m_Value(std::move(_Right.m_Value))
	{
	}
	HPMProjectCustomColumnsColumnSDKData &operator =(HPMProjectCustomColumnsColumnSDKData const &_Right)
	{
		m_Key = _Right.m_Key;
		m_Value = _Right.m_Value;
		return *this;
	}
	HPMProjectCustomColumnsColumnSDKData &operator =(HPMProjectCustomColumnsColumnSDKData &&_Right)
	{
		m_Key = std::move(_Right.m_Key);
		m_Value = std::move(_Right.m_Value);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		if (m_Key != _Right.m_Key)
			return false;
		if (m_Value.size() != _Right.m_Value.size())
			return false;
		for (size_t i = 0; i < m_Value.size(); ++i)
			if (m_Value[i] != _Right.m_Value[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		if (m_Key < _Right.m_Key)
			return true;
		if (m_Key > _Right.m_Key)
			return false;
		if (m_Value.size() < _Right.m_Value.size())
			return true;
		if (m_Value.size() > _Right.m_Value.size())
			return false;
		for (size_t i = 0; i < m_Value.size(); ++i)
		{
			if (m_Value[i] < _Right.m_Value[i])
				return true;
			if (m_Value[i] > _Right.m_Value[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomColumnsColumnSDKData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomColumnsColumn
{
	public:
	HPMUInt32 m_Hash;
	EHPMProjectCustomColumnsColumnType m_Type;
	HPMString m_Name;
	EHPMProjectCustomColumnsColumnAccessRights m_AccessRights;
	HPMString m_Unit;
	std::vector<HPMProjectCustomColumnsColumnDropListItem> m_DropListItems;
	std::vector<HPMProjectCustomColumnsColumnSDKData> m_SDKData;
	EHPMProjectCustomColumnsColumnFlag m_Flags;
	HPMProjectCustomColumnsColumn()
		: m_Type(EHPMProjectCustomColumnsColumnType_Text)
		, m_AccessRights(EHPMProjectCustomColumnsColumnAccessRights_AllProjectMembers)
		, m_Flags(EHPMProjectCustomColumnsColumnFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomColumnsColumn(HPMProjectCustomColumnsColumn const &_Right)
		: m_Hash(_Right.m_Hash)
		, m_Type(_Right.m_Type)
		, m_Name(_Right.m_Name)
		, m_AccessRights(_Right.m_AccessRights)
		, m_Unit(_Right.m_Unit)
		, m_DropListItems(_Right.m_DropListItems)
		, m_SDKData(_Right.m_SDKData)
		, m_Flags(_Right.m_Flags)
	{
	}
	HPMProjectCustomColumnsColumn(HPMProjectCustomColumnsColumn &&_Right)
		: m_Hash(std::move(_Right.m_Hash))
		, m_Type(std::move(_Right.m_Type))
		, m_Name(std::move(_Right.m_Name))
		, m_AccessRights(std::move(_Right.m_AccessRights))
		, m_Unit(std::move(_Right.m_Unit))
		, m_DropListItems(std::move(_Right.m_DropListItems))
		, m_SDKData(std::move(_Right.m_SDKData))
		, m_Flags(std::move(_Right.m_Flags))
	{
	}
	HPMProjectCustomColumnsColumn &operator =(HPMProjectCustomColumnsColumn const &_Right)
	{
		m_Hash = _Right.m_Hash;
		m_Type = _Right.m_Type;
		m_Name = _Right.m_Name;
		m_AccessRights = _Right.m_AccessRights;
		m_Unit = _Right.m_Unit;
		m_DropListItems = _Right.m_DropListItems;
		m_SDKData = _Right.m_SDKData;
		m_Flags = _Right.m_Flags;
		return *this;
	}
	HPMProjectCustomColumnsColumn &operator =(HPMProjectCustomColumnsColumn &&_Right)
	{
		m_Hash = std::move(_Right.m_Hash);
		m_Type = std::move(_Right.m_Type);
		m_Name = std::move(_Right.m_Name);
		m_AccessRights = std::move(_Right.m_AccessRights);
		m_Unit = std::move(_Right.m_Unit);
		m_DropListItems = std::move(_Right.m_DropListItems);
		m_SDKData = std::move(_Right.m_SDKData);
		m_Flags = std::move(_Right.m_Flags);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomColumnsColumn &_Right) const
	{
		if (m_Hash != _Right.m_Hash)
			return false;
		if (m_Type != _Right.m_Type)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		if (m_AccessRights != _Right.m_AccessRights)
			return false;
		if (m_Unit != _Right.m_Unit)
			return false;
		if (m_DropListItems.size() != _Right.m_DropListItems.size())
			return false;
		for (size_t i = 0; i < m_DropListItems.size(); ++i)
			if (m_DropListItems[i] != _Right.m_DropListItems[i])
				return false;
		if (m_SDKData.size() != _Right.m_SDKData.size())
			return false;
		for (size_t i = 0; i < m_SDKData.size(); ++i)
			if (m_SDKData[i] != _Right.m_SDKData[i])
				return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		return true;
	}
	bool operator != (const HPMProjectCustomColumnsColumn &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomColumnsColumn &_Right) const
	{
		if (m_Hash < _Right.m_Hash)
			return true;
		if (m_Hash > _Right.m_Hash)
			return false;
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_AccessRights < _Right.m_AccessRights)
			return true;
		if (m_AccessRights > _Right.m_AccessRights)
			return false;
		if (m_Unit < _Right.m_Unit)
			return true;
		if (m_Unit > _Right.m_Unit)
			return false;
		if (m_DropListItems.size() < _Right.m_DropListItems.size())
			return true;
		if (m_DropListItems.size() > _Right.m_DropListItems.size())
			return false;
		for (size_t i = 0; i < m_DropListItems.size(); ++i)
		{
			if (m_DropListItems[i] < _Right.m_DropListItems[i])
				return true;
			if (m_DropListItems[i] > _Right.m_DropListItems[i])
				return false;
		}
		if (m_SDKData.size() < _Right.m_SDKData.size())
			return true;
		if (m_SDKData.size() > _Right.m_SDKData.size())
			return false;
		for (size_t i = 0; i < m_SDKData.size(); ++i)
		{
			if (m_SDKData[i] < _Right.m_SDKData[i])
				return true;
			if (m_SDKData[i] > _Right.m_SDKData[i])
				return false;
		}
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		return false;
	}
	bool operator > (const HPMProjectCustomColumnsColumn &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomColumnsColumn &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomColumnsColumn &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomColumns
{
	public:
	std::vector<HPMProjectCustomColumnsColumn> m_ShowingColumns;
	std::vector<HPMProjectCustomColumnsColumn> m_HiddenColumns;
	HPMProjectCustomColumns()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomColumns(HPMProjectCustomColumns const &_Right)
		: m_ShowingColumns(_Right.m_ShowingColumns)
		, m_HiddenColumns(_Right.m_HiddenColumns)
	{
	}
	HPMProjectCustomColumns(HPMProjectCustomColumns &&_Right)
		: m_ShowingColumns(std::move(_Right.m_ShowingColumns))
		, m_HiddenColumns(std::move(_Right.m_HiddenColumns))
	{
	}
	HPMProjectCustomColumns &operator =(HPMProjectCustomColumns const &_Right)
	{
		m_ShowingColumns = _Right.m_ShowingColumns;
		m_HiddenColumns = _Right.m_HiddenColumns;
		return *this;
	}
	HPMProjectCustomColumns &operator =(HPMProjectCustomColumns &&_Right)
	{
		m_ShowingColumns = std::move(_Right.m_ShowingColumns);
		m_HiddenColumns = std::move(_Right.m_HiddenColumns);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomColumns &_Right) const
	{
		if (m_ShowingColumns.size() != _Right.m_ShowingColumns.size())
			return false;
		for (size_t i = 0; i < m_ShowingColumns.size(); ++i)
			if (m_ShowingColumns[i] != _Right.m_ShowingColumns[i])
				return false;
		if (m_HiddenColumns.size() != _Right.m_HiddenColumns.size())
			return false;
		for (size_t i = 0; i < m_HiddenColumns.size(); ++i)
			if (m_HiddenColumns[i] != _Right.m_HiddenColumns[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectCustomColumns &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomColumns &_Right) const
	{
		if (m_ShowingColumns.size() < _Right.m_ShowingColumns.size())
			return true;
		if (m_ShowingColumns.size() > _Right.m_ShowingColumns.size())
			return false;
		for (size_t i = 0; i < m_ShowingColumns.size(); ++i)
		{
			if (m_ShowingColumns[i] < _Right.m_ShowingColumns[i])
				return true;
			if (m_ShowingColumns[i] > _Right.m_ShowingColumns[i])
				return false;
		}
		if (m_HiddenColumns.size() < _Right.m_HiddenColumns.size())
			return true;
		if (m_HiddenColumns.size() > _Right.m_HiddenColumns.size())
			return false;
		for (size_t i = 0; i < m_HiddenColumns.size(); ++i)
		{
			if (m_HiddenColumns[i] < _Right.m_HiddenColumns[i])
				return true;
			if (m_HiddenColumns[i] > _Right.m_HiddenColumns[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectCustomColumns &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomColumns &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomColumns &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectDefaultColumns
{
	public:
	std::vector<EHPMProjectDefaultColumn> m_Columns;
	HPMProjectDefaultColumns()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectDefaultColumns(HPMProjectDefaultColumns const &_Right)
		: m_Columns(_Right.m_Columns)
	{
	}
	HPMProjectDefaultColumns(HPMProjectDefaultColumns &&_Right)
		: m_Columns(std::move(_Right.m_Columns))
	{
	}
	HPMProjectDefaultColumns &operator =(HPMProjectDefaultColumns const &_Right)
	{
		m_Columns = _Right.m_Columns;
		return *this;
	}
	HPMProjectDefaultColumns &operator =(HPMProjectDefaultColumns &&_Right)
	{
		m_Columns = std::move(_Right.m_Columns);
		return *this;
	}
#endif
	bool operator == (const HPMProjectDefaultColumns &_Right) const
	{
		if (m_Columns.size() != _Right.m_Columns.size())
			return false;
		for (size_t i = 0; i < m_Columns.size(); ++i)
			if (m_Columns[i] != _Right.m_Columns[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectDefaultColumns &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectDefaultColumns &_Right) const
	{
		if (m_Columns.size() < _Right.m_Columns.size())
			return true;
		if (m_Columns.size() > _Right.m_Columns.size())
			return false;
		for (size_t i = 0; i < m_Columns.size(); ++i)
		{
			if (m_Columns[i] < _Right.m_Columns[i])
				return true;
			if (m_Columns[i] > _Right.m_Columns[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectDefaultColumns &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectDefaultColumns &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectDefaultColumns &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectEmailSettings
{
	public:
	EHPMOptionalBoolean m_ResourceScheduleUpdated_Enable;
	HPMInt32 m_ResourceScheduleUpdated_nMinutesAfterUpdate;
	bool m_ResourceScheduleUpdated_bIncludeComment;
	EHPMOptionalBoolean m_BeforeAMilestone_Enable;
	HPMInt32 m_BeforeAMilestone_nDaysBefore0;
	HPMInt32 m_BeforeAMilestone_nDaysBefore1;
	HPMInt32 m_BeforeAMilestone_WhenToSend;
	EHPMOptionalBoolean m_ProjectReport_Enable;
	EHPMPeriodicityType m_ProjectReport_PeriodicityType;
	HPMInt32 m_ProjectReport_WhenToSendWeekDay;
	HPMInt32 m_ProjectReport_WhenToSendHourOfDay;
	std::vector<HPMString> m_ProjectReport_SendToEmailsExtra;
	EHPMOptionalBoolean m_WhenATaskIsCompleted_Enable;
	std::vector<HPMString> m_WhenATaskIsCompleted_SendToEmailsExtra;
	EHPMOptionalBoolean m_WhenACommentIsPosted_Enable;
	std::vector<HPMString> m_WhenACommentIsPosted_SendToEmailsExtra;
	EHPMOptionalBoolean m_WhenAPredcessorIsCompleted_Enable;
	std::vector<HPMString> m_WhenAPredcessorIsCompleted_SendToEmailsExtra;
	HPMProjectEmailSettings()
		: m_ResourceScheduleUpdated_Enable(EHPMOptionalBoolean_NotSet)
		, m_BeforeAMilestone_Enable(EHPMOptionalBoolean_NotSet)
		, m_BeforeAMilestone_nDaysBefore0(0)
		, m_BeforeAMilestone_nDaysBefore1(0)
		, m_BeforeAMilestone_WhenToSend(0)
		, m_ProjectReport_Enable(EHPMOptionalBoolean_NotSet)
		, m_ProjectReport_PeriodicityType(EHPMPeriodicityType_Weekly)
		, m_ProjectReport_WhenToSendWeekDay(0)
		, m_ProjectReport_WhenToSendHourOfDay(0)
		, m_WhenATaskIsCompleted_Enable(EHPMOptionalBoolean_NotSet)
		, m_WhenACommentIsPosted_Enable(EHPMOptionalBoolean_NotSet)
		, m_WhenAPredcessorIsCompleted_Enable(EHPMOptionalBoolean_NotSet)
	{
		m_ProjectReport_SendToEmailsExtra.resize(3);
		m_WhenATaskIsCompleted_SendToEmailsExtra.resize(3);
		m_WhenACommentIsPosted_SendToEmailsExtra.resize(3);
		m_WhenAPredcessorIsCompleted_SendToEmailsExtra.resize(3);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectEmailSettings(HPMProjectEmailSettings const &_Right)
		: m_ResourceScheduleUpdated_Enable(_Right.m_ResourceScheduleUpdated_Enable)
		, m_ResourceScheduleUpdated_nMinutesAfterUpdate(_Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate)
		, m_ResourceScheduleUpdated_bIncludeComment(_Right.m_ResourceScheduleUpdated_bIncludeComment)
		, m_BeforeAMilestone_Enable(_Right.m_BeforeAMilestone_Enable)
		, m_BeforeAMilestone_nDaysBefore0(_Right.m_BeforeAMilestone_nDaysBefore0)
		, m_BeforeAMilestone_nDaysBefore1(_Right.m_BeforeAMilestone_nDaysBefore1)
		, m_BeforeAMilestone_WhenToSend(_Right.m_BeforeAMilestone_WhenToSend)
		, m_ProjectReport_Enable(_Right.m_ProjectReport_Enable)
		, m_ProjectReport_PeriodicityType(_Right.m_ProjectReport_PeriodicityType)
		, m_ProjectReport_WhenToSendWeekDay(_Right.m_ProjectReport_WhenToSendWeekDay)
		, m_ProjectReport_WhenToSendHourOfDay(_Right.m_ProjectReport_WhenToSendHourOfDay)
		, m_ProjectReport_SendToEmailsExtra(_Right.m_ProjectReport_SendToEmailsExtra)
		, m_WhenATaskIsCompleted_Enable(_Right.m_WhenATaskIsCompleted_Enable)
		, m_WhenATaskIsCompleted_SendToEmailsExtra(_Right.m_WhenATaskIsCompleted_SendToEmailsExtra)
		, m_WhenACommentIsPosted_Enable(_Right.m_WhenACommentIsPosted_Enable)
		, m_WhenACommentIsPosted_SendToEmailsExtra(_Right.m_WhenACommentIsPosted_SendToEmailsExtra)
		, m_WhenAPredcessorIsCompleted_Enable(_Right.m_WhenAPredcessorIsCompleted_Enable)
		, m_WhenAPredcessorIsCompleted_SendToEmailsExtra(_Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra)
	{
	}
	HPMProjectEmailSettings(HPMProjectEmailSettings &&_Right)
		: m_ResourceScheduleUpdated_Enable(std::move(_Right.m_ResourceScheduleUpdated_Enable))
		, m_ResourceScheduleUpdated_nMinutesAfterUpdate(std::move(_Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate))
		, m_ResourceScheduleUpdated_bIncludeComment(std::move(_Right.m_ResourceScheduleUpdated_bIncludeComment))
		, m_BeforeAMilestone_Enable(std::move(_Right.m_BeforeAMilestone_Enable))
		, m_BeforeAMilestone_nDaysBefore0(std::move(_Right.m_BeforeAMilestone_nDaysBefore0))
		, m_BeforeAMilestone_nDaysBefore1(std::move(_Right.m_BeforeAMilestone_nDaysBefore1))
		, m_BeforeAMilestone_WhenToSend(std::move(_Right.m_BeforeAMilestone_WhenToSend))
		, m_ProjectReport_Enable(std::move(_Right.m_ProjectReport_Enable))
		, m_ProjectReport_PeriodicityType(std::move(_Right.m_ProjectReport_PeriodicityType))
		, m_ProjectReport_WhenToSendWeekDay(std::move(_Right.m_ProjectReport_WhenToSendWeekDay))
		, m_ProjectReport_WhenToSendHourOfDay(std::move(_Right.m_ProjectReport_WhenToSendHourOfDay))
		, m_ProjectReport_SendToEmailsExtra(std::move(_Right.m_ProjectReport_SendToEmailsExtra))
		, m_WhenATaskIsCompleted_Enable(std::move(_Right.m_WhenATaskIsCompleted_Enable))
		, m_WhenATaskIsCompleted_SendToEmailsExtra(std::move(_Right.m_WhenATaskIsCompleted_SendToEmailsExtra))
		, m_WhenACommentIsPosted_Enable(std::move(_Right.m_WhenACommentIsPosted_Enable))
		, m_WhenACommentIsPosted_SendToEmailsExtra(std::move(_Right.m_WhenACommentIsPosted_SendToEmailsExtra))
		, m_WhenAPredcessorIsCompleted_Enable(std::move(_Right.m_WhenAPredcessorIsCompleted_Enable))
		, m_WhenAPredcessorIsCompleted_SendToEmailsExtra(std::move(_Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra))
	{
	}
	HPMProjectEmailSettings &operator =(HPMProjectEmailSettings const &_Right)
	{
		m_ResourceScheduleUpdated_Enable = _Right.m_ResourceScheduleUpdated_Enable;
		m_ResourceScheduleUpdated_nMinutesAfterUpdate = _Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate;
		m_ResourceScheduleUpdated_bIncludeComment = _Right.m_ResourceScheduleUpdated_bIncludeComment;
		m_BeforeAMilestone_Enable = _Right.m_BeforeAMilestone_Enable;
		m_BeforeAMilestone_nDaysBefore0 = _Right.m_BeforeAMilestone_nDaysBefore0;
		m_BeforeAMilestone_nDaysBefore1 = _Right.m_BeforeAMilestone_nDaysBefore1;
		m_BeforeAMilestone_WhenToSend = _Right.m_BeforeAMilestone_WhenToSend;
		m_ProjectReport_Enable = _Right.m_ProjectReport_Enable;
		m_ProjectReport_PeriodicityType = _Right.m_ProjectReport_PeriodicityType;
		m_ProjectReport_WhenToSendWeekDay = _Right.m_ProjectReport_WhenToSendWeekDay;
		m_ProjectReport_WhenToSendHourOfDay = _Right.m_ProjectReport_WhenToSendHourOfDay;
		m_ProjectReport_SendToEmailsExtra = _Right.m_ProjectReport_SendToEmailsExtra;
		m_WhenATaskIsCompleted_Enable = _Right.m_WhenATaskIsCompleted_Enable;
		m_WhenATaskIsCompleted_SendToEmailsExtra = _Right.m_WhenATaskIsCompleted_SendToEmailsExtra;
		m_WhenACommentIsPosted_Enable = _Right.m_WhenACommentIsPosted_Enable;
		m_WhenACommentIsPosted_SendToEmailsExtra = _Right.m_WhenACommentIsPosted_SendToEmailsExtra;
		m_WhenAPredcessorIsCompleted_Enable = _Right.m_WhenAPredcessorIsCompleted_Enable;
		m_WhenAPredcessorIsCompleted_SendToEmailsExtra = _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra;
		return *this;
	}
	HPMProjectEmailSettings &operator =(HPMProjectEmailSettings &&_Right)
	{
		m_ResourceScheduleUpdated_Enable = std::move(_Right.m_ResourceScheduleUpdated_Enable);
		m_ResourceScheduleUpdated_nMinutesAfterUpdate = std::move(_Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate);
		m_ResourceScheduleUpdated_bIncludeComment = std::move(_Right.m_ResourceScheduleUpdated_bIncludeComment);
		m_BeforeAMilestone_Enable = std::move(_Right.m_BeforeAMilestone_Enable);
		m_BeforeAMilestone_nDaysBefore0 = std::move(_Right.m_BeforeAMilestone_nDaysBefore0);
		m_BeforeAMilestone_nDaysBefore1 = std::move(_Right.m_BeforeAMilestone_nDaysBefore1);
		m_BeforeAMilestone_WhenToSend = std::move(_Right.m_BeforeAMilestone_WhenToSend);
		m_ProjectReport_Enable = std::move(_Right.m_ProjectReport_Enable);
		m_ProjectReport_PeriodicityType = std::move(_Right.m_ProjectReport_PeriodicityType);
		m_ProjectReport_WhenToSendWeekDay = std::move(_Right.m_ProjectReport_WhenToSendWeekDay);
		m_ProjectReport_WhenToSendHourOfDay = std::move(_Right.m_ProjectReport_WhenToSendHourOfDay);
		m_ProjectReport_SendToEmailsExtra = std::move(_Right.m_ProjectReport_SendToEmailsExtra);
		m_WhenATaskIsCompleted_Enable = std::move(_Right.m_WhenATaskIsCompleted_Enable);
		m_WhenATaskIsCompleted_SendToEmailsExtra = std::move(_Right.m_WhenATaskIsCompleted_SendToEmailsExtra);
		m_WhenACommentIsPosted_Enable = std::move(_Right.m_WhenACommentIsPosted_Enable);
		m_WhenACommentIsPosted_SendToEmailsExtra = std::move(_Right.m_WhenACommentIsPosted_SendToEmailsExtra);
		m_WhenAPredcessorIsCompleted_Enable = std::move(_Right.m_WhenAPredcessorIsCompleted_Enable);
		m_WhenAPredcessorIsCompleted_SendToEmailsExtra = std::move(_Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra);
		return *this;
	}
#endif
	bool operator == (const HPMProjectEmailSettings &_Right) const
	{
		if (m_ResourceScheduleUpdated_Enable != _Right.m_ResourceScheduleUpdated_Enable)
			return false;
		if (m_ResourceScheduleUpdated_nMinutesAfterUpdate != _Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate)
			return false;
		if (m_ResourceScheduleUpdated_bIncludeComment != _Right.m_ResourceScheduleUpdated_bIncludeComment)
			return false;
		if (m_BeforeAMilestone_Enable != _Right.m_BeforeAMilestone_Enable)
			return false;
		if (m_BeforeAMilestone_nDaysBefore0 != _Right.m_BeforeAMilestone_nDaysBefore0)
			return false;
		if (m_BeforeAMilestone_nDaysBefore1 != _Right.m_BeforeAMilestone_nDaysBefore1)
			return false;
		if (m_BeforeAMilestone_WhenToSend != _Right.m_BeforeAMilestone_WhenToSend)
			return false;
		if (m_ProjectReport_Enable != _Right.m_ProjectReport_Enable)
			return false;
		if (m_ProjectReport_PeriodicityType != _Right.m_ProjectReport_PeriodicityType)
			return false;
		if (m_ProjectReport_WhenToSendWeekDay != _Right.m_ProjectReport_WhenToSendWeekDay)
			return false;
		if (m_ProjectReport_WhenToSendHourOfDay != _Right.m_ProjectReport_WhenToSendHourOfDay)
			return false;
		if (m_ProjectReport_SendToEmailsExtra.size() != _Right.m_ProjectReport_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_ProjectReport_SendToEmailsExtra.size(); ++i)
			if (m_ProjectReport_SendToEmailsExtra[i] != _Right.m_ProjectReport_SendToEmailsExtra[i])
				return false;
		if (m_WhenATaskIsCompleted_Enable != _Right.m_WhenATaskIsCompleted_Enable)
			return false;
		if (m_WhenATaskIsCompleted_SendToEmailsExtra.size() != _Right.m_WhenATaskIsCompleted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenATaskIsCompleted_SendToEmailsExtra.size(); ++i)
			if (m_WhenATaskIsCompleted_SendToEmailsExtra[i] != _Right.m_WhenATaskIsCompleted_SendToEmailsExtra[i])
				return false;
		if (m_WhenACommentIsPosted_Enable != _Right.m_WhenACommentIsPosted_Enable)
			return false;
		if (m_WhenACommentIsPosted_SendToEmailsExtra.size() != _Right.m_WhenACommentIsPosted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenACommentIsPosted_SendToEmailsExtra.size(); ++i)
			if (m_WhenACommentIsPosted_SendToEmailsExtra[i] != _Right.m_WhenACommentIsPosted_SendToEmailsExtra[i])
				return false;
		if (m_WhenAPredcessorIsCompleted_Enable != _Right.m_WhenAPredcessorIsCompleted_Enable)
			return false;
		if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size() != _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size(); ++i)
			if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i] != _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectEmailSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectEmailSettings &_Right) const
	{
		if (m_ResourceScheduleUpdated_Enable < _Right.m_ResourceScheduleUpdated_Enable)
			return true;
		if (m_ResourceScheduleUpdated_Enable > _Right.m_ResourceScheduleUpdated_Enable)
			return false;
		if (m_ResourceScheduleUpdated_nMinutesAfterUpdate < _Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate)
			return true;
		if (m_ResourceScheduleUpdated_nMinutesAfterUpdate > _Right.m_ResourceScheduleUpdated_nMinutesAfterUpdate)
			return false;
		if (m_ResourceScheduleUpdated_bIncludeComment < _Right.m_ResourceScheduleUpdated_bIncludeComment)
			return true;
		if (m_ResourceScheduleUpdated_bIncludeComment > _Right.m_ResourceScheduleUpdated_bIncludeComment)
			return false;
		if (m_BeforeAMilestone_Enable < _Right.m_BeforeAMilestone_Enable)
			return true;
		if (m_BeforeAMilestone_Enable > _Right.m_BeforeAMilestone_Enable)
			return false;
		if (m_BeforeAMilestone_nDaysBefore0 < _Right.m_BeforeAMilestone_nDaysBefore0)
			return true;
		if (m_BeforeAMilestone_nDaysBefore0 > _Right.m_BeforeAMilestone_nDaysBefore0)
			return false;
		if (m_BeforeAMilestone_nDaysBefore1 < _Right.m_BeforeAMilestone_nDaysBefore1)
			return true;
		if (m_BeforeAMilestone_nDaysBefore1 > _Right.m_BeforeAMilestone_nDaysBefore1)
			return false;
		if (m_BeforeAMilestone_WhenToSend < _Right.m_BeforeAMilestone_WhenToSend)
			return true;
		if (m_BeforeAMilestone_WhenToSend > _Right.m_BeforeAMilestone_WhenToSend)
			return false;
		if (m_ProjectReport_Enable < _Right.m_ProjectReport_Enable)
			return true;
		if (m_ProjectReport_Enable > _Right.m_ProjectReport_Enable)
			return false;
		if (m_ProjectReport_PeriodicityType < _Right.m_ProjectReport_PeriodicityType)
			return true;
		if (m_ProjectReport_PeriodicityType > _Right.m_ProjectReport_PeriodicityType)
			return false;
		if (m_ProjectReport_WhenToSendWeekDay < _Right.m_ProjectReport_WhenToSendWeekDay)
			return true;
		if (m_ProjectReport_WhenToSendWeekDay > _Right.m_ProjectReport_WhenToSendWeekDay)
			return false;
		if (m_ProjectReport_WhenToSendHourOfDay < _Right.m_ProjectReport_WhenToSendHourOfDay)
			return true;
		if (m_ProjectReport_WhenToSendHourOfDay > _Right.m_ProjectReport_WhenToSendHourOfDay)
			return false;
		if (m_ProjectReport_SendToEmailsExtra.size() < _Right.m_ProjectReport_SendToEmailsExtra.size())
			return true;
		if (m_ProjectReport_SendToEmailsExtra.size() > _Right.m_ProjectReport_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_ProjectReport_SendToEmailsExtra.size(); ++i)
		{
			if (m_ProjectReport_SendToEmailsExtra[i] < _Right.m_ProjectReport_SendToEmailsExtra[i])
				return true;
			if (m_ProjectReport_SendToEmailsExtra[i] > _Right.m_ProjectReport_SendToEmailsExtra[i])
				return false;
		}
		if (m_WhenATaskIsCompleted_Enable < _Right.m_WhenATaskIsCompleted_Enable)
			return true;
		if (m_WhenATaskIsCompleted_Enable > _Right.m_WhenATaskIsCompleted_Enable)
			return false;
		if (m_WhenATaskIsCompleted_SendToEmailsExtra.size() < _Right.m_WhenATaskIsCompleted_SendToEmailsExtra.size())
			return true;
		if (m_WhenATaskIsCompleted_SendToEmailsExtra.size() > _Right.m_WhenATaskIsCompleted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenATaskIsCompleted_SendToEmailsExtra.size(); ++i)
		{
			if (m_WhenATaskIsCompleted_SendToEmailsExtra[i] < _Right.m_WhenATaskIsCompleted_SendToEmailsExtra[i])
				return true;
			if (m_WhenATaskIsCompleted_SendToEmailsExtra[i] > _Right.m_WhenATaskIsCompleted_SendToEmailsExtra[i])
				return false;
		}
		if (m_WhenACommentIsPosted_Enable < _Right.m_WhenACommentIsPosted_Enable)
			return true;
		if (m_WhenACommentIsPosted_Enable > _Right.m_WhenACommentIsPosted_Enable)
			return false;
		if (m_WhenACommentIsPosted_SendToEmailsExtra.size() < _Right.m_WhenACommentIsPosted_SendToEmailsExtra.size())
			return true;
		if (m_WhenACommentIsPosted_SendToEmailsExtra.size() > _Right.m_WhenACommentIsPosted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenACommentIsPosted_SendToEmailsExtra.size(); ++i)
		{
			if (m_WhenACommentIsPosted_SendToEmailsExtra[i] < _Right.m_WhenACommentIsPosted_SendToEmailsExtra[i])
				return true;
			if (m_WhenACommentIsPosted_SendToEmailsExtra[i] > _Right.m_WhenACommentIsPosted_SendToEmailsExtra[i])
				return false;
		}
		if (m_WhenAPredcessorIsCompleted_Enable < _Right.m_WhenAPredcessorIsCompleted_Enable)
			return true;
		if (m_WhenAPredcessorIsCompleted_Enable > _Right.m_WhenAPredcessorIsCompleted_Enable)
			return false;
		if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size() < _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size())
			return true;
		if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size() > _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size())
			return false;
		for (size_t i = 0; i < m_WhenAPredcessorIsCompleted_SendToEmailsExtra.size(); ++i)
		{
			if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i] < _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i])
				return true;
			if (m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i] > _Right.m_WhenAPredcessorIsCompleted_SendToEmailsExtra[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectEmailSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectEmailSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectEmailSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowRequiredField
{
	public:
	EHPMProjectWorkflowRequiredFieldType m_Type;
	HPMInt32 m_ID;
	HPMProjectWorkflowRequiredField()
		: m_Type(EHPMProjectWorkflowRequiredFieldType_CustomColumn)
		, m_ID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowRequiredField(HPMProjectWorkflowRequiredField const &_Right)
		: m_Type(_Right.m_Type)
		, m_ID(_Right.m_ID)
	{
	}
	HPMProjectWorkflowRequiredField(HPMProjectWorkflowRequiredField &&_Right)
		: m_Type(std::move(_Right.m_Type))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMProjectWorkflowRequiredField &operator =(HPMProjectWorkflowRequiredField const &_Right)
	{
		m_Type = _Right.m_Type;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMProjectWorkflowRequiredField &operator =(HPMProjectWorkflowRequiredField &&_Right)
	{
		m_Type = std::move(_Right.m_Type);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowRequiredField &_Right) const
	{
		if (m_Type != _Right.m_Type)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowRequiredField &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowRequiredField &_Right) const
	{
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowRequiredField &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowRequiredField &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowRequiredField &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowConnection
{
	public:
	HPMUInt32 m_ConnectedToUID;
	EHPMProjectWorkflowConnectionSite m_ConnectFrom;
	EHPMProjectWorkflowConnectionSite m_ConnectTo;
	HPMProjectWorkflowConnection()
		: m_ConnectedToUID(0)
		, m_ConnectFrom(EHPMProjectWorkflowConnectionSite_NewVersionOfSDKRequired)
		, m_ConnectTo(EHPMProjectWorkflowConnectionSite_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowConnection(HPMProjectWorkflowConnection const &_Right)
		: m_ConnectedToUID(_Right.m_ConnectedToUID)
		, m_ConnectFrom(_Right.m_ConnectFrom)
		, m_ConnectTo(_Right.m_ConnectTo)
	{
	}
	HPMProjectWorkflowConnection(HPMProjectWorkflowConnection &&_Right)
		: m_ConnectedToUID(std::move(_Right.m_ConnectedToUID))
		, m_ConnectFrom(std::move(_Right.m_ConnectFrom))
		, m_ConnectTo(std::move(_Right.m_ConnectTo))
	{
	}
	HPMProjectWorkflowConnection &operator =(HPMProjectWorkflowConnection const &_Right)
	{
		m_ConnectedToUID = _Right.m_ConnectedToUID;
		m_ConnectFrom = _Right.m_ConnectFrom;
		m_ConnectTo = _Right.m_ConnectTo;
		return *this;
	}
	HPMProjectWorkflowConnection &operator =(HPMProjectWorkflowConnection &&_Right)
	{
		m_ConnectedToUID = std::move(_Right.m_ConnectedToUID);
		m_ConnectFrom = std::move(_Right.m_ConnectFrom);
		m_ConnectTo = std::move(_Right.m_ConnectTo);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowConnection &_Right) const
	{
		if (m_ConnectedToUID != _Right.m_ConnectedToUID)
			return false;
		if (m_ConnectFrom != _Right.m_ConnectFrom)
			return false;
		if (m_ConnectTo != _Right.m_ConnectTo)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowConnection &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowConnection &_Right) const
	{
		if (m_ConnectedToUID < _Right.m_ConnectedToUID)
			return true;
		if (m_ConnectedToUID > _Right.m_ConnectedToUID)
			return false;
		if (m_ConnectFrom < _Right.m_ConnectFrom)
			return true;
		if (m_ConnectFrom > _Right.m_ConnectFrom)
			return false;
		if (m_ConnectTo < _Right.m_ConnectTo)
			return true;
		if (m_ConnectTo > _Right.m_ConnectTo)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowConnection &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowConnection &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowConnection &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMWorkflowStatusChange
{
	public:
	EHPMTaskStatus m_ItemStatus;
	HPMUInt32 m_GotoStatus;
	HPMWorkflowStatusChange()
		: m_ItemStatus(EHPMTaskStatus_NoStatus)
		, m_GotoStatus(-1)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMWorkflowStatusChange(HPMWorkflowStatusChange const &_Right)
		: m_ItemStatus(_Right.m_ItemStatus)
		, m_GotoStatus(_Right.m_GotoStatus)
	{
	}
	HPMWorkflowStatusChange(HPMWorkflowStatusChange &&_Right)
		: m_ItemStatus(std::move(_Right.m_ItemStatus))
		, m_GotoStatus(std::move(_Right.m_GotoStatus))
	{
	}
	HPMWorkflowStatusChange &operator =(HPMWorkflowStatusChange const &_Right)
	{
		m_ItemStatus = _Right.m_ItemStatus;
		m_GotoStatus = _Right.m_GotoStatus;
		return *this;
	}
	HPMWorkflowStatusChange &operator =(HPMWorkflowStatusChange &&_Right)
	{
		m_ItemStatus = std::move(_Right.m_ItemStatus);
		m_GotoStatus = std::move(_Right.m_GotoStatus);
		return *this;
	}
#endif
	bool operator == (const HPMWorkflowStatusChange &_Right) const
	{
		if (m_ItemStatus != _Right.m_ItemStatus)
			return false;
		if (m_GotoStatus != _Right.m_GotoStatus)
			return false;
		return true;
	}
	bool operator != (const HPMWorkflowStatusChange &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMWorkflowStatusChange &_Right) const
	{
		if (m_ItemStatus < _Right.m_ItemStatus)
			return true;
		if (m_ItemStatus > _Right.m_ItemStatus)
			return false;
		if (m_GotoStatus < _Right.m_GotoStatus)
			return true;
		if (m_GotoStatus > _Right.m_GotoStatus)
			return false;
		return false;
	}
	bool operator > (const HPMWorkflowStatusChange &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMWorkflowStatusChange &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMWorkflowStatusChange &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowObject
{
	public:
	HPMUInt32 m_ObjectID;
	EHPMProjectWorkflowObjectType m_ObjectType;
	HPMInt32 m_PositionX;
	HPMInt32 m_PositionY;
	std::vector<HPMResourceDefinition> m_Resources;
	std::vector<HPMProjectWorkflowConnection> m_ConnectedToObjects;
	EHPMProjectWorkflowObjectFlag m_Flags;
	std::vector<HPMProjectWorkflowRequiredField> m_RequiredFields;
	HPMUntranslatedString m_WorkflowStatus_Name;
	HPMUInt32 m_WorkflowStatus_GoToWorkflowStatusWhenAssigned;
	std::vector<HPMWorkflowStatusChange> m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet;
	HPMUInt32 m_WorkflowStatus_AssignToResourcesAssignedInThisStatus;
	EHPMListIcon m_WorkflowStatus_Icon;
	std::vector<HPMResourceDefinition> m_WorkflowStatus_EmailNotifications;
	std::vector<HPMTaskFieldData> m_WorkflowStatus_DefaultTaskValues;
	HPMUInt32 m_WorkflowStatus_SelectedWorklfowID;
	HPMInt32 m_TaktTimeDays;
	HPMInt32 m_TaktTimeHours;
	HPMInt32 m_MaxWIPItems;
	HPMProjectWorkflowObject()
		: m_ObjectID(1)
		, m_ObjectType(EHPMProjectWorkflowObjectType_WorkflowStatus)
		, m_PositionX(500)
		, m_PositionY(500)
		, m_Flags(EHPMProjectWorkflowObjectFlag_None)
		, m_WorkflowStatus_GoToWorkflowStatusWhenAssigned(0)
		, m_WorkflowStatus_AssignToResourcesAssignedInThisStatus(0)
		, m_WorkflowStatus_Icon(EHPMListIcon_Default)
		, m_WorkflowStatus_SelectedWorklfowID(0)
		, m_TaktTimeDays(0)
		, m_TaktTimeHours(0)
		, m_MaxWIPItems(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowObject(HPMProjectWorkflowObject const &_Right)
		: m_ObjectID(_Right.m_ObjectID)
		, m_ObjectType(_Right.m_ObjectType)
		, m_PositionX(_Right.m_PositionX)
		, m_PositionY(_Right.m_PositionY)
		, m_Resources(_Right.m_Resources)
		, m_ConnectedToObjects(_Right.m_ConnectedToObjects)
		, m_Flags(_Right.m_Flags)
		, m_RequiredFields(_Right.m_RequiredFields)
		, m_WorkflowStatus_Name(_Right.m_WorkflowStatus_Name)
		, m_WorkflowStatus_GoToWorkflowStatusWhenAssigned(_Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned)
		, m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet(_Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet)
		, m_WorkflowStatus_AssignToResourcesAssignedInThisStatus(_Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus)
		, m_WorkflowStatus_Icon(_Right.m_WorkflowStatus_Icon)
		, m_WorkflowStatus_EmailNotifications(_Right.m_WorkflowStatus_EmailNotifications)
		, m_WorkflowStatus_DefaultTaskValues(_Right.m_WorkflowStatus_DefaultTaskValues)
		, m_WorkflowStatus_SelectedWorklfowID(_Right.m_WorkflowStatus_SelectedWorklfowID)
		, m_TaktTimeDays(_Right.m_TaktTimeDays)
		, m_TaktTimeHours(_Right.m_TaktTimeHours)
		, m_MaxWIPItems(_Right.m_MaxWIPItems)
	{
	}
	HPMProjectWorkflowObject(HPMProjectWorkflowObject &&_Right)
		: m_ObjectID(std::move(_Right.m_ObjectID))
		, m_ObjectType(std::move(_Right.m_ObjectType))
		, m_PositionX(std::move(_Right.m_PositionX))
		, m_PositionY(std::move(_Right.m_PositionY))
		, m_Resources(std::move(_Right.m_Resources))
		, m_ConnectedToObjects(std::move(_Right.m_ConnectedToObjects))
		, m_Flags(std::move(_Right.m_Flags))
		, m_RequiredFields(std::move(_Right.m_RequiredFields))
		, m_WorkflowStatus_Name(std::move(_Right.m_WorkflowStatus_Name))
		, m_WorkflowStatus_GoToWorkflowStatusWhenAssigned(std::move(_Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned))
		, m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet(std::move(_Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet))
		, m_WorkflowStatus_AssignToResourcesAssignedInThisStatus(std::move(_Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus))
		, m_WorkflowStatus_Icon(std::move(_Right.m_WorkflowStatus_Icon))
		, m_WorkflowStatus_EmailNotifications(std::move(_Right.m_WorkflowStatus_EmailNotifications))
		, m_WorkflowStatus_DefaultTaskValues(std::move(_Right.m_WorkflowStatus_DefaultTaskValues))
		, m_WorkflowStatus_SelectedWorklfowID(std::move(_Right.m_WorkflowStatus_SelectedWorklfowID))
		, m_TaktTimeDays(std::move(_Right.m_TaktTimeDays))
		, m_TaktTimeHours(std::move(_Right.m_TaktTimeHours))
		, m_MaxWIPItems(std::move(_Right.m_MaxWIPItems))
	{
	}
	HPMProjectWorkflowObject &operator =(HPMProjectWorkflowObject const &_Right)
	{
		m_ObjectID = _Right.m_ObjectID;
		m_ObjectType = _Right.m_ObjectType;
		m_PositionX = _Right.m_PositionX;
		m_PositionY = _Right.m_PositionY;
		m_Resources = _Right.m_Resources;
		m_ConnectedToObjects = _Right.m_ConnectedToObjects;
		m_Flags = _Right.m_Flags;
		m_RequiredFields = _Right.m_RequiredFields;
		m_WorkflowStatus_Name = _Right.m_WorkflowStatus_Name;
		m_WorkflowStatus_GoToWorkflowStatusWhenAssigned = _Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned;
		m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet = _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet;
		m_WorkflowStatus_AssignToResourcesAssignedInThisStatus = _Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus;
		m_WorkflowStatus_Icon = _Right.m_WorkflowStatus_Icon;
		m_WorkflowStatus_EmailNotifications = _Right.m_WorkflowStatus_EmailNotifications;
		m_WorkflowStatus_DefaultTaskValues = _Right.m_WorkflowStatus_DefaultTaskValues;
		m_WorkflowStatus_SelectedWorklfowID = _Right.m_WorkflowStatus_SelectedWorklfowID;
		m_TaktTimeDays = _Right.m_TaktTimeDays;
		m_TaktTimeHours = _Right.m_TaktTimeHours;
		m_MaxWIPItems = _Right.m_MaxWIPItems;
		return *this;
	}
	HPMProjectWorkflowObject &operator =(HPMProjectWorkflowObject &&_Right)
	{
		m_ObjectID = std::move(_Right.m_ObjectID);
		m_ObjectType = std::move(_Right.m_ObjectType);
		m_PositionX = std::move(_Right.m_PositionX);
		m_PositionY = std::move(_Right.m_PositionY);
		m_Resources = std::move(_Right.m_Resources);
		m_ConnectedToObjects = std::move(_Right.m_ConnectedToObjects);
		m_Flags = std::move(_Right.m_Flags);
		m_RequiredFields = std::move(_Right.m_RequiredFields);
		m_WorkflowStatus_Name = std::move(_Right.m_WorkflowStatus_Name);
		m_WorkflowStatus_GoToWorkflowStatusWhenAssigned = std::move(_Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned);
		m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet = std::move(_Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet);
		m_WorkflowStatus_AssignToResourcesAssignedInThisStatus = std::move(_Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus);
		m_WorkflowStatus_Icon = std::move(_Right.m_WorkflowStatus_Icon);
		m_WorkflowStatus_EmailNotifications = std::move(_Right.m_WorkflowStatus_EmailNotifications);
		m_WorkflowStatus_DefaultTaskValues = std::move(_Right.m_WorkflowStatus_DefaultTaskValues);
		m_WorkflowStatus_SelectedWorklfowID = std::move(_Right.m_WorkflowStatus_SelectedWorklfowID);
		m_TaktTimeDays = std::move(_Right.m_TaktTimeDays);
		m_TaktTimeHours = std::move(_Right.m_TaktTimeHours);
		m_MaxWIPItems = std::move(_Right.m_MaxWIPItems);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowObject &_Right) const
	{
		if (m_ObjectID != _Right.m_ObjectID)
			return false;
		if (m_ObjectType != _Right.m_ObjectType)
			return false;
		if (m_PositionX != _Right.m_PositionX)
			return false;
		if (m_PositionY != _Right.m_PositionY)
			return false;
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		if (m_ConnectedToObjects.size() != _Right.m_ConnectedToObjects.size())
			return false;
		for (size_t i = 0; i < m_ConnectedToObjects.size(); ++i)
			if (m_ConnectedToObjects[i] != _Right.m_ConnectedToObjects[i])
				return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_RequiredFields.size() != _Right.m_RequiredFields.size())
			return false;
		for (size_t i = 0; i < m_RequiredFields.size(); ++i)
			if (m_RequiredFields[i] != _Right.m_RequiredFields[i])
				return false;
		if (m_WorkflowStatus_Name != _Right.m_WorkflowStatus_Name)
			return false;
		if (m_WorkflowStatus_GoToWorkflowStatusWhenAssigned != _Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned)
			return false;
		if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size() != _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size(); ++i)
			if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i] != _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i])
				return false;
		if (m_WorkflowStatus_AssignToResourcesAssignedInThisStatus != _Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus)
			return false;
		if (m_WorkflowStatus_Icon != _Right.m_WorkflowStatus_Icon)
			return false;
		if (m_WorkflowStatus_EmailNotifications.size() != _Right.m_WorkflowStatus_EmailNotifications.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_EmailNotifications.size(); ++i)
			if (m_WorkflowStatus_EmailNotifications[i] != _Right.m_WorkflowStatus_EmailNotifications[i])
				return false;
		if (m_WorkflowStatus_DefaultTaskValues.size() != _Right.m_WorkflowStatus_DefaultTaskValues.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_DefaultTaskValues.size(); ++i)
			if (m_WorkflowStatus_DefaultTaskValues[i] != _Right.m_WorkflowStatus_DefaultTaskValues[i])
				return false;
		if (m_WorkflowStatus_SelectedWorklfowID != _Right.m_WorkflowStatus_SelectedWorklfowID)
			return false;
		if (m_TaktTimeDays != _Right.m_TaktTimeDays)
			return false;
		if (m_TaktTimeHours != _Right.m_TaktTimeHours)
			return false;
		if (m_MaxWIPItems != _Right.m_MaxWIPItems)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowObject &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowObject &_Right) const
	{
		if (m_ObjectID < _Right.m_ObjectID)
			return true;
		if (m_ObjectID > _Right.m_ObjectID)
			return false;
		if (m_ObjectType < _Right.m_ObjectType)
			return true;
		if (m_ObjectType > _Right.m_ObjectType)
			return false;
		if (m_PositionX < _Right.m_PositionX)
			return true;
		if (m_PositionX > _Right.m_PositionX)
			return false;
		if (m_PositionY < _Right.m_PositionY)
			return true;
		if (m_PositionY > _Right.m_PositionY)
			return false;
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		if (m_ConnectedToObjects.size() < _Right.m_ConnectedToObjects.size())
			return true;
		if (m_ConnectedToObjects.size() > _Right.m_ConnectedToObjects.size())
			return false;
		for (size_t i = 0; i < m_ConnectedToObjects.size(); ++i)
		{
			if (m_ConnectedToObjects[i] < _Right.m_ConnectedToObjects[i])
				return true;
			if (m_ConnectedToObjects[i] > _Right.m_ConnectedToObjects[i])
				return false;
		}
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_RequiredFields.size() < _Right.m_RequiredFields.size())
			return true;
		if (m_RequiredFields.size() > _Right.m_RequiredFields.size())
			return false;
		for (size_t i = 0; i < m_RequiredFields.size(); ++i)
		{
			if (m_RequiredFields[i] < _Right.m_RequiredFields[i])
				return true;
			if (m_RequiredFields[i] > _Right.m_RequiredFields[i])
				return false;
		}
		if (m_WorkflowStatus_Name < _Right.m_WorkflowStatus_Name)
			return true;
		if (m_WorkflowStatus_Name > _Right.m_WorkflowStatus_Name)
			return false;
		if (m_WorkflowStatus_GoToWorkflowStatusWhenAssigned < _Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned)
			return true;
		if (m_WorkflowStatus_GoToWorkflowStatusWhenAssigned > _Right.m_WorkflowStatus_GoToWorkflowStatusWhenAssigned)
			return false;
		if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size() < _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size())
			return true;
		if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size() > _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet.size(); ++i)
		{
			if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i] < _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i])
				return true;
			if (m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i] > _Right.m_WorkflowStatus_GotoWorkflowStatusWhenItemStatusSet[i])
				return false;
		}
		if (m_WorkflowStatus_AssignToResourcesAssignedInThisStatus < _Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus)
			return true;
		if (m_WorkflowStatus_AssignToResourcesAssignedInThisStatus > _Right.m_WorkflowStatus_AssignToResourcesAssignedInThisStatus)
			return false;
		if (m_WorkflowStatus_Icon < _Right.m_WorkflowStatus_Icon)
			return true;
		if (m_WorkflowStatus_Icon > _Right.m_WorkflowStatus_Icon)
			return false;
		if (m_WorkflowStatus_EmailNotifications.size() < _Right.m_WorkflowStatus_EmailNotifications.size())
			return true;
		if (m_WorkflowStatus_EmailNotifications.size() > _Right.m_WorkflowStatus_EmailNotifications.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_EmailNotifications.size(); ++i)
		{
			if (m_WorkflowStatus_EmailNotifications[i] < _Right.m_WorkflowStatus_EmailNotifications[i])
				return true;
			if (m_WorkflowStatus_EmailNotifications[i] > _Right.m_WorkflowStatus_EmailNotifications[i])
				return false;
		}
		if (m_WorkflowStatus_DefaultTaskValues.size() < _Right.m_WorkflowStatus_DefaultTaskValues.size())
			return true;
		if (m_WorkflowStatus_DefaultTaskValues.size() > _Right.m_WorkflowStatus_DefaultTaskValues.size())
			return false;
		for (size_t i = 0; i < m_WorkflowStatus_DefaultTaskValues.size(); ++i)
		{
			if (m_WorkflowStatus_DefaultTaskValues[i] < _Right.m_WorkflowStatus_DefaultTaskValues[i])
				return true;
			if (m_WorkflowStatus_DefaultTaskValues[i] > _Right.m_WorkflowStatus_DefaultTaskValues[i])
				return false;
		}
		if (m_WorkflowStatus_SelectedWorklfowID < _Right.m_WorkflowStatus_SelectedWorklfowID)
			return true;
		if (m_WorkflowStatus_SelectedWorklfowID > _Right.m_WorkflowStatus_SelectedWorklfowID)
			return false;
		if (m_TaktTimeDays < _Right.m_TaktTimeDays)
			return true;
		if (m_TaktTimeDays > _Right.m_TaktTimeDays)
			return false;
		if (m_TaktTimeHours < _Right.m_TaktTimeHours)
			return true;
		if (m_TaktTimeHours > _Right.m_TaktTimeHours)
			return false;
		if (m_MaxWIPItems < _Right.m_MaxWIPItems)
			return true;
		if (m_MaxWIPItems > _Right.m_MaxWIPItems)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowObject &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowObject &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowObject &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowProperties
{
	public:
	HPMString m_Name;
	EHPMWorkflowType m_WorkflowType;
	EHPMListIcon m_Icon;
	HPMProjectWorkflowProperties()
		: m_WorkflowType(EHPMWorkflowType_Workflow)
		, m_Icon(EHPMListIcon_Default)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowProperties(HPMProjectWorkflowProperties const &_Right)
		: m_Name(_Right.m_Name)
		, m_WorkflowType(_Right.m_WorkflowType)
		, m_Icon(_Right.m_Icon)
	{
	}
	HPMProjectWorkflowProperties(HPMProjectWorkflowProperties &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_WorkflowType(std::move(_Right.m_WorkflowType))
		, m_Icon(std::move(_Right.m_Icon))
	{
	}
	HPMProjectWorkflowProperties &operator =(HPMProjectWorkflowProperties const &_Right)
	{
		m_Name = _Right.m_Name;
		m_WorkflowType = _Right.m_WorkflowType;
		m_Icon = _Right.m_Icon;
		return *this;
	}
	HPMProjectWorkflowProperties &operator =(HPMProjectWorkflowProperties &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_WorkflowType = std::move(_Right.m_WorkflowType);
		m_Icon = std::move(_Right.m_Icon);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowProperties &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_WorkflowType != _Right.m_WorkflowType)
			return false;
		if (m_Icon != _Right.m_Icon)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowProperties &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_WorkflowType < _Right.m_WorkflowType)
			return true;
		if (m_WorkflowType > _Right.m_WorkflowType)
			return false;
		if (m_Icon < _Right.m_Icon)
			return true;
		if (m_Icon > _Right.m_Icon)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowSettings
{
	public:
	HPMUInt32 m_Identifier;
	HPMUInt32 m_NewestWorkflowVersionID;
	EHPMProjectWorkflowContainerFlag m_Flags;
	HPMProjectWorkflowProperties m_Properties;
	HPMUniqueID m_CreatedByResource;
	HPMResourceDefinitionList m_ResourceList;
	std::vector<HPMProjectWorkflowObject> m_WorkflowObjects;
	HPMProjectWorkflowSettings()
		: m_Identifier(1)
		, m_NewestWorkflowVersionID(0xffffffff)
		, m_Flags(EHPMProjectWorkflowContainerFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowSettings(HPMProjectWorkflowSettings const &_Right)
		: m_Identifier(_Right.m_Identifier)
		, m_NewestWorkflowVersionID(_Right.m_NewestWorkflowVersionID)
		, m_Flags(_Right.m_Flags)
		, m_Properties(_Right.m_Properties)
		, m_CreatedByResource(_Right.m_CreatedByResource)
		, m_ResourceList(_Right.m_ResourceList)
		, m_WorkflowObjects(_Right.m_WorkflowObjects)
	{
	}
	HPMProjectWorkflowSettings(HPMProjectWorkflowSettings &&_Right)
		: m_Identifier(std::move(_Right.m_Identifier))
		, m_NewestWorkflowVersionID(std::move(_Right.m_NewestWorkflowVersionID))
		, m_Flags(std::move(_Right.m_Flags))
		, m_Properties(std::move(_Right.m_Properties))
		, m_CreatedByResource(std::move(_Right.m_CreatedByResource))
		, m_ResourceList(std::move(_Right.m_ResourceList))
		, m_WorkflowObjects(std::move(_Right.m_WorkflowObjects))
	{
	}
	HPMProjectWorkflowSettings &operator =(HPMProjectWorkflowSettings const &_Right)
	{
		m_Identifier = _Right.m_Identifier;
		m_NewestWorkflowVersionID = _Right.m_NewestWorkflowVersionID;
		m_Flags = _Right.m_Flags;
		m_Properties = _Right.m_Properties;
		m_CreatedByResource = _Right.m_CreatedByResource;
		m_ResourceList = _Right.m_ResourceList;
		m_WorkflowObjects = _Right.m_WorkflowObjects;
		return *this;
	}
	HPMProjectWorkflowSettings &operator =(HPMProjectWorkflowSettings &&_Right)
	{
		m_Identifier = std::move(_Right.m_Identifier);
		m_NewestWorkflowVersionID = std::move(_Right.m_NewestWorkflowVersionID);
		m_Flags = std::move(_Right.m_Flags);
		m_Properties = std::move(_Right.m_Properties);
		m_CreatedByResource = std::move(_Right.m_CreatedByResource);
		m_ResourceList = std::move(_Right.m_ResourceList);
		m_WorkflowObjects = std::move(_Right.m_WorkflowObjects);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowSettings &_Right) const
	{
		if (m_Identifier != _Right.m_Identifier)
			return false;
		if (m_NewestWorkflowVersionID != _Right.m_NewestWorkflowVersionID)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_Properties != _Right.m_Properties)
			return false;
		if (m_CreatedByResource != _Right.m_CreatedByResource)
			return false;
		if (m_ResourceList != _Right.m_ResourceList)
			return false;
		if (m_WorkflowObjects.size() != _Right.m_WorkflowObjects.size())
			return false;
		for (size_t i = 0; i < m_WorkflowObjects.size(); ++i)
			if (m_WorkflowObjects[i] != _Right.m_WorkflowObjects[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowSettings &_Right) const
	{
		if (m_Identifier < _Right.m_Identifier)
			return true;
		if (m_Identifier > _Right.m_Identifier)
			return false;
		if (m_NewestWorkflowVersionID < _Right.m_NewestWorkflowVersionID)
			return true;
		if (m_NewestWorkflowVersionID > _Right.m_NewestWorkflowVersionID)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_Properties < _Right.m_Properties)
			return true;
		if (m_Properties > _Right.m_Properties)
			return false;
		if (m_CreatedByResource < _Right.m_CreatedByResource)
			return true;
		if (m_CreatedByResource > _Right.m_CreatedByResource)
			return false;
		if (m_ResourceList < _Right.m_ResourceList)
			return true;
		if (m_ResourceList > _Right.m_ResourceList)
			return false;
		if (m_WorkflowObjects.size() < _Right.m_WorkflowObjects.size())
			return true;
		if (m_WorkflowObjects.size() > _Right.m_WorkflowObjects.size())
			return false;
		for (size_t i = 0; i < m_WorkflowObjects.size(); ++i)
		{
			if (m_WorkflowObjects[i] < _Right.m_WorkflowObjects[i])
				return true;
			if (m_WorkflowObjects[i] > _Right.m_WorkflowObjects[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflowSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflows
{
	public:
	std::vector<HPMProjectWorkflowSettings> m_Workflows;
	HPMProjectWorkflows()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflows(HPMProjectWorkflows const &_Right)
		: m_Workflows(_Right.m_Workflows)
	{
	}
	HPMProjectWorkflows(HPMProjectWorkflows &&_Right)
		: m_Workflows(std::move(_Right.m_Workflows))
	{
	}
	HPMProjectWorkflows &operator =(HPMProjectWorkflows const &_Right)
	{
		m_Workflows = _Right.m_Workflows;
		return *this;
	}
	HPMProjectWorkflows &operator =(HPMProjectWorkflows &&_Right)
	{
		m_Workflows = std::move(_Right.m_Workflows);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflows &_Right) const
	{
		if (m_Workflows.size() != _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
			if (m_Workflows[i] != _Right.m_Workflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflows &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflows &_Right) const
	{
		if (m_Workflows.size() < _Right.m_Workflows.size())
			return true;
		if (m_Workflows.size() > _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
		{
			if (m_Workflows[i] < _Right.m_Workflows[i])
				return true;
			if (m_Workflows[i] > _Right.m_Workflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflows &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflows &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflows &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWallSettings
{
	public:
	EHPMProjectWallSettingsFlags m_Flags;
	std::vector<HPMColumn> m_ShowTaskColumns;
	HPMProjectWallSettings()
		: m_Flags(EHPMProjectWallSettingsFlags_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWallSettings(HPMProjectWallSettings const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_ShowTaskColumns(_Right.m_ShowTaskColumns)
	{
	}
	HPMProjectWallSettings(HPMProjectWallSettings &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_ShowTaskColumns(std::move(_Right.m_ShowTaskColumns))
	{
	}
	HPMProjectWallSettings &operator =(HPMProjectWallSettings const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_ShowTaskColumns = _Right.m_ShowTaskColumns;
		return *this;
	}
	HPMProjectWallSettings &operator =(HPMProjectWallSettings &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_ShowTaskColumns = std::move(_Right.m_ShowTaskColumns);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWallSettings &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_ShowTaskColumns.size() != _Right.m_ShowTaskColumns.size())
			return false;
		for (size_t i = 0; i < m_ShowTaskColumns.size(); ++i)
			if (m_ShowTaskColumns[i] != _Right.m_ShowTaskColumns[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWallSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWallSettings &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_ShowTaskColumns.size() < _Right.m_ShowTaskColumns.size())
			return true;
		if (m_ShowTaskColumns.size() > _Right.m_ShowTaskColumns.size())
			return false;
		for (size_t i = 0; i < m_ShowTaskColumns.size(); ++i)
		{
			if (m_ShowTaskColumns[i] < _Right.m_ShowTaskColumns[i])
				return true;
			if (m_ShowTaskColumns[i] > _Right.m_ShowTaskColumns[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWallSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWallSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWallSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectDetailedAccessRuleFunction
{
	public:
	EHPMProjectDetailedAccessRuleFunctionType m_FunctionType;
	HPMUInt32 m_FunctionID;
	HPMInt32 m_FunctionSubID;
	HPMProjectDetailedAccessRuleFunction()
		: m_FunctionType(EHPMProjectDetailedAccessRuleFunctionType_DeleteTask)
		, m_FunctionID(0)
		, m_FunctionSubID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectDetailedAccessRuleFunction(HPMProjectDetailedAccessRuleFunction const &_Right)
		: m_FunctionType(_Right.m_FunctionType)
		, m_FunctionID(_Right.m_FunctionID)
		, m_FunctionSubID(_Right.m_FunctionSubID)
	{
	}
	HPMProjectDetailedAccessRuleFunction(HPMProjectDetailedAccessRuleFunction &&_Right)
		: m_FunctionType(std::move(_Right.m_FunctionType))
		, m_FunctionID(std::move(_Right.m_FunctionID))
		, m_FunctionSubID(std::move(_Right.m_FunctionSubID))
	{
	}
	HPMProjectDetailedAccessRuleFunction &operator =(HPMProjectDetailedAccessRuleFunction const &_Right)
	{
		m_FunctionType = _Right.m_FunctionType;
		m_FunctionID = _Right.m_FunctionID;
		m_FunctionSubID = _Right.m_FunctionSubID;
		return *this;
	}
	HPMProjectDetailedAccessRuleFunction &operator =(HPMProjectDetailedAccessRuleFunction &&_Right)
	{
		m_FunctionType = std::move(_Right.m_FunctionType);
		m_FunctionID = std::move(_Right.m_FunctionID);
		m_FunctionSubID = std::move(_Right.m_FunctionSubID);
		return *this;
	}
#endif
	bool operator == (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		if (m_FunctionType != _Right.m_FunctionType)
			return false;
		if (m_FunctionID != _Right.m_FunctionID)
			return false;
		if (m_FunctionSubID != _Right.m_FunctionSubID)
			return false;
		return true;
	}
	bool operator != (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		if (m_FunctionType < _Right.m_FunctionType)
			return true;
		if (m_FunctionType > _Right.m_FunctionType)
			return false;
		if (m_FunctionID < _Right.m_FunctionID)
			return true;
		if (m_FunctionID > _Right.m_FunctionID)
			return false;
		if (m_FunctionSubID < _Right.m_FunctionSubID)
			return true;
		if (m_FunctionSubID > _Right.m_FunctionSubID)
			return false;
		return false;
	}
	bool operator > (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectDetailedAccessRuleFunction &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectDetailedAccessRule
{
	public:
	EHPMProjectDetailedAccessRuleType m_RuleType;
	HPMUniqueID m_CreatedByResource;
	std::vector<HPMResourceDefinition> m_Resources;
	std::vector<HPMProjectDetailedAccessRuleFunction> m_Functions;
	HPMProjectDetailedAccessRule()
		: m_RuleType(EHPMProjectDetailedAccessRuleType_GiveAccess)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectDetailedAccessRule(HPMProjectDetailedAccessRule const &_Right)
		: m_RuleType(_Right.m_RuleType)
		, m_CreatedByResource(_Right.m_CreatedByResource)
		, m_Resources(_Right.m_Resources)
		, m_Functions(_Right.m_Functions)
	{
	}
	HPMProjectDetailedAccessRule(HPMProjectDetailedAccessRule &&_Right)
		: m_RuleType(std::move(_Right.m_RuleType))
		, m_CreatedByResource(std::move(_Right.m_CreatedByResource))
		, m_Resources(std::move(_Right.m_Resources))
		, m_Functions(std::move(_Right.m_Functions))
	{
	}
	HPMProjectDetailedAccessRule &operator =(HPMProjectDetailedAccessRule const &_Right)
	{
		m_RuleType = _Right.m_RuleType;
		m_CreatedByResource = _Right.m_CreatedByResource;
		m_Resources = _Right.m_Resources;
		m_Functions = _Right.m_Functions;
		return *this;
	}
	HPMProjectDetailedAccessRule &operator =(HPMProjectDetailedAccessRule &&_Right)
	{
		m_RuleType = std::move(_Right.m_RuleType);
		m_CreatedByResource = std::move(_Right.m_CreatedByResource);
		m_Resources = std::move(_Right.m_Resources);
		m_Functions = std::move(_Right.m_Functions);
		return *this;
	}
#endif
	bool operator == (const HPMProjectDetailedAccessRule &_Right) const
	{
		if (m_RuleType != _Right.m_RuleType)
			return false;
		if (m_CreatedByResource != _Right.m_CreatedByResource)
			return false;
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		if (m_Functions.size() != _Right.m_Functions.size())
			return false;
		for (size_t i = 0; i < m_Functions.size(); ++i)
			if (m_Functions[i] != _Right.m_Functions[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectDetailedAccessRule &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectDetailedAccessRule &_Right) const
	{
		if (m_RuleType < _Right.m_RuleType)
			return true;
		if (m_RuleType > _Right.m_RuleType)
			return false;
		if (m_CreatedByResource < _Right.m_CreatedByResource)
			return true;
		if (m_CreatedByResource > _Right.m_CreatedByResource)
			return false;
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		if (m_Functions.size() < _Right.m_Functions.size())
			return true;
		if (m_Functions.size() > _Right.m_Functions.size())
			return false;
		for (size_t i = 0; i < m_Functions.size(); ++i)
		{
			if (m_Functions[i] < _Right.m_Functions[i])
				return true;
			if (m_Functions[i] > _Right.m_Functions[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectDetailedAccessRule &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectDetailedAccessRule &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectDetailedAccessRule &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectDetailedAccessRules
{
	public:
	std::vector<HPMProjectDetailedAccessRule> m_Rules;
	HPMProjectDetailedAccessRules()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectDetailedAccessRules(HPMProjectDetailedAccessRules const &_Right)
		: m_Rules(_Right.m_Rules)
	{
	}
	HPMProjectDetailedAccessRules(HPMProjectDetailedAccessRules &&_Right)
		: m_Rules(std::move(_Right.m_Rules))
	{
	}
	HPMProjectDetailedAccessRules &operator =(HPMProjectDetailedAccessRules const &_Right)
	{
		m_Rules = _Right.m_Rules;
		return *this;
	}
	HPMProjectDetailedAccessRules &operator =(HPMProjectDetailedAccessRules &&_Right)
	{
		m_Rules = std::move(_Right.m_Rules);
		return *this;
	}
#endif
	bool operator == (const HPMProjectDetailedAccessRules &_Right) const
	{
		if (m_Rules.size() != _Right.m_Rules.size())
			return false;
		for (size_t i = 0; i < m_Rules.size(); ++i)
			if (m_Rules[i] != _Right.m_Rules[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectDetailedAccessRules &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectDetailedAccessRules &_Right) const
	{
		if (m_Rules.size() < _Right.m_Rules.size())
			return true;
		if (m_Rules.size() > _Right.m_Rules.size())
			return false;
		for (size_t i = 0; i < m_Rules.size(); ++i)
		{
			if (m_Rules[i] < _Right.m_Rules[i])
				return true;
			if (m_Rules[i] > _Right.m_Rules[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectDetailedAccessRules &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectDetailedAccessRules &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectDetailedAccessRules &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWallGroup
{
	public:
	EHPMWallGroupingType m_GroupingType;
	HPMUInt32 m_GroupingID;
	HPMUniqueID m_GroupingSprintUID;
	HPMUniqueID m_ValueAssignID;
	HPMString m_GroupName;
	HPMFP32 m_RectLeft;
	HPMFP32 m_RectTop;
	HPMFP32 m_RectRight;
	HPMFP32 m_RectBottom;
	HPMProjectWallGroup()
		: m_GroupingType(EHPMWallGroupingType_CustomGroups)
		, m_GroupingID(0)
		, m_RectLeft(0.0f)
		, m_RectTop(0.0f)
		, m_RectRight(500.0f)
		, m_RectBottom(500.0f)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWallGroup(HPMProjectWallGroup const &_Right)
		: m_GroupingType(_Right.m_GroupingType)
		, m_GroupingID(_Right.m_GroupingID)
		, m_GroupingSprintUID(_Right.m_GroupingSprintUID)
		, m_ValueAssignID(_Right.m_ValueAssignID)
		, m_GroupName(_Right.m_GroupName)
		, m_RectLeft(_Right.m_RectLeft)
		, m_RectTop(_Right.m_RectTop)
		, m_RectRight(_Right.m_RectRight)
		, m_RectBottom(_Right.m_RectBottom)
	{
	}
	HPMProjectWallGroup(HPMProjectWallGroup &&_Right)
		: m_GroupingType(std::move(_Right.m_GroupingType))
		, m_GroupingID(std::move(_Right.m_GroupingID))
		, m_GroupingSprintUID(std::move(_Right.m_GroupingSprintUID))
		, m_ValueAssignID(std::move(_Right.m_ValueAssignID))
		, m_GroupName(std::move(_Right.m_GroupName))
		, m_RectLeft(std::move(_Right.m_RectLeft))
		, m_RectTop(std::move(_Right.m_RectTop))
		, m_RectRight(std::move(_Right.m_RectRight))
		, m_RectBottom(std::move(_Right.m_RectBottom))
	{
	}
	HPMProjectWallGroup &operator =(HPMProjectWallGroup const &_Right)
	{
		m_GroupingType = _Right.m_GroupingType;
		m_GroupingID = _Right.m_GroupingID;
		m_GroupingSprintUID = _Right.m_GroupingSprintUID;
		m_ValueAssignID = _Right.m_ValueAssignID;
		m_GroupName = _Right.m_GroupName;
		m_RectLeft = _Right.m_RectLeft;
		m_RectTop = _Right.m_RectTop;
		m_RectRight = _Right.m_RectRight;
		m_RectBottom = _Right.m_RectBottom;
		return *this;
	}
	HPMProjectWallGroup &operator =(HPMProjectWallGroup &&_Right)
	{
		m_GroupingType = std::move(_Right.m_GroupingType);
		m_GroupingID = std::move(_Right.m_GroupingID);
		m_GroupingSprintUID = std::move(_Right.m_GroupingSprintUID);
		m_ValueAssignID = std::move(_Right.m_ValueAssignID);
		m_GroupName = std::move(_Right.m_GroupName);
		m_RectLeft = std::move(_Right.m_RectLeft);
		m_RectTop = std::move(_Right.m_RectTop);
		m_RectRight = std::move(_Right.m_RectRight);
		m_RectBottom = std::move(_Right.m_RectBottom);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWallGroup &_Right) const
	{
		if (m_GroupingType != _Right.m_GroupingType)
			return false;
		if (m_GroupingID != _Right.m_GroupingID)
			return false;
		if (m_GroupingSprintUID != _Right.m_GroupingSprintUID)
			return false;
		if (m_ValueAssignID != _Right.m_ValueAssignID)
			return false;
		if (m_GroupName != _Right.m_GroupName)
			return false;
		if (m_RectLeft != _Right.m_RectLeft)
			return false;
		if (m_RectTop != _Right.m_RectTop)
			return false;
		if (m_RectRight != _Right.m_RectRight)
			return false;
		if (m_RectBottom != _Right.m_RectBottom)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWallGroup &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWallGroup &_Right) const
	{
		if (m_GroupingType < _Right.m_GroupingType)
			return true;
		if (m_GroupingType > _Right.m_GroupingType)
			return false;
		if (m_GroupingID < _Right.m_GroupingID)
			return true;
		if (m_GroupingID > _Right.m_GroupingID)
			return false;
		if (m_GroupingSprintUID < _Right.m_GroupingSprintUID)
			return true;
		if (m_GroupingSprintUID > _Right.m_GroupingSprintUID)
			return false;
		if (m_ValueAssignID < _Right.m_ValueAssignID)
			return true;
		if (m_ValueAssignID > _Right.m_ValueAssignID)
			return false;
		if (m_GroupName < _Right.m_GroupName)
			return true;
		if (m_GroupName > _Right.m_GroupName)
			return false;
		if (m_RectLeft < _Right.m_RectLeft)
			return true;
		if (m_RectLeft > _Right.m_RectLeft)
			return false;
		if (m_RectTop < _Right.m_RectTop)
			return true;
		if (m_RectTop > _Right.m_RectTop)
			return false;
		if (m_RectRight < _Right.m_RectRight)
			return true;
		if (m_RectRight > _Right.m_RectRight)
			return false;
		if (m_RectBottom < _Right.m_RectBottom)
			return true;
		if (m_RectBottom > _Right.m_RectBottom)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWallGroup &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWallGroup &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWallGroup &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWallGroups
{
	public:
	std::vector<HPMProjectWallGroup> m_Groups;
	HPMProjectWallGroups()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWallGroups(HPMProjectWallGroups const &_Right)
		: m_Groups(_Right.m_Groups)
	{
	}
	HPMProjectWallGroups(HPMProjectWallGroups &&_Right)
		: m_Groups(std::move(_Right.m_Groups))
	{
	}
	HPMProjectWallGroups &operator =(HPMProjectWallGroups const &_Right)
	{
		m_Groups = _Right.m_Groups;
		return *this;
	}
	HPMProjectWallGroups &operator =(HPMProjectWallGroups &&_Right)
	{
		m_Groups = std::move(_Right.m_Groups);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWallGroups &_Right) const
	{
		if (m_Groups.size() != _Right.m_Groups.size())
			return false;
		for (size_t i = 0; i < m_Groups.size(); ++i)
			if (m_Groups[i] != _Right.m_Groups[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWallGroups &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWallGroups &_Right) const
	{
		if (m_Groups.size() < _Right.m_Groups.size())
			return true;
		if (m_Groups.size() > _Right.m_Groups.size())
			return false;
		for (size_t i = 0; i < m_Groups.size(); ++i)
		{
			if (m_Groups[i] < _Right.m_Groups[i])
				return true;
			if (m_Groups[i] > _Right.m_Groups[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWallGroups &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWallGroups &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWallGroups &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectStatisticsSettings
{
	public:
	HPMUInt32 m_SamplingFrequency;
	HPMUInt32 m_SecondOfDaySample;
	HPMUInt32 m_SamplingFrequencyResource;
	HPMUInt32 m_SecondOfDaySampleResource;
	HPMUInt32 m_SamplingFrequencyResourceGroup;
	HPMUInt32 m_SecondOfDaySampleResourceGroup;
	HPMProjectStatisticsSettings()
		: m_SamplingFrequency(86400)
		, m_SecondOfDaySample(7200)
		, m_SamplingFrequencyResource(86400)
		, m_SecondOfDaySampleResource(7200)
		, m_SamplingFrequencyResourceGroup(86400)
		, m_SecondOfDaySampleResourceGroup(7200)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectStatisticsSettings(HPMProjectStatisticsSettings const &_Right)
		: m_SamplingFrequency(_Right.m_SamplingFrequency)
		, m_SecondOfDaySample(_Right.m_SecondOfDaySample)
		, m_SamplingFrequencyResource(_Right.m_SamplingFrequencyResource)
		, m_SecondOfDaySampleResource(_Right.m_SecondOfDaySampleResource)
		, m_SamplingFrequencyResourceGroup(_Right.m_SamplingFrequencyResourceGroup)
		, m_SecondOfDaySampleResourceGroup(_Right.m_SecondOfDaySampleResourceGroup)
	{
	}
	HPMProjectStatisticsSettings(HPMProjectStatisticsSettings &&_Right)
		: m_SamplingFrequency(std::move(_Right.m_SamplingFrequency))
		, m_SecondOfDaySample(std::move(_Right.m_SecondOfDaySample))
		, m_SamplingFrequencyResource(std::move(_Right.m_SamplingFrequencyResource))
		, m_SecondOfDaySampleResource(std::move(_Right.m_SecondOfDaySampleResource))
		, m_SamplingFrequencyResourceGroup(std::move(_Right.m_SamplingFrequencyResourceGroup))
		, m_SecondOfDaySampleResourceGroup(std::move(_Right.m_SecondOfDaySampleResourceGroup))
	{
	}
	HPMProjectStatisticsSettings &operator =(HPMProjectStatisticsSettings const &_Right)
	{
		m_SamplingFrequency = _Right.m_SamplingFrequency;
		m_SecondOfDaySample = _Right.m_SecondOfDaySample;
		m_SamplingFrequencyResource = _Right.m_SamplingFrequencyResource;
		m_SecondOfDaySampleResource = _Right.m_SecondOfDaySampleResource;
		m_SamplingFrequencyResourceGroup = _Right.m_SamplingFrequencyResourceGroup;
		m_SecondOfDaySampleResourceGroup = _Right.m_SecondOfDaySampleResourceGroup;
		return *this;
	}
	HPMProjectStatisticsSettings &operator =(HPMProjectStatisticsSettings &&_Right)
	{
		m_SamplingFrequency = std::move(_Right.m_SamplingFrequency);
		m_SecondOfDaySample = std::move(_Right.m_SecondOfDaySample);
		m_SamplingFrequencyResource = std::move(_Right.m_SamplingFrequencyResource);
		m_SecondOfDaySampleResource = std::move(_Right.m_SecondOfDaySampleResource);
		m_SamplingFrequencyResourceGroup = std::move(_Right.m_SamplingFrequencyResourceGroup);
		m_SecondOfDaySampleResourceGroup = std::move(_Right.m_SecondOfDaySampleResourceGroup);
		return *this;
	}
#endif
	bool operator == (const HPMProjectStatisticsSettings &_Right) const
	{
		if (m_SamplingFrequency != _Right.m_SamplingFrequency)
			return false;
		if (m_SecondOfDaySample != _Right.m_SecondOfDaySample)
			return false;
		if (m_SamplingFrequencyResource != _Right.m_SamplingFrequencyResource)
			return false;
		if (m_SecondOfDaySampleResource != _Right.m_SecondOfDaySampleResource)
			return false;
		if (m_SamplingFrequencyResourceGroup != _Right.m_SamplingFrequencyResourceGroup)
			return false;
		if (m_SecondOfDaySampleResourceGroup != _Right.m_SecondOfDaySampleResourceGroup)
			return false;
		return true;
	}
	bool operator != (const HPMProjectStatisticsSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectStatisticsSettings &_Right) const
	{
		if (m_SamplingFrequency < _Right.m_SamplingFrequency)
			return true;
		if (m_SamplingFrequency > _Right.m_SamplingFrequency)
			return false;
		if (m_SecondOfDaySample < _Right.m_SecondOfDaySample)
			return true;
		if (m_SecondOfDaySample > _Right.m_SecondOfDaySample)
			return false;
		if (m_SamplingFrequencyResource < _Right.m_SamplingFrequencyResource)
			return true;
		if (m_SamplingFrequencyResource > _Right.m_SamplingFrequencyResource)
			return false;
		if (m_SecondOfDaySampleResource < _Right.m_SecondOfDaySampleResource)
			return true;
		if (m_SecondOfDaySampleResource > _Right.m_SecondOfDaySampleResource)
			return false;
		if (m_SamplingFrequencyResourceGroup < _Right.m_SamplingFrequencyResourceGroup)
			return true;
		if (m_SamplingFrequencyResourceGroup > _Right.m_SamplingFrequencyResourceGroup)
			return false;
		if (m_SecondOfDaySampleResourceGroup < _Right.m_SecondOfDaySampleResourceGroup)
			return true;
		if (m_SecondOfDaySampleResourceGroup > _Right.m_SecondOfDaySampleResourceGroup)
			return false;
		return false;
	}
	bool operator > (const HPMProjectStatisticsSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectStatisticsSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectStatisticsSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectResourceEnum
{
	public:
	std::vector<HPMUniqueID> m_Resources;
	HPMProjectResourceEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectResourceEnum(HPMProjectResourceEnum const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMProjectResourceEnum(HPMProjectResourceEnum &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMProjectResourceEnum &operator =(HPMProjectResourceEnum const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMProjectResourceEnum &operator =(HPMProjectResourceEnum &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMProjectResourceEnum &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectResourceEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectResourceEnum &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectResourceEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectResourceEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectResourceEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectResourceProperties
{
	public:
	EHPMProjectResourceFlag m_Flags;
	HPMProjectResourceProperties()
		: m_Flags(EHPMProjectResourceFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectResourceProperties(HPMProjectResourceProperties const &_Right)
		: m_Flags(_Right.m_Flags)
	{
	}
	HPMProjectResourceProperties(HPMProjectResourceProperties &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
	{
	}
	HPMProjectResourceProperties &operator =(HPMProjectResourceProperties const &_Right)
	{
		m_Flags = _Right.m_Flags;
		return *this;
	}
	HPMProjectResourceProperties &operator =(HPMProjectResourceProperties &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		return *this;
	}
#endif
	bool operator == (const HPMProjectResourceProperties &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		return true;
	}
	bool operator != (const HPMProjectResourceProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectResourceProperties &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		return false;
	}
	bool operator > (const HPMProjectResourceProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectResourceProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectResourceProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomStatisticsSampler
{
	public:
	HPMInt32 m_SamplerID;
	HPMString m_Name;
	HPMUniqueID m_CreatedBy;
	std::vector<HPMCustomStatisticsField> m_Fields;
	HPMProjectCustomStatisticsSampler()
		: m_SamplerID(-1)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomStatisticsSampler(HPMProjectCustomStatisticsSampler const &_Right)
		: m_SamplerID(_Right.m_SamplerID)
		, m_Name(_Right.m_Name)
		, m_CreatedBy(_Right.m_CreatedBy)
		, m_Fields(_Right.m_Fields)
	{
	}
	HPMProjectCustomStatisticsSampler(HPMProjectCustomStatisticsSampler &&_Right)
		: m_SamplerID(std::move(_Right.m_SamplerID))
		, m_Name(std::move(_Right.m_Name))
		, m_CreatedBy(std::move(_Right.m_CreatedBy))
		, m_Fields(std::move(_Right.m_Fields))
	{
	}
	HPMProjectCustomStatisticsSampler &operator =(HPMProjectCustomStatisticsSampler const &_Right)
	{
		m_SamplerID = _Right.m_SamplerID;
		m_Name = _Right.m_Name;
		m_CreatedBy = _Right.m_CreatedBy;
		m_Fields = _Right.m_Fields;
		return *this;
	}
	HPMProjectCustomStatisticsSampler &operator =(HPMProjectCustomStatisticsSampler &&_Right)
	{
		m_SamplerID = std::move(_Right.m_SamplerID);
		m_Name = std::move(_Right.m_Name);
		m_CreatedBy = std::move(_Right.m_CreatedBy);
		m_Fields = std::move(_Right.m_Fields);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		if (m_SamplerID != _Right.m_SamplerID)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		if (m_CreatedBy != _Right.m_CreatedBy)
			return false;
		if (m_Fields.size() != _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
			if (m_Fields[i] != _Right.m_Fields[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		if (m_SamplerID < _Right.m_SamplerID)
			return true;
		if (m_SamplerID > _Right.m_SamplerID)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_CreatedBy < _Right.m_CreatedBy)
			return true;
		if (m_CreatedBy > _Right.m_CreatedBy)
			return false;
		if (m_Fields.size() < _Right.m_Fields.size())
			return true;
		if (m_Fields.size() > _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
		{
			if (m_Fields[i] < _Right.m_Fields[i])
				return true;
			if (m_Fields[i] > _Right.m_Fields[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomStatisticsSampler &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectCustomStatisticsSettings
{
	public:
	HPMInt32 m_NextSamplerID;
	std::vector<HPMProjectCustomStatisticsSampler> m_StatisticsSamplers;
	HPMProjectCustomStatisticsSettings()
		: m_NextSamplerID(1)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectCustomStatisticsSettings(HPMProjectCustomStatisticsSettings const &_Right)
		: m_NextSamplerID(_Right.m_NextSamplerID)
		, m_StatisticsSamplers(_Right.m_StatisticsSamplers)
	{
	}
	HPMProjectCustomStatisticsSettings(HPMProjectCustomStatisticsSettings &&_Right)
		: m_NextSamplerID(std::move(_Right.m_NextSamplerID))
		, m_StatisticsSamplers(std::move(_Right.m_StatisticsSamplers))
	{
	}
	HPMProjectCustomStatisticsSettings &operator =(HPMProjectCustomStatisticsSettings const &_Right)
	{
		m_NextSamplerID = _Right.m_NextSamplerID;
		m_StatisticsSamplers = _Right.m_StatisticsSamplers;
		return *this;
	}
	HPMProjectCustomStatisticsSettings &operator =(HPMProjectCustomStatisticsSettings &&_Right)
	{
		m_NextSamplerID = std::move(_Right.m_NextSamplerID);
		m_StatisticsSamplers = std::move(_Right.m_StatisticsSamplers);
		return *this;
	}
#endif
	bool operator == (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		if (m_NextSamplerID != _Right.m_NextSamplerID)
			return false;
		if (m_StatisticsSamplers.size() != _Right.m_StatisticsSamplers.size())
			return false;
		for (size_t i = 0; i < m_StatisticsSamplers.size(); ++i)
			if (m_StatisticsSamplers[i] != _Right.m_StatisticsSamplers[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		if (m_NextSamplerID < _Right.m_NextSamplerID)
			return true;
		if (m_NextSamplerID > _Right.m_NextSamplerID)
			return false;
		if (m_StatisticsSamplers.size() < _Right.m_StatisticsSamplers.size())
			return true;
		if (m_StatisticsSamplers.size() > _Right.m_StatisticsSamplers.size())
			return false;
		for (size_t i = 0; i < m_StatisticsSamplers.size(); ++i)
		{
			if (m_StatisticsSamplers[i] < _Right.m_StatisticsSamplers[i])
				return true;
			if (m_StatisticsSamplers[i] > _Right.m_StatisticsSamplers[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectCustomStatisticsSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowEnum
{
	public:
	std::vector<HPMUInt32> m_Workflows;
	HPMProjectWorkflowEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowEnum(HPMProjectWorkflowEnum const &_Right)
		: m_Workflows(_Right.m_Workflows)
	{
	}
	HPMProjectWorkflowEnum(HPMProjectWorkflowEnum &&_Right)
		: m_Workflows(std::move(_Right.m_Workflows))
	{
	}
	HPMProjectWorkflowEnum &operator =(HPMProjectWorkflowEnum const &_Right)
	{
		m_Workflows = _Right.m_Workflows;
		return *this;
	}
	HPMProjectWorkflowEnum &operator =(HPMProjectWorkflowEnum &&_Right)
	{
		m_Workflows = std::move(_Right.m_Workflows);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowEnum &_Right) const
	{
		if (m_Workflows.size() != _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
			if (m_Workflows[i] != _Right.m_Workflows[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowEnum &_Right) const
	{
		if (m_Workflows.size() < _Right.m_Workflows.size())
			return true;
		if (m_Workflows.size() > _Right.m_Workflows.size())
			return false;
		for (size_t i = 0; i < m_Workflows.size(); ++i)
		{
			if (m_Workflows[i] < _Right.m_Workflows[i])
				return true;
			if (m_Workflows[i] > _Right.m_Workflows[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflowEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowObjectEnum
{
	public:
	std::vector<HPMUInt32> m_WorkflowObjects;
	HPMProjectWorkflowObjectEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowObjectEnum(HPMProjectWorkflowObjectEnum const &_Right)
		: m_WorkflowObjects(_Right.m_WorkflowObjects)
	{
	}
	HPMProjectWorkflowObjectEnum(HPMProjectWorkflowObjectEnum &&_Right)
		: m_WorkflowObjects(std::move(_Right.m_WorkflowObjects))
	{
	}
	HPMProjectWorkflowObjectEnum &operator =(HPMProjectWorkflowObjectEnum const &_Right)
	{
		m_WorkflowObjects = _Right.m_WorkflowObjects;
		return *this;
	}
	HPMProjectWorkflowObjectEnum &operator =(HPMProjectWorkflowObjectEnum &&_Right)
	{
		m_WorkflowObjects = std::move(_Right.m_WorkflowObjects);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		if (m_WorkflowObjects.size() != _Right.m_WorkflowObjects.size())
			return false;
		for (size_t i = 0; i < m_WorkflowObjects.size(); ++i)
			if (m_WorkflowObjects[i] != _Right.m_WorkflowObjects[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		if (m_WorkflowObjects.size() < _Right.m_WorkflowObjects.size())
			return true;
		if (m_WorkflowObjects.size() > _Right.m_WorkflowObjects.size())
			return false;
		for (size_t i = 0; i < m_WorkflowObjects.size(); ++i)
		{
			if (m_WorkflowObjects[i] < _Right.m_WorkflowObjects[i])
				return true;
			if (m_WorkflowObjects[i] > _Right.m_WorkflowObjects[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowObjectEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowStructureTask
{
	public:
	HPMWorkflowObjectIdentifier m_WorkflowIdentifier;
	HPMUntranslatedString m_TaskDescription;
	HPMUInt32 m_TaskTreeLevel;
	HPMResourceDefinitionList m_TaskAllocatedResources;
	std::vector<HPMTaskFieldData> m_TaskDefaultValues;
	HPMProjectWorkflowStructureTask()
		: m_TaskTreeLevel(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowStructureTask(HPMProjectWorkflowStructureTask const &_Right)
		: m_WorkflowIdentifier(_Right.m_WorkflowIdentifier)
		, m_TaskDescription(_Right.m_TaskDescription)
		, m_TaskTreeLevel(_Right.m_TaskTreeLevel)
		, m_TaskAllocatedResources(_Right.m_TaskAllocatedResources)
		, m_TaskDefaultValues(_Right.m_TaskDefaultValues)
	{
	}
	HPMProjectWorkflowStructureTask(HPMProjectWorkflowStructureTask &&_Right)
		: m_WorkflowIdentifier(std::move(_Right.m_WorkflowIdentifier))
		, m_TaskDescription(std::move(_Right.m_TaskDescription))
		, m_TaskTreeLevel(std::move(_Right.m_TaskTreeLevel))
		, m_TaskAllocatedResources(std::move(_Right.m_TaskAllocatedResources))
		, m_TaskDefaultValues(std::move(_Right.m_TaskDefaultValues))
	{
	}
	HPMProjectWorkflowStructureTask &operator =(HPMProjectWorkflowStructureTask const &_Right)
	{
		m_WorkflowIdentifier = _Right.m_WorkflowIdentifier;
		m_TaskDescription = _Right.m_TaskDescription;
		m_TaskTreeLevel = _Right.m_TaskTreeLevel;
		m_TaskAllocatedResources = _Right.m_TaskAllocatedResources;
		m_TaskDefaultValues = _Right.m_TaskDefaultValues;
		return *this;
	}
	HPMProjectWorkflowStructureTask &operator =(HPMProjectWorkflowStructureTask &&_Right)
	{
		m_WorkflowIdentifier = std::move(_Right.m_WorkflowIdentifier);
		m_TaskDescription = std::move(_Right.m_TaskDescription);
		m_TaskTreeLevel = std::move(_Right.m_TaskTreeLevel);
		m_TaskAllocatedResources = std::move(_Right.m_TaskAllocatedResources);
		m_TaskDefaultValues = std::move(_Right.m_TaskDefaultValues);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowStructureTask &_Right) const
	{
		if (m_WorkflowIdentifier != _Right.m_WorkflowIdentifier)
			return false;
		if (m_TaskDescription != _Right.m_TaskDescription)
			return false;
		if (m_TaskTreeLevel != _Right.m_TaskTreeLevel)
			return false;
		if (m_TaskAllocatedResources != _Right.m_TaskAllocatedResources)
			return false;
		if (m_TaskDefaultValues.size() != _Right.m_TaskDefaultValues.size())
			return false;
		for (size_t i = 0; i < m_TaskDefaultValues.size(); ++i)
			if (m_TaskDefaultValues[i] != _Right.m_TaskDefaultValues[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowStructureTask &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowStructureTask &_Right) const
	{
		if (m_WorkflowIdentifier < _Right.m_WorkflowIdentifier)
			return true;
		if (m_WorkflowIdentifier > _Right.m_WorkflowIdentifier)
			return false;
		if (m_TaskDescription < _Right.m_TaskDescription)
			return true;
		if (m_TaskDescription > _Right.m_TaskDescription)
			return false;
		if (m_TaskTreeLevel < _Right.m_TaskTreeLevel)
			return true;
		if (m_TaskTreeLevel > _Right.m_TaskTreeLevel)
			return false;
		if (m_TaskAllocatedResources < _Right.m_TaskAllocatedResources)
			return true;
		if (m_TaskAllocatedResources > _Right.m_TaskAllocatedResources)
			return false;
		if (m_TaskDefaultValues.size() < _Right.m_TaskDefaultValues.size())
			return true;
		if (m_TaskDefaultValues.size() > _Right.m_TaskDefaultValues.size())
			return false;
		for (size_t i = 0; i < m_TaskDefaultValues.size(); ++i)
		{
			if (m_TaskDefaultValues[i] < _Right.m_TaskDefaultValues[i])
				return true;
			if (m_TaskDefaultValues[i] > _Right.m_TaskDefaultValues[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflowStructureTask &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowStructureTask &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowStructureTask &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowStructure
{
	public:
	std::vector<HPMProjectWorkflowStructureTask> m_Tasks;
	HPMProjectWorkflowStructure()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowStructure(HPMProjectWorkflowStructure const &_Right)
		: m_Tasks(_Right.m_Tasks)
	{
	}
	HPMProjectWorkflowStructure(HPMProjectWorkflowStructure &&_Right)
		: m_Tasks(std::move(_Right.m_Tasks))
	{
	}
	HPMProjectWorkflowStructure &operator =(HPMProjectWorkflowStructure const &_Right)
	{
		m_Tasks = _Right.m_Tasks;
		return *this;
	}
	HPMProjectWorkflowStructure &operator =(HPMProjectWorkflowStructure &&_Right)
	{
		m_Tasks = std::move(_Right.m_Tasks);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowStructure &_Right) const
	{
		if (m_Tasks.size() != _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
			if (m_Tasks[i] != _Right.m_Tasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowStructure &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowStructure &_Right) const
	{
		if (m_Tasks.size() < _Right.m_Tasks.size())
			return true;
		if (m_Tasks.size() > _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
		{
			if (m_Tasks[i] < _Right.m_Tasks[i])
				return true;
			if (m_Tasks[i] > _Right.m_Tasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectWorkflowStructure &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowStructure &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowStructure &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowStatusStats
{
	public:
	HPMInt64 m_StateChanges;
	HPMInt64 m_TotalTimeSpan;
	HPMInt64 m_ContributingTasks;
	HPMProjectWorkflowStatusStats()
		: m_StateChanges(0)
		, m_TotalTimeSpan(0)
		, m_ContributingTasks(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowStatusStats(HPMProjectWorkflowStatusStats const &_Right)
		: m_StateChanges(_Right.m_StateChanges)
		, m_TotalTimeSpan(_Right.m_TotalTimeSpan)
		, m_ContributingTasks(_Right.m_ContributingTasks)
	{
	}
	HPMProjectWorkflowStatusStats(HPMProjectWorkflowStatusStats &&_Right)
		: m_StateChanges(std::move(_Right.m_StateChanges))
		, m_TotalTimeSpan(std::move(_Right.m_TotalTimeSpan))
		, m_ContributingTasks(std::move(_Right.m_ContributingTasks))
	{
	}
	HPMProjectWorkflowStatusStats &operator =(HPMProjectWorkflowStatusStats const &_Right)
	{
		m_StateChanges = _Right.m_StateChanges;
		m_TotalTimeSpan = _Right.m_TotalTimeSpan;
		m_ContributingTasks = _Right.m_ContributingTasks;
		return *this;
	}
	HPMProjectWorkflowStatusStats &operator =(HPMProjectWorkflowStatusStats &&_Right)
	{
		m_StateChanges = std::move(_Right.m_StateChanges);
		m_TotalTimeSpan = std::move(_Right.m_TotalTimeSpan);
		m_ContributingTasks = std::move(_Right.m_ContributingTasks);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowStatusStats &_Right) const
	{
		if (m_StateChanges != _Right.m_StateChanges)
			return false;
		if (m_TotalTimeSpan != _Right.m_TotalTimeSpan)
			return false;
		if (m_ContributingTasks != _Right.m_ContributingTasks)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowStatusStats &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowStatusStats &_Right) const
	{
		if (m_StateChanges < _Right.m_StateChanges)
			return true;
		if (m_StateChanges > _Right.m_StateChanges)
			return false;
		if (m_TotalTimeSpan < _Right.m_TotalTimeSpan)
			return true;
		if (m_TotalTimeSpan > _Right.m_TotalTimeSpan)
			return false;
		if (m_ContributingTasks < _Right.m_ContributingTasks)
			return true;
		if (m_ContributingTasks > _Right.m_ContributingTasks)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowStatusStats &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowStatusStats &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowStatusStats &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowEnumWorkflowProperties
{
	public:
	EHPMProjectWorkflowEnumWorkflowType m_WorkflowEnumWorkflowType;
	HPMProjectWorkflowEnumWorkflowProperties()
		: m_WorkflowEnumWorkflowType(EHPMProjectWorkflowEnumWorkflowType_Dependencies)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowEnumWorkflowProperties(HPMProjectWorkflowEnumWorkflowProperties const &_Right)
		: m_WorkflowEnumWorkflowType(_Right.m_WorkflowEnumWorkflowType)
	{
	}
	HPMProjectWorkflowEnumWorkflowProperties(HPMProjectWorkflowEnumWorkflowProperties &&_Right)
		: m_WorkflowEnumWorkflowType(std::move(_Right.m_WorkflowEnumWorkflowType))
	{
	}
	HPMProjectWorkflowEnumWorkflowProperties &operator =(HPMProjectWorkflowEnumWorkflowProperties const &_Right)
	{
		m_WorkflowEnumWorkflowType = _Right.m_WorkflowEnumWorkflowType;
		return *this;
	}
	HPMProjectWorkflowEnumWorkflowProperties &operator =(HPMProjectWorkflowEnumWorkflowProperties &&_Right)
	{
		m_WorkflowEnumWorkflowType = std::move(_Right.m_WorkflowEnumWorkflowType);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		if (m_WorkflowEnumWorkflowType != _Right.m_WorkflowEnumWorkflowType)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		if (m_WorkflowEnumWorkflowType < _Right.m_WorkflowEnumWorkflowType)
			return true;
		if (m_WorkflowEnumWorkflowType > _Right.m_WorkflowEnumWorkflowType)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowEnumWorkflowProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectWorkflowEnumObjectProperties
{
	public:
	EHPMProjectWorkflowEnumObjectType m_WorkflowEnumObjectType;
	HPMProjectWorkflowEnumObjectProperties()
		: m_WorkflowEnumObjectType(EHPMProjectWorkflowEnumObjectType_Dependencies)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectWorkflowEnumObjectProperties(HPMProjectWorkflowEnumObjectProperties const &_Right)
		: m_WorkflowEnumObjectType(_Right.m_WorkflowEnumObjectType)
	{
	}
	HPMProjectWorkflowEnumObjectProperties(HPMProjectWorkflowEnumObjectProperties &&_Right)
		: m_WorkflowEnumObjectType(std::move(_Right.m_WorkflowEnumObjectType))
	{
	}
	HPMProjectWorkflowEnumObjectProperties &operator =(HPMProjectWorkflowEnumObjectProperties const &_Right)
	{
		m_WorkflowEnumObjectType = _Right.m_WorkflowEnumObjectType;
		return *this;
	}
	HPMProjectWorkflowEnumObjectProperties &operator =(HPMProjectWorkflowEnumObjectProperties &&_Right)
	{
		m_WorkflowEnumObjectType = std::move(_Right.m_WorkflowEnumObjectType);
		return *this;
	}
#endif
	bool operator == (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		if (m_WorkflowEnumObjectType != _Right.m_WorkflowEnumObjectType)
			return false;
		return true;
	}
	bool operator != (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		if (m_WorkflowEnumObjectType < _Right.m_WorkflowEnumObjectType)
			return true;
		if (m_WorkflowEnumObjectType > _Right.m_WorkflowEnumObjectType)
			return false;
		return false;
	}
	bool operator > (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectWorkflowEnumObjectProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectViewPreset
{
	public:
	HPMString m_Name;
	std::vector<HPMResourceDefinition> m_Resources;
	std::vector<HPMColumn> m_Columns;
	std::vector<HPMColumn> m_ColumnsOrder;
	std::vector<HPMColumn> m_ItemSettingsColumns;
	std::vector<HPMColumn> m_ItemSettingsColumnsOrder;
	EHPMProjectPresetShowOptionFlag m_ShowOptions;
	HPMProjectViewPreset()
		: m_ShowOptions(EHPMProjectPresetShowOptionFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectViewPreset(HPMProjectViewPreset const &_Right)
		: m_Name(_Right.m_Name)
		, m_Resources(_Right.m_Resources)
		, m_Columns(_Right.m_Columns)
		, m_ColumnsOrder(_Right.m_ColumnsOrder)
		, m_ItemSettingsColumns(_Right.m_ItemSettingsColumns)
		, m_ItemSettingsColumnsOrder(_Right.m_ItemSettingsColumnsOrder)
		, m_ShowOptions(_Right.m_ShowOptions)
	{
	}
	HPMProjectViewPreset(HPMProjectViewPreset &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_Resources(std::move(_Right.m_Resources))
		, m_Columns(std::move(_Right.m_Columns))
		, m_ColumnsOrder(std::move(_Right.m_ColumnsOrder))
		, m_ItemSettingsColumns(std::move(_Right.m_ItemSettingsColumns))
		, m_ItemSettingsColumnsOrder(std::move(_Right.m_ItemSettingsColumnsOrder))
		, m_ShowOptions(std::move(_Right.m_ShowOptions))
	{
	}
	HPMProjectViewPreset &operator =(HPMProjectViewPreset const &_Right)
	{
		m_Name = _Right.m_Name;
		m_Resources = _Right.m_Resources;
		m_Columns = _Right.m_Columns;
		m_ColumnsOrder = _Right.m_ColumnsOrder;
		m_ItemSettingsColumns = _Right.m_ItemSettingsColumns;
		m_ItemSettingsColumnsOrder = _Right.m_ItemSettingsColumnsOrder;
		m_ShowOptions = _Right.m_ShowOptions;
		return *this;
	}
	HPMProjectViewPreset &operator =(HPMProjectViewPreset &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_Resources = std::move(_Right.m_Resources);
		m_Columns = std::move(_Right.m_Columns);
		m_ColumnsOrder = std::move(_Right.m_ColumnsOrder);
		m_ItemSettingsColumns = std::move(_Right.m_ItemSettingsColumns);
		m_ItemSettingsColumnsOrder = std::move(_Right.m_ItemSettingsColumnsOrder);
		m_ShowOptions = std::move(_Right.m_ShowOptions);
		return *this;
	}
#endif
	bool operator == (const HPMProjectViewPreset &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		if (m_Columns.size() != _Right.m_Columns.size())
			return false;
		for (size_t i = 0; i < m_Columns.size(); ++i)
			if (m_Columns[i] != _Right.m_Columns[i])
				return false;
		if (m_ColumnsOrder.size() != _Right.m_ColumnsOrder.size())
			return false;
		for (size_t i = 0; i < m_ColumnsOrder.size(); ++i)
			if (m_ColumnsOrder[i] != _Right.m_ColumnsOrder[i])
				return false;
		if (m_ItemSettingsColumns.size() != _Right.m_ItemSettingsColumns.size())
			return false;
		for (size_t i = 0; i < m_ItemSettingsColumns.size(); ++i)
			if (m_ItemSettingsColumns[i] != _Right.m_ItemSettingsColumns[i])
				return false;
		if (m_ItemSettingsColumnsOrder.size() != _Right.m_ItemSettingsColumnsOrder.size())
			return false;
		for (size_t i = 0; i < m_ItemSettingsColumnsOrder.size(); ++i)
			if (m_ItemSettingsColumnsOrder[i] != _Right.m_ItemSettingsColumnsOrder[i])
				return false;
		if (m_ShowOptions != _Right.m_ShowOptions)
			return false;
		return true;
	}
	bool operator != (const HPMProjectViewPreset &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectViewPreset &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		if (m_Columns.size() < _Right.m_Columns.size())
			return true;
		if (m_Columns.size() > _Right.m_Columns.size())
			return false;
		for (size_t i = 0; i < m_Columns.size(); ++i)
		{
			if (m_Columns[i] < _Right.m_Columns[i])
				return true;
			if (m_Columns[i] > _Right.m_Columns[i])
				return false;
		}
		if (m_ColumnsOrder.size() < _Right.m_ColumnsOrder.size())
			return true;
		if (m_ColumnsOrder.size() > _Right.m_ColumnsOrder.size())
			return false;
		for (size_t i = 0; i < m_ColumnsOrder.size(); ++i)
		{
			if (m_ColumnsOrder[i] < _Right.m_ColumnsOrder[i])
				return true;
			if (m_ColumnsOrder[i] > _Right.m_ColumnsOrder[i])
				return false;
		}
		if (m_ItemSettingsColumns.size() < _Right.m_ItemSettingsColumns.size())
			return true;
		if (m_ItemSettingsColumns.size() > _Right.m_ItemSettingsColumns.size())
			return false;
		for (size_t i = 0; i < m_ItemSettingsColumns.size(); ++i)
		{
			if (m_ItemSettingsColumns[i] < _Right.m_ItemSettingsColumns[i])
				return true;
			if (m_ItemSettingsColumns[i] > _Right.m_ItemSettingsColumns[i])
				return false;
		}
		if (m_ItemSettingsColumnsOrder.size() < _Right.m_ItemSettingsColumnsOrder.size())
			return true;
		if (m_ItemSettingsColumnsOrder.size() > _Right.m_ItemSettingsColumnsOrder.size())
			return false;
		for (size_t i = 0; i < m_ItemSettingsColumnsOrder.size(); ++i)
		{
			if (m_ItemSettingsColumnsOrder[i] < _Right.m_ItemSettingsColumnsOrder[i])
				return true;
			if (m_ItemSettingsColumnsOrder[i] > _Right.m_ItemSettingsColumnsOrder[i])
				return false;
		}
		if (m_ShowOptions < _Right.m_ShowOptions)
			return true;
		if (m_ShowOptions > _Right.m_ShowOptions)
			return false;
		return false;
	}
	bool operator > (const HPMProjectViewPreset &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectViewPreset &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectViewPreset &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMProjectViewPresets
{
	public:
	std::vector<HPMProjectViewPreset> m_Presets;
	HPMProjectViewPresets()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMProjectViewPresets(HPMProjectViewPresets const &_Right)
		: m_Presets(_Right.m_Presets)
	{
	}
	HPMProjectViewPresets(HPMProjectViewPresets &&_Right)
		: m_Presets(std::move(_Right.m_Presets))
	{
	}
	HPMProjectViewPresets &operator =(HPMProjectViewPresets const &_Right)
	{
		m_Presets = _Right.m_Presets;
		return *this;
	}
	HPMProjectViewPresets &operator =(HPMProjectViewPresets &&_Right)
	{
		m_Presets = std::move(_Right.m_Presets);
		return *this;
	}
#endif
	bool operator == (const HPMProjectViewPresets &_Right) const
	{
		if (m_Presets.size() != _Right.m_Presets.size())
			return false;
		for (size_t i = 0; i < m_Presets.size(); ++i)
			if (m_Presets[i] != _Right.m_Presets[i])
				return false;
		return true;
	}
	bool operator != (const HPMProjectViewPresets &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMProjectViewPresets &_Right) const
	{
		if (m_Presets.size() < _Right.m_Presets.size())
			return true;
		if (m_Presets.size() > _Right.m_Presets.size())
			return false;
		for (size_t i = 0; i < m_Presets.size(); ++i)
		{
			if (m_Presets[i] < _Right.m_Presets[i])
				return true;
			if (m_Presets[i] > _Right.m_Presets[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMProjectViewPresets &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMProjectViewPresets &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMProjectViewPresets &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskEnum
{
	public:
	std::vector<HPMUniqueID> m_Tasks;
	HPMTaskEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskEnum(HPMTaskEnum const &_Right)
		: m_Tasks(_Right.m_Tasks)
	{
	}
	HPMTaskEnum(HPMTaskEnum &&_Right)
		: m_Tasks(std::move(_Right.m_Tasks))
	{
	}
	HPMTaskEnum &operator =(HPMTaskEnum const &_Right)
	{
		m_Tasks = _Right.m_Tasks;
		return *this;
	}
	HPMTaskEnum &operator =(HPMTaskEnum &&_Right)
	{
		m_Tasks = std::move(_Right.m_Tasks);
		return *this;
	}
#endif
	bool operator == (const HPMTaskEnum &_Right) const
	{
		if (m_Tasks.size() != _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
			if (m_Tasks[i] != _Right.m_Tasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskEnum &_Right) const
	{
		if (m_Tasks.size() < _Right.m_Tasks.size())
			return true;
		if (m_Tasks.size() > _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
		{
			if (m_Tasks[i] < _Right.m_Tasks[i])
				return true;
			if (m_Tasks[i] > _Right.m_Tasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskConnectionEnum
{
	public:
	std::vector<HPMUniqueID> m_ConnectedTasks;
	HPMTaskConnectionEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskConnectionEnum(HPMTaskConnectionEnum const &_Right)
		: m_ConnectedTasks(_Right.m_ConnectedTasks)
	{
	}
	HPMTaskConnectionEnum(HPMTaskConnectionEnum &&_Right)
		: m_ConnectedTasks(std::move(_Right.m_ConnectedTasks))
	{
	}
	HPMTaskConnectionEnum &operator =(HPMTaskConnectionEnum const &_Right)
	{
		m_ConnectedTasks = _Right.m_ConnectedTasks;
		return *this;
	}
	HPMTaskConnectionEnum &operator =(HPMTaskConnectionEnum &&_Right)
	{
		m_ConnectedTasks = std::move(_Right.m_ConnectedTasks);
		return *this;
	}
#endif
	bool operator == (const HPMTaskConnectionEnum &_Right) const
	{
		if (m_ConnectedTasks.size() != _Right.m_ConnectedTasks.size())
			return false;
		for (size_t i = 0; i < m_ConnectedTasks.size(); ++i)
			if (m_ConnectedTasks[i] != _Right.m_ConnectedTasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskConnectionEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskConnectionEnum &_Right) const
	{
		if (m_ConnectedTasks.size() < _Right.m_ConnectedTasks.size())
			return true;
		if (m_ConnectedTasks.size() > _Right.m_ConnectedTasks.size())
			return false;
		for (size_t i = 0; i < m_ConnectedTasks.size(); ++i)
		{
			if (m_ConnectedTasks[i] < _Right.m_ConnectedTasks[i])
				return true;
			if (m_ConnectedTasks[i] > _Right.m_ConnectedTasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskConnectionEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskConnectionEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskConnectionEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCustomColumnDataEnum
{
	public:
	std::vector<HPMUInt32> m_Hashes;
	HPMTaskCustomColumnDataEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCustomColumnDataEnum(HPMTaskCustomColumnDataEnum const &_Right)
		: m_Hashes(_Right.m_Hashes)
	{
	}
	HPMTaskCustomColumnDataEnum(HPMTaskCustomColumnDataEnum &&_Right)
		: m_Hashes(std::move(_Right.m_Hashes))
	{
	}
	HPMTaskCustomColumnDataEnum &operator =(HPMTaskCustomColumnDataEnum const &_Right)
	{
		m_Hashes = _Right.m_Hashes;
		return *this;
	}
	HPMTaskCustomColumnDataEnum &operator =(HPMTaskCustomColumnDataEnum &&_Right)
	{
		m_Hashes = std::move(_Right.m_Hashes);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		if (m_Hashes.size() != _Right.m_Hashes.size())
			return false;
		for (size_t i = 0; i < m_Hashes.size(); ++i)
			if (m_Hashes[i] != _Right.m_Hashes[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		if (m_Hashes.size() < _Right.m_Hashes.size())
			return true;
		if (m_Hashes.size() > _Right.m_Hashes.size())
			return false;
		for (size_t i = 0; i < m_Hashes.size(); ++i)
		{
			if (m_Hashes[i] < _Right.m_Hashes[i])
				return true;
			if (m_Hashes[i] > _Right.m_Hashes[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCustomColumnDataEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCreateUnifiedReference
{
	public:
	bool m_bLocalID;
	bool m_bHasNonSumbittedBetween;
	HPMUniqueID m_RefID;
	HPMTaskCreateUnifiedReference()
		: m_bLocalID(0)
		, m_bHasNonSumbittedBetween(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCreateUnifiedReference(HPMTaskCreateUnifiedReference const &_Right)
		: m_bLocalID(_Right.m_bLocalID)
		, m_bHasNonSumbittedBetween(_Right.m_bHasNonSumbittedBetween)
		, m_RefID(_Right.m_RefID)
	{
	}
	HPMTaskCreateUnifiedReference(HPMTaskCreateUnifiedReference &&_Right)
		: m_bLocalID(std::move(_Right.m_bLocalID))
		, m_bHasNonSumbittedBetween(std::move(_Right.m_bHasNonSumbittedBetween))
		, m_RefID(std::move(_Right.m_RefID))
	{
	}
	HPMTaskCreateUnifiedReference &operator =(HPMTaskCreateUnifiedReference const &_Right)
	{
		m_bLocalID = _Right.m_bLocalID;
		m_bHasNonSumbittedBetween = _Right.m_bHasNonSumbittedBetween;
		m_RefID = _Right.m_RefID;
		return *this;
	}
	HPMTaskCreateUnifiedReference &operator =(HPMTaskCreateUnifiedReference &&_Right)
	{
		m_bLocalID = std::move(_Right.m_bLocalID);
		m_bHasNonSumbittedBetween = std::move(_Right.m_bHasNonSumbittedBetween);
		m_RefID = std::move(_Right.m_RefID);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCreateUnifiedReference &_Right) const
	{
		if (m_bLocalID != _Right.m_bLocalID)
			return false;
		if (m_bHasNonSumbittedBetween != _Right.m_bHasNonSumbittedBetween)
			return false;
		if (m_RefID != _Right.m_RefID)
			return false;
		return true;
	}
	bool operator != (const HPMTaskCreateUnifiedReference &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCreateUnifiedReference &_Right) const
	{
		if (m_bLocalID < _Right.m_bLocalID)
			return true;
		if (m_bLocalID > _Right.m_bLocalID)
			return false;
		if (m_bHasNonSumbittedBetween < _Right.m_bHasNonSumbittedBetween)
			return true;
		if (m_bHasNonSumbittedBetween > _Right.m_bHasNonSumbittedBetween)
			return false;
		if (m_RefID < _Right.m_RefID)
			return true;
		if (m_RefID > _Right.m_RefID)
			return false;
		return false;
	}
	bool operator > (const HPMTaskCreateUnifiedReference &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCreateUnifiedReference &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCreateUnifiedReference &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCreateUnifiedEntry
{
	public:
	bool m_bIsProxy;
	HPMUniqueID m_LocalID;
	HPMUniqueID m_ReuseUniqueRefID;
	EHPMTaskType m_TaskType;
	EHPMTaskLockedType m_TaskLockedType;
	HPMUniqueID m_Proxy_ReferToRefTaskID;
	HPMUniqueID m_NonProxy_ReuseUniqueID;
	HPMUInt32 m_NonProxy_ReuseID;
	HPMUInt32 m_NonProxy_WorkflowID;
	bool m_NonProxy_bRestoreFromHistory;
	HPMTaskCreateUnifiedReference m_PreviousRefID;
	HPMTaskCreateUnifiedReference m_PreviousWorkPrioRefID;
	std::vector<HPMTaskCreateUnifiedReference> m_ParentRefIDs;
	HPMTaskCreateUnifiedEntry()
		: m_bIsProxy(0)
		, m_TaskType(EHPMTaskType_Planned)
		, m_TaskLockedType(EHPMTaskLockedType_Normal)
		, m_NonProxy_ReuseID(0)
		, m_NonProxy_WorkflowID(0xffffffff)
		, m_NonProxy_bRestoreFromHistory(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCreateUnifiedEntry(HPMTaskCreateUnifiedEntry const &_Right)
		: m_bIsProxy(_Right.m_bIsProxy)
		, m_LocalID(_Right.m_LocalID)
		, m_ReuseUniqueRefID(_Right.m_ReuseUniqueRefID)
		, m_TaskType(_Right.m_TaskType)
		, m_TaskLockedType(_Right.m_TaskLockedType)
		, m_Proxy_ReferToRefTaskID(_Right.m_Proxy_ReferToRefTaskID)
		, m_NonProxy_ReuseUniqueID(_Right.m_NonProxy_ReuseUniqueID)
		, m_NonProxy_ReuseID(_Right.m_NonProxy_ReuseID)
		, m_NonProxy_WorkflowID(_Right.m_NonProxy_WorkflowID)
		, m_NonProxy_bRestoreFromHistory(_Right.m_NonProxy_bRestoreFromHistory)
		, m_PreviousRefID(_Right.m_PreviousRefID)
		, m_PreviousWorkPrioRefID(_Right.m_PreviousWorkPrioRefID)
		, m_ParentRefIDs(_Right.m_ParentRefIDs)
	{
	}
	HPMTaskCreateUnifiedEntry(HPMTaskCreateUnifiedEntry &&_Right)
		: m_bIsProxy(std::move(_Right.m_bIsProxy))
		, m_LocalID(std::move(_Right.m_LocalID))
		, m_ReuseUniqueRefID(std::move(_Right.m_ReuseUniqueRefID))
		, m_TaskType(std::move(_Right.m_TaskType))
		, m_TaskLockedType(std::move(_Right.m_TaskLockedType))
		, m_Proxy_ReferToRefTaskID(std::move(_Right.m_Proxy_ReferToRefTaskID))
		, m_NonProxy_ReuseUniqueID(std::move(_Right.m_NonProxy_ReuseUniqueID))
		, m_NonProxy_ReuseID(std::move(_Right.m_NonProxy_ReuseID))
		, m_NonProxy_WorkflowID(std::move(_Right.m_NonProxy_WorkflowID))
		, m_NonProxy_bRestoreFromHistory(std::move(_Right.m_NonProxy_bRestoreFromHistory))
		, m_PreviousRefID(std::move(_Right.m_PreviousRefID))
		, m_PreviousWorkPrioRefID(std::move(_Right.m_PreviousWorkPrioRefID))
		, m_ParentRefIDs(std::move(_Right.m_ParentRefIDs))
	{
	}
	HPMTaskCreateUnifiedEntry &operator =(HPMTaskCreateUnifiedEntry const &_Right)
	{
		m_bIsProxy = _Right.m_bIsProxy;
		m_LocalID = _Right.m_LocalID;
		m_ReuseUniqueRefID = _Right.m_ReuseUniqueRefID;
		m_TaskType = _Right.m_TaskType;
		m_TaskLockedType = _Right.m_TaskLockedType;
		m_Proxy_ReferToRefTaskID = _Right.m_Proxy_ReferToRefTaskID;
		m_NonProxy_ReuseUniqueID = _Right.m_NonProxy_ReuseUniqueID;
		m_NonProxy_ReuseID = _Right.m_NonProxy_ReuseID;
		m_NonProxy_WorkflowID = _Right.m_NonProxy_WorkflowID;
		m_NonProxy_bRestoreFromHistory = _Right.m_NonProxy_bRestoreFromHistory;
		m_PreviousRefID = _Right.m_PreviousRefID;
		m_PreviousWorkPrioRefID = _Right.m_PreviousWorkPrioRefID;
		m_ParentRefIDs = _Right.m_ParentRefIDs;
		return *this;
	}
	HPMTaskCreateUnifiedEntry &operator =(HPMTaskCreateUnifiedEntry &&_Right)
	{
		m_bIsProxy = std::move(_Right.m_bIsProxy);
		m_LocalID = std::move(_Right.m_LocalID);
		m_ReuseUniqueRefID = std::move(_Right.m_ReuseUniqueRefID);
		m_TaskType = std::move(_Right.m_TaskType);
		m_TaskLockedType = std::move(_Right.m_TaskLockedType);
		m_Proxy_ReferToRefTaskID = std::move(_Right.m_Proxy_ReferToRefTaskID);
		m_NonProxy_ReuseUniqueID = std::move(_Right.m_NonProxy_ReuseUniqueID);
		m_NonProxy_ReuseID = std::move(_Right.m_NonProxy_ReuseID);
		m_NonProxy_WorkflowID = std::move(_Right.m_NonProxy_WorkflowID);
		m_NonProxy_bRestoreFromHistory = std::move(_Right.m_NonProxy_bRestoreFromHistory);
		m_PreviousRefID = std::move(_Right.m_PreviousRefID);
		m_PreviousWorkPrioRefID = std::move(_Right.m_PreviousWorkPrioRefID);
		m_ParentRefIDs = std::move(_Right.m_ParentRefIDs);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		if (m_bIsProxy != _Right.m_bIsProxy)
			return false;
		if (m_LocalID != _Right.m_LocalID)
			return false;
		if (m_ReuseUniqueRefID != _Right.m_ReuseUniqueRefID)
			return false;
		if (m_TaskType != _Right.m_TaskType)
			return false;
		if (m_TaskLockedType != _Right.m_TaskLockedType)
			return false;
		if (m_Proxy_ReferToRefTaskID != _Right.m_Proxy_ReferToRefTaskID)
			return false;
		if (m_NonProxy_ReuseUniqueID != _Right.m_NonProxy_ReuseUniqueID)
			return false;
		if (m_NonProxy_ReuseID != _Right.m_NonProxy_ReuseID)
			return false;
		if (m_NonProxy_WorkflowID != _Right.m_NonProxy_WorkflowID)
			return false;
		if (m_NonProxy_bRestoreFromHistory != _Right.m_NonProxy_bRestoreFromHistory)
			return false;
		if (m_PreviousRefID != _Right.m_PreviousRefID)
			return false;
		if (m_PreviousWorkPrioRefID != _Right.m_PreviousWorkPrioRefID)
			return false;
		if (m_ParentRefIDs.size() != _Right.m_ParentRefIDs.size())
			return false;
		for (size_t i = 0; i < m_ParentRefIDs.size(); ++i)
			if (m_ParentRefIDs[i] != _Right.m_ParentRefIDs[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		if (m_bIsProxy < _Right.m_bIsProxy)
			return true;
		if (m_bIsProxy > _Right.m_bIsProxy)
			return false;
		if (m_LocalID < _Right.m_LocalID)
			return true;
		if (m_LocalID > _Right.m_LocalID)
			return false;
		if (m_ReuseUniqueRefID < _Right.m_ReuseUniqueRefID)
			return true;
		if (m_ReuseUniqueRefID > _Right.m_ReuseUniqueRefID)
			return false;
		if (m_TaskType < _Right.m_TaskType)
			return true;
		if (m_TaskType > _Right.m_TaskType)
			return false;
		if (m_TaskLockedType < _Right.m_TaskLockedType)
			return true;
		if (m_TaskLockedType > _Right.m_TaskLockedType)
			return false;
		if (m_Proxy_ReferToRefTaskID < _Right.m_Proxy_ReferToRefTaskID)
			return true;
		if (m_Proxy_ReferToRefTaskID > _Right.m_Proxy_ReferToRefTaskID)
			return false;
		if (m_NonProxy_ReuseUniqueID < _Right.m_NonProxy_ReuseUniqueID)
			return true;
		if (m_NonProxy_ReuseUniqueID > _Right.m_NonProxy_ReuseUniqueID)
			return false;
		if (m_NonProxy_ReuseID < _Right.m_NonProxy_ReuseID)
			return true;
		if (m_NonProxy_ReuseID > _Right.m_NonProxy_ReuseID)
			return false;
		if (m_NonProxy_WorkflowID < _Right.m_NonProxy_WorkflowID)
			return true;
		if (m_NonProxy_WorkflowID > _Right.m_NonProxy_WorkflowID)
			return false;
		if (m_NonProxy_bRestoreFromHistory < _Right.m_NonProxy_bRestoreFromHistory)
			return true;
		if (m_NonProxy_bRestoreFromHistory > _Right.m_NonProxy_bRestoreFromHistory)
			return false;
		if (m_PreviousRefID < _Right.m_PreviousRefID)
			return true;
		if (m_PreviousRefID > _Right.m_PreviousRefID)
			return false;
		if (m_PreviousWorkPrioRefID < _Right.m_PreviousWorkPrioRefID)
			return true;
		if (m_PreviousWorkPrioRefID > _Right.m_PreviousWorkPrioRefID)
			return false;
		if (m_ParentRefIDs.size() < _Right.m_ParentRefIDs.size())
			return true;
		if (m_ParentRefIDs.size() > _Right.m_ParentRefIDs.size())
			return false;
		for (size_t i = 0; i < m_ParentRefIDs.size(); ++i)
		{
			if (m_ParentRefIDs[i] < _Right.m_ParentRefIDs[i])
				return true;
			if (m_ParentRefIDs[i] > _Right.m_ParentRefIDs[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCreateUnifiedEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCreateUnified
{
	public:
	std::vector<HPMTaskCreateUnifiedEntry> m_Tasks;
	HPMTaskCreateUnified()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCreateUnified(HPMTaskCreateUnified const &_Right)
		: m_Tasks(_Right.m_Tasks)
	{
	}
	HPMTaskCreateUnified(HPMTaskCreateUnified &&_Right)
		: m_Tasks(std::move(_Right.m_Tasks))
	{
	}
	HPMTaskCreateUnified &operator =(HPMTaskCreateUnified const &_Right)
	{
		m_Tasks = _Right.m_Tasks;
		return *this;
	}
	HPMTaskCreateUnified &operator =(HPMTaskCreateUnified &&_Right)
	{
		m_Tasks = std::move(_Right.m_Tasks);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCreateUnified &_Right) const
	{
		if (m_Tasks.size() != _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
			if (m_Tasks[i] != _Right.m_Tasks[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskCreateUnified &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCreateUnified &_Right) const
	{
		if (m_Tasks.size() < _Right.m_Tasks.size())
			return true;
		if (m_Tasks.size() > _Right.m_Tasks.size())
			return false;
		for (size_t i = 0; i < m_Tasks.size(); ++i)
		{
			if (m_Tasks[i] < _Right.m_Tasks[i])
				return true;
			if (m_Tasks[i] > _Right.m_Tasks[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskCreateUnified &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCreateUnified &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCreateUnified &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskChangeDispositionEntry
{
	public:
	HPMUniqueID m_TaskRefID;
	EHPMTaskChangeDispositionEntryChangeFlag m_ChangeFlags;
	HPMUniqueID m_PreviousRefID;
	HPMUInt32 m_TreeLevel;
	HPMUniqueID m_LinkedToSprint;
	HPMUniqueID m_LinkedToPipelineTask;
	EHPMTaskType m_TaskType;
	EHPMTaskLockedType m_TaskLockedType;
	HPMTaskChangeDispositionEntry()
		: m_ChangeFlags(EHPMTaskChangeDispositionEntryChangeFlag_None)
		, m_TreeLevel(0)
		, m_TaskType(EHPMTaskType_Planned)
		, m_TaskLockedType(EHPMTaskLockedType_Normal)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskChangeDispositionEntry(HPMTaskChangeDispositionEntry const &_Right)
		: m_TaskRefID(_Right.m_TaskRefID)
		, m_ChangeFlags(_Right.m_ChangeFlags)
		, m_PreviousRefID(_Right.m_PreviousRefID)
		, m_TreeLevel(_Right.m_TreeLevel)
		, m_LinkedToSprint(_Right.m_LinkedToSprint)
		, m_LinkedToPipelineTask(_Right.m_LinkedToPipelineTask)
		, m_TaskType(_Right.m_TaskType)
		, m_TaskLockedType(_Right.m_TaskLockedType)
	{
	}
	HPMTaskChangeDispositionEntry(HPMTaskChangeDispositionEntry &&_Right)
		: m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_ChangeFlags(std::move(_Right.m_ChangeFlags))
		, m_PreviousRefID(std::move(_Right.m_PreviousRefID))
		, m_TreeLevel(std::move(_Right.m_TreeLevel))
		, m_LinkedToSprint(std::move(_Right.m_LinkedToSprint))
		, m_LinkedToPipelineTask(std::move(_Right.m_LinkedToPipelineTask))
		, m_TaskType(std::move(_Right.m_TaskType))
		, m_TaskLockedType(std::move(_Right.m_TaskLockedType))
	{
	}
	HPMTaskChangeDispositionEntry &operator =(HPMTaskChangeDispositionEntry const &_Right)
	{
		m_TaskRefID = _Right.m_TaskRefID;
		m_ChangeFlags = _Right.m_ChangeFlags;
		m_PreviousRefID = _Right.m_PreviousRefID;
		m_TreeLevel = _Right.m_TreeLevel;
		m_LinkedToSprint = _Right.m_LinkedToSprint;
		m_LinkedToPipelineTask = _Right.m_LinkedToPipelineTask;
		m_TaskType = _Right.m_TaskType;
		m_TaskLockedType = _Right.m_TaskLockedType;
		return *this;
	}
	HPMTaskChangeDispositionEntry &operator =(HPMTaskChangeDispositionEntry &&_Right)
	{
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_ChangeFlags = std::move(_Right.m_ChangeFlags);
		m_PreviousRefID = std::move(_Right.m_PreviousRefID);
		m_TreeLevel = std::move(_Right.m_TreeLevel);
		m_LinkedToSprint = std::move(_Right.m_LinkedToSprint);
		m_LinkedToPipelineTask = std::move(_Right.m_LinkedToPipelineTask);
		m_TaskType = std::move(_Right.m_TaskType);
		m_TaskLockedType = std::move(_Right.m_TaskLockedType);
		return *this;
	}
#endif
	bool operator == (const HPMTaskChangeDispositionEntry &_Right) const
	{
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_ChangeFlags != _Right.m_ChangeFlags)
			return false;
		if (m_PreviousRefID != _Right.m_PreviousRefID)
			return false;
		if (m_TreeLevel != _Right.m_TreeLevel)
			return false;
		if (m_LinkedToSprint != _Right.m_LinkedToSprint)
			return false;
		if (m_LinkedToPipelineTask != _Right.m_LinkedToPipelineTask)
			return false;
		if (m_TaskType != _Right.m_TaskType)
			return false;
		if (m_TaskLockedType != _Right.m_TaskLockedType)
			return false;
		return true;
	}
	bool operator != (const HPMTaskChangeDispositionEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskChangeDispositionEntry &_Right) const
	{
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_ChangeFlags < _Right.m_ChangeFlags)
			return true;
		if (m_ChangeFlags > _Right.m_ChangeFlags)
			return false;
		if (m_PreviousRefID < _Right.m_PreviousRefID)
			return true;
		if (m_PreviousRefID > _Right.m_PreviousRefID)
			return false;
		if (m_TreeLevel < _Right.m_TreeLevel)
			return true;
		if (m_TreeLevel > _Right.m_TreeLevel)
			return false;
		if (m_LinkedToSprint < _Right.m_LinkedToSprint)
			return true;
		if (m_LinkedToSprint > _Right.m_LinkedToSprint)
			return false;
		if (m_LinkedToPipelineTask < _Right.m_LinkedToPipelineTask)
			return true;
		if (m_LinkedToPipelineTask > _Right.m_LinkedToPipelineTask)
			return false;
		if (m_TaskType < _Right.m_TaskType)
			return true;
		if (m_TaskType > _Right.m_TaskType)
			return false;
		if (m_TaskLockedType < _Right.m_TaskLockedType)
			return true;
		if (m_TaskLockedType > _Right.m_TaskLockedType)
			return false;
		return false;
	}
	bool operator > (const HPMTaskChangeDispositionEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskChangeDispositionEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskChangeDispositionEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskChangeDisposition
{
	public:
	EHPMTaskChangeDispositionOptionFlag m_OptionFlags;
	std::vector<HPMTaskChangeDispositionEntry> m_TasksToChange;
	HPMTaskChangeDisposition()
		: m_OptionFlags(EHPMTaskChangeDispositionOptionFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskChangeDisposition(HPMTaskChangeDisposition const &_Right)
		: m_OptionFlags(_Right.m_OptionFlags)
		, m_TasksToChange(_Right.m_TasksToChange)
	{
	}
	HPMTaskChangeDisposition(HPMTaskChangeDisposition &&_Right)
		: m_OptionFlags(std::move(_Right.m_OptionFlags))
		, m_TasksToChange(std::move(_Right.m_TasksToChange))
	{
	}
	HPMTaskChangeDisposition &operator =(HPMTaskChangeDisposition const &_Right)
	{
		m_OptionFlags = _Right.m_OptionFlags;
		m_TasksToChange = _Right.m_TasksToChange;
		return *this;
	}
	HPMTaskChangeDisposition &operator =(HPMTaskChangeDisposition &&_Right)
	{
		m_OptionFlags = std::move(_Right.m_OptionFlags);
		m_TasksToChange = std::move(_Right.m_TasksToChange);
		return *this;
	}
#endif
	bool operator == (const HPMTaskChangeDisposition &_Right) const
	{
		if (m_OptionFlags != _Right.m_OptionFlags)
			return false;
		if (m_TasksToChange.size() != _Right.m_TasksToChange.size())
			return false;
		for (size_t i = 0; i < m_TasksToChange.size(); ++i)
			if (m_TasksToChange[i] != _Right.m_TasksToChange[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskChangeDisposition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskChangeDisposition &_Right) const
	{
		if (m_OptionFlags < _Right.m_OptionFlags)
			return true;
		if (m_OptionFlags > _Right.m_OptionFlags)
			return false;
		if (m_TasksToChange.size() < _Right.m_TasksToChange.size())
			return true;
		if (m_TasksToChange.size() > _Right.m_TasksToChange.size())
			return false;
		for (size_t i = 0; i < m_TasksToChange.size(); ++i)
		{
			if (m_TasksToChange[i] < _Right.m_TasksToChange[i])
				return true;
			if (m_TasksToChange[i] > _Right.m_TasksToChange[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskChangeDisposition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskChangeDisposition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskChangeDisposition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskAttachedDocumentsEntry
{
	public:
	HPMUniqueID m_AddedByResource;
	HPMUInt64 m_FileID;
	HPMTaskAttachedDocumentsEntry()
		: m_FileID(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskAttachedDocumentsEntry(HPMTaskAttachedDocumentsEntry const &_Right)
		: m_AddedByResource(_Right.m_AddedByResource)
		, m_FileID(_Right.m_FileID)
	{
	}
	HPMTaskAttachedDocumentsEntry(HPMTaskAttachedDocumentsEntry &&_Right)
		: m_AddedByResource(std::move(_Right.m_AddedByResource))
		, m_FileID(std::move(_Right.m_FileID))
	{
	}
	HPMTaskAttachedDocumentsEntry &operator =(HPMTaskAttachedDocumentsEntry const &_Right)
	{
		m_AddedByResource = _Right.m_AddedByResource;
		m_FileID = _Right.m_FileID;
		return *this;
	}
	HPMTaskAttachedDocumentsEntry &operator =(HPMTaskAttachedDocumentsEntry &&_Right)
	{
		m_AddedByResource = std::move(_Right.m_AddedByResource);
		m_FileID = std::move(_Right.m_FileID);
		return *this;
	}
#endif
	bool operator == (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		if (m_AddedByResource != _Right.m_AddedByResource)
			return false;
		if (m_FileID != _Right.m_FileID)
			return false;
		return true;
	}
	bool operator != (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		if (m_AddedByResource < _Right.m_AddedByResource)
			return true;
		if (m_AddedByResource > _Right.m_AddedByResource)
			return false;
		if (m_FileID < _Right.m_FileID)
			return true;
		if (m_FileID > _Right.m_FileID)
			return false;
		return false;
	}
	bool operator > (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskAttachedDocumentsEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskAttachedDocuments
{
	public:
	std::vector<HPMTaskAttachedDocumentsEntry> m_AttachedDocuments;
	HPMTaskAttachedDocuments()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskAttachedDocuments(HPMTaskAttachedDocuments const &_Right)
		: m_AttachedDocuments(_Right.m_AttachedDocuments)
	{
	}
	HPMTaskAttachedDocuments(HPMTaskAttachedDocuments &&_Right)
		: m_AttachedDocuments(std::move(_Right.m_AttachedDocuments))
	{
	}
	HPMTaskAttachedDocuments &operator =(HPMTaskAttachedDocuments const &_Right)
	{
		m_AttachedDocuments = _Right.m_AttachedDocuments;
		return *this;
	}
	HPMTaskAttachedDocuments &operator =(HPMTaskAttachedDocuments &&_Right)
	{
		m_AttachedDocuments = std::move(_Right.m_AttachedDocuments);
		return *this;
	}
#endif
	bool operator == (const HPMTaskAttachedDocuments &_Right) const
	{
		if (m_AttachedDocuments.size() != _Right.m_AttachedDocuments.size())
			return false;
		for (size_t i = 0; i < m_AttachedDocuments.size(); ++i)
			if (m_AttachedDocuments[i] != _Right.m_AttachedDocuments[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskAttachedDocuments &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskAttachedDocuments &_Right) const
	{
		if (m_AttachedDocuments.size() < _Right.m_AttachedDocuments.size())
			return true;
		if (m_AttachedDocuments.size() > _Right.m_AttachedDocuments.size())
			return false;
		for (size_t i = 0; i < m_AttachedDocuments.size(); ++i)
		{
			if (m_AttachedDocuments[i] < _Right.m_AttachedDocuments[i])
				return true;
			if (m_AttachedDocuments[i] > _Right.m_AttachedDocuments[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskAttachedDocuments &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskAttachedDocuments &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskAttachedDocuments &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskResourceAllocationResource
{
	public:
	HPMUniqueID m_ResourceID;
	HPMInt32 m_PercentAllocated;
	HPMTaskResourceAllocationResource()
		: m_PercentAllocated(100)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskResourceAllocationResource(HPMTaskResourceAllocationResource const &_Right)
		: m_ResourceID(_Right.m_ResourceID)
		, m_PercentAllocated(_Right.m_PercentAllocated)
	{
	}
	HPMTaskResourceAllocationResource(HPMTaskResourceAllocationResource &&_Right)
		: m_ResourceID(std::move(_Right.m_ResourceID))
		, m_PercentAllocated(std::move(_Right.m_PercentAllocated))
	{
	}
	HPMTaskResourceAllocationResource &operator =(HPMTaskResourceAllocationResource const &_Right)
	{
		m_ResourceID = _Right.m_ResourceID;
		m_PercentAllocated = _Right.m_PercentAllocated;
		return *this;
	}
	HPMTaskResourceAllocationResource &operator =(HPMTaskResourceAllocationResource &&_Right)
	{
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_PercentAllocated = std::move(_Right.m_PercentAllocated);
		return *this;
	}
#endif
	bool operator == (const HPMTaskResourceAllocationResource &_Right) const
	{
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_PercentAllocated != _Right.m_PercentAllocated)
			return false;
		return true;
	}
	bool operator != (const HPMTaskResourceAllocationResource &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskResourceAllocationResource &_Right) const
	{
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_PercentAllocated < _Right.m_PercentAllocated)
			return true;
		if (m_PercentAllocated > _Right.m_PercentAllocated)
			return false;
		return false;
	}
	bool operator > (const HPMTaskResourceAllocationResource &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskResourceAllocationResource &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskResourceAllocationResource &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskResourceAllocation
{
	public:
	std::vector<HPMTaskResourceAllocationResource> m_Resources;
	HPMTaskResourceAllocation()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskResourceAllocation(HPMTaskResourceAllocation const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMTaskResourceAllocation(HPMTaskResourceAllocation &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMTaskResourceAllocation &operator =(HPMTaskResourceAllocation const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMTaskResourceAllocation &operator =(HPMTaskResourceAllocation &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMTaskResourceAllocation &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskResourceAllocation &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskResourceAllocation &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskResourceAllocation &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskResourceAllocation &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskResourceAllocation &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceReference
{
	public:
	EHPMResourceGroupingType m_ResourceType;
	HPMUniqueID m_ID;
	HPMResourceReference()
		: m_ResourceType(EHPMResourceGroupingType_Resource)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceReference(HPMResourceReference const &_Right)
		: m_ResourceType(_Right.m_ResourceType)
		, m_ID(_Right.m_ID)
	{
	}
	HPMResourceReference(HPMResourceReference &&_Right)
		: m_ResourceType(std::move(_Right.m_ResourceType))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMResourceReference &operator =(HPMResourceReference const &_Right)
	{
		m_ResourceType = _Right.m_ResourceType;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMResourceReference &operator =(HPMResourceReference &&_Right)
	{
		m_ResourceType = std::move(_Right.m_ResourceType);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMResourceReference &_Right) const
	{
		if (m_ResourceType != _Right.m_ResourceType)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMResourceReference &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceReference &_Right) const
	{
		if (m_ResourceType < _Right.m_ResourceType)
			return true;
		if (m_ResourceType > _Right.m_ResourceType)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMResourceReference &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceReference &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceReference &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskSprintAllocatedResources
{
	public:
	std::vector<HPMResourceReference> m_Resources;
	HPMTaskSprintAllocatedResources()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskSprintAllocatedResources(HPMTaskSprintAllocatedResources const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMTaskSprintAllocatedResources(HPMTaskSprintAllocatedResources &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMTaskSprintAllocatedResources &operator =(HPMTaskSprintAllocatedResources const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMTaskSprintAllocatedResources &operator =(HPMTaskSprintAllocatedResources &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMTaskSprintAllocatedResources &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskSprintAllocatedResources &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskSprintAllocatedResources &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskSprintAllocatedResources &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskSprintAllocatedResources &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskSprintAllocatedResources &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskSprintResourceAllocationResource
{
	public:
	HPMUniqueID m_ID;
	HPMUInt32 m_AllocatedPercent;
	HPMTaskSprintResourceAllocationResource()
		: m_AllocatedPercent(100)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskSprintResourceAllocationResource(HPMTaskSprintResourceAllocationResource const &_Right)
		: m_ID(_Right.m_ID)
		, m_AllocatedPercent(_Right.m_AllocatedPercent)
	{
	}
	HPMTaskSprintResourceAllocationResource(HPMTaskSprintResourceAllocationResource &&_Right)
		: m_ID(std::move(_Right.m_ID))
		, m_AllocatedPercent(std::move(_Right.m_AllocatedPercent))
	{
	}
	HPMTaskSprintResourceAllocationResource &operator =(HPMTaskSprintResourceAllocationResource const &_Right)
	{
		m_ID = _Right.m_ID;
		m_AllocatedPercent = _Right.m_AllocatedPercent;
		return *this;
	}
	HPMTaskSprintResourceAllocationResource &operator =(HPMTaskSprintResourceAllocationResource &&_Right)
	{
		m_ID = std::move(_Right.m_ID);
		m_AllocatedPercent = std::move(_Right.m_AllocatedPercent);
		return *this;
	}
#endif
	bool operator == (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		if (m_ID != _Right.m_ID)
			return false;
		if (m_AllocatedPercent != _Right.m_AllocatedPercent)
			return false;
		return true;
	}
	bool operator != (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		if (m_AllocatedPercent < _Right.m_AllocatedPercent)
			return true;
		if (m_AllocatedPercent > _Right.m_AllocatedPercent)
			return false;
		return false;
	}
	bool operator > (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskSprintResourceAllocationResource &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskSprintResourceAllocation
{
	public:
	std::vector<HPMTaskSprintResourceAllocationResource> m_Resources;
	HPMTaskSprintResourceAllocation()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskSprintResourceAllocation(HPMTaskSprintResourceAllocation const &_Right)
		: m_Resources(_Right.m_Resources)
	{
	}
	HPMTaskSprintResourceAllocation(HPMTaskSprintResourceAllocation &&_Right)
		: m_Resources(std::move(_Right.m_Resources))
	{
	}
	HPMTaskSprintResourceAllocation &operator =(HPMTaskSprintResourceAllocation const &_Right)
	{
		m_Resources = _Right.m_Resources;
		return *this;
	}
	HPMTaskSprintResourceAllocation &operator =(HPMTaskSprintResourceAllocation &&_Right)
	{
		m_Resources = std::move(_Right.m_Resources);
		return *this;
	}
#endif
	bool operator == (const HPMTaskSprintResourceAllocation &_Right) const
	{
		if (m_Resources.size() != _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
			if (m_Resources[i] != _Right.m_Resources[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskSprintResourceAllocation &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskSprintResourceAllocation &_Right) const
	{
		if (m_Resources.size() < _Right.m_Resources.size())
			return true;
		if (m_Resources.size() > _Right.m_Resources.size())
			return false;
		for (size_t i = 0; i < m_Resources.size(); ++i)
		{
			if (m_Resources[i] < _Right.m_Resources[i])
				return true;
			if (m_Resources[i] > _Right.m_Resources[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskSprintResourceAllocation &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskSprintResourceAllocation &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskSprintResourceAllocation &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskTimeZonesZone
{
	public:
	HPMUInt64 m_Start;
	HPMUInt64 m_End;
	HPMTaskTimeZonesZone()
		: m_Start(0)
		, m_End(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskTimeZonesZone(HPMTaskTimeZonesZone const &_Right)
		: m_Start(_Right.m_Start)
		, m_End(_Right.m_End)
	{
	}
	HPMTaskTimeZonesZone(HPMTaskTimeZonesZone &&_Right)
		: m_Start(std::move(_Right.m_Start))
		, m_End(std::move(_Right.m_End))
	{
	}
	HPMTaskTimeZonesZone &operator =(HPMTaskTimeZonesZone const &_Right)
	{
		m_Start = _Right.m_Start;
		m_End = _Right.m_End;
		return *this;
	}
	HPMTaskTimeZonesZone &operator =(HPMTaskTimeZonesZone &&_Right)
	{
		m_Start = std::move(_Right.m_Start);
		m_End = std::move(_Right.m_End);
		return *this;
	}
#endif
	bool operator == (const HPMTaskTimeZonesZone &_Right) const
	{
		if (m_Start != _Right.m_Start)
			return false;
		if (m_End != _Right.m_End)
			return false;
		return true;
	}
	bool operator != (const HPMTaskTimeZonesZone &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskTimeZonesZone &_Right) const
	{
		if (m_Start < _Right.m_Start)
			return true;
		if (m_Start > _Right.m_Start)
			return false;
		if (m_End < _Right.m_End)
			return true;
		if (m_End > _Right.m_End)
			return false;
		return false;
	}
	bool operator > (const HPMTaskTimeZonesZone &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskTimeZonesZone &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskTimeZonesZone &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskTimeZones
{
	public:
	std::vector<HPMTaskTimeZonesZone> m_Zones;
	HPMTaskTimeZones()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskTimeZones(HPMTaskTimeZones const &_Right)
		: m_Zones(_Right.m_Zones)
	{
	}
	HPMTaskTimeZones(HPMTaskTimeZones &&_Right)
		: m_Zones(std::move(_Right.m_Zones))
	{
	}
	HPMTaskTimeZones &operator =(HPMTaskTimeZones const &_Right)
	{
		m_Zones = _Right.m_Zones;
		return *this;
	}
	HPMTaskTimeZones &operator =(HPMTaskTimeZones &&_Right)
	{
		m_Zones = std::move(_Right.m_Zones);
		return *this;
	}
#endif
	bool operator == (const HPMTaskTimeZones &_Right) const
	{
		if (m_Zones.size() != _Right.m_Zones.size())
			return false;
		for (size_t i = 0; i < m_Zones.size(); ++i)
			if (m_Zones[i] != _Right.m_Zones[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskTimeZones &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskTimeZones &_Right) const
	{
		if (m_Zones.size() < _Right.m_Zones.size())
			return true;
		if (m_Zones.size() > _Right.m_Zones.size())
			return false;
		for (size_t i = 0; i < m_Zones.size(); ++i)
		{
			if (m_Zones[i] < _Right.m_Zones[i])
				return true;
			if (m_Zones[i] > _Right.m_Zones[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskTimeZones &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskTimeZones &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskTimeZones &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskUIDHistory
{
	public:
	std::vector<HPMUniqueID> m_UIDs;
	HPMTaskUIDHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskUIDHistory(HPMTaskUIDHistory const &_Right)
		: m_UIDs(_Right.m_UIDs)
	{
	}
	HPMTaskUIDHistory(HPMTaskUIDHistory &&_Right)
		: m_UIDs(std::move(_Right.m_UIDs))
	{
	}
	HPMTaskUIDHistory &operator =(HPMTaskUIDHistory const &_Right)
	{
		m_UIDs = _Right.m_UIDs;
		return *this;
	}
	HPMTaskUIDHistory &operator =(HPMTaskUIDHistory &&_Right)
	{
		m_UIDs = std::move(_Right.m_UIDs);
		return *this;
	}
#endif
	bool operator == (const HPMTaskUIDHistory &_Right) const
	{
		if (m_UIDs.size() != _Right.m_UIDs.size())
			return false;
		for (size_t i = 0; i < m_UIDs.size(); ++i)
			if (m_UIDs[i] != _Right.m_UIDs[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskUIDHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskUIDHistory &_Right) const
	{
		if (m_UIDs.size() < _Right.m_UIDs.size())
			return true;
		if (m_UIDs.size() > _Right.m_UIDs.size())
			return false;
		for (size_t i = 0; i < m_UIDs.size(); ++i)
		{
			if (m_UIDs[i] < _Right.m_UIDs[i])
				return true;
			if (m_UIDs[i] > _Right.m_UIDs[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskUIDHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskUIDHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskUIDHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMResourceAllocationHistoryEntry
{
	public:
	HPMUniqueID m_ResourceID;
	HPMInt32 m_PercentAllocated;
	HPMResourceAllocationHistoryEntry()
		: m_PercentAllocated(100)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMResourceAllocationHistoryEntry(HPMResourceAllocationHistoryEntry const &_Right)
		: m_ResourceID(_Right.m_ResourceID)
		, m_PercentAllocated(_Right.m_PercentAllocated)
	{
	}
	HPMResourceAllocationHistoryEntry(HPMResourceAllocationHistoryEntry &&_Right)
		: m_ResourceID(std::move(_Right.m_ResourceID))
		, m_PercentAllocated(std::move(_Right.m_PercentAllocated))
	{
	}
	HPMResourceAllocationHistoryEntry &operator =(HPMResourceAllocationHistoryEntry const &_Right)
	{
		m_ResourceID = _Right.m_ResourceID;
		m_PercentAllocated = _Right.m_PercentAllocated;
		return *this;
	}
	HPMResourceAllocationHistoryEntry &operator =(HPMResourceAllocationHistoryEntry &&_Right)
	{
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_PercentAllocated = std::move(_Right.m_PercentAllocated);
		return *this;
	}
#endif
	bool operator == (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_PercentAllocated != _Right.m_PercentAllocated)
			return false;
		return true;
	}
	bool operator != (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_PercentAllocated < _Right.m_PercentAllocated)
			return true;
		if (m_PercentAllocated > _Right.m_PercentAllocated)
			return false;
		return false;
	}
	bool operator > (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMResourceAllocationHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskWorkRemainingHistoryEntry
{
	public:
	HPMUniqueID m_TaskRefID;
	HPMFP32 m_nHoursRemaining;
	bool m_bResourcesValid;
	std::vector<HPMResourceAllocationHistoryEntry> m_ResourceAllocationEntries;
	HPMTaskWorkRemainingHistoryEntry()
		: m_nHoursRemaining(0.0f)
		, m_bResourcesValid(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskWorkRemainingHistoryEntry(HPMTaskWorkRemainingHistoryEntry const &_Right)
		: m_TaskRefID(_Right.m_TaskRefID)
		, m_nHoursRemaining(_Right.m_nHoursRemaining)
		, m_bResourcesValid(_Right.m_bResourcesValid)
		, m_ResourceAllocationEntries(_Right.m_ResourceAllocationEntries)
	{
	}
	HPMTaskWorkRemainingHistoryEntry(HPMTaskWorkRemainingHistoryEntry &&_Right)
		: m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_nHoursRemaining(std::move(_Right.m_nHoursRemaining))
		, m_bResourcesValid(std::move(_Right.m_bResourcesValid))
		, m_ResourceAllocationEntries(std::move(_Right.m_ResourceAllocationEntries))
	{
	}
	HPMTaskWorkRemainingHistoryEntry &operator =(HPMTaskWorkRemainingHistoryEntry const &_Right)
	{
		m_TaskRefID = _Right.m_TaskRefID;
		m_nHoursRemaining = _Right.m_nHoursRemaining;
		m_bResourcesValid = _Right.m_bResourcesValid;
		m_ResourceAllocationEntries = _Right.m_ResourceAllocationEntries;
		return *this;
	}
	HPMTaskWorkRemainingHistoryEntry &operator =(HPMTaskWorkRemainingHistoryEntry &&_Right)
	{
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_nHoursRemaining = std::move(_Right.m_nHoursRemaining);
		m_bResourcesValid = std::move(_Right.m_bResourcesValid);
		m_ResourceAllocationEntries = std::move(_Right.m_ResourceAllocationEntries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_nHoursRemaining != _Right.m_nHoursRemaining)
			return false;
		if (m_bResourcesValid != _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() != _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
			if (m_ResourceAllocationEntries[i] != _Right.m_ResourceAllocationEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_nHoursRemaining < _Right.m_nHoursRemaining)
			return true;
		if (m_nHoursRemaining > _Right.m_nHoursRemaining)
			return false;
		if (m_bResourcesValid < _Right.m_bResourcesValid)
			return true;
		if (m_bResourcesValid > _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() < _Right.m_ResourceAllocationEntries.size())
			return true;
		if (m_ResourceAllocationEntries.size() > _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
		{
			if (m_ResourceAllocationEntries[i] < _Right.m_ResourceAllocationEntries[i])
				return true;
			if (m_ResourceAllocationEntries[i] > _Right.m_ResourceAllocationEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskWorkRemainingHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskWorkRemainingHistory
{
	public:
	std::vector<HPMTaskWorkRemainingHistoryEntry> m_Entries;
	HPMTaskWorkRemainingHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskWorkRemainingHistory(HPMTaskWorkRemainingHistory const &_Right)
		: m_Entries(_Right.m_Entries)
	{
	}
	HPMTaskWorkRemainingHistory(HPMTaskWorkRemainingHistory &&_Right)
		: m_Entries(std::move(_Right.m_Entries))
	{
	}
	HPMTaskWorkRemainingHistory &operator =(HPMTaskWorkRemainingHistory const &_Right)
	{
		m_Entries = _Right.m_Entries;
		return *this;
	}
	HPMTaskWorkRemainingHistory &operator =(HPMTaskWorkRemainingHistory &&_Right)
	{
		m_Entries = std::move(_Right.m_Entries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskWorkRemainingHistory &_Right) const
	{
		if (m_Entries.size() != _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
			if (m_Entries[i] != _Right.m_Entries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskWorkRemainingHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskWorkRemainingHistory &_Right) const
	{
		if (m_Entries.size() < _Right.m_Entries.size())
			return true;
		if (m_Entries.size() > _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
		{
			if (m_Entries[i] < _Right.m_Entries[i])
				return true;
			if (m_Entries[i] > _Right.m_Entries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskWorkRemainingHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskWorkRemainingHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskWorkRemainingHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskWorkRemainingHistoryDaysEnum
{
	public:
	std::vector<HPMUInt32> m_Days;
	HPMTaskWorkRemainingHistoryDaysEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskWorkRemainingHistoryDaysEnum(HPMTaskWorkRemainingHistoryDaysEnum const &_Right)
		: m_Days(_Right.m_Days)
	{
	}
	HPMTaskWorkRemainingHistoryDaysEnum(HPMTaskWorkRemainingHistoryDaysEnum &&_Right)
		: m_Days(std::move(_Right.m_Days))
	{
	}
	HPMTaskWorkRemainingHistoryDaysEnum &operator =(HPMTaskWorkRemainingHistoryDaysEnum const &_Right)
	{
		m_Days = _Right.m_Days;
		return *this;
	}
	HPMTaskWorkRemainingHistoryDaysEnum &operator =(HPMTaskWorkRemainingHistoryDaysEnum &&_Right)
	{
		m_Days = std::move(_Right.m_Days);
		return *this;
	}
#endif
	bool operator == (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		if (m_Days.size() != _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
			if (m_Days[i] != _Right.m_Days[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		if (m_Days.size() < _Right.m_Days.size())
			return true;
		if (m_Days.size() > _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
		{
			if (m_Days[i] < _Right.m_Days[i])
				return true;
			if (m_Days[i] > _Right.m_Days[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskWorkRemainingHistoryDaysEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskIdealDaysHistoryEntry
{
	public:
	HPMUniqueID m_TaskRefID;
	HPMFP32 m_Value;
	HPMFP32 m_ValueNotDone;
	bool m_bResourcesValid;
	std::vector<HPMResourceAllocationHistoryEntry> m_ResourceAllocationEntries;
	HPMTaskIdealDaysHistoryEntry()
		: m_Value(0.0f)
		, m_ValueNotDone(0.0f)
		, m_bResourcesValid(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskIdealDaysHistoryEntry(HPMTaskIdealDaysHistoryEntry const &_Right)
		: m_TaskRefID(_Right.m_TaskRefID)
		, m_Value(_Right.m_Value)
		, m_ValueNotDone(_Right.m_ValueNotDone)
		, m_bResourcesValid(_Right.m_bResourcesValid)
		, m_ResourceAllocationEntries(_Right.m_ResourceAllocationEntries)
	{
	}
	HPMTaskIdealDaysHistoryEntry(HPMTaskIdealDaysHistoryEntry &&_Right)
		: m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_Value(std::move(_Right.m_Value))
		, m_ValueNotDone(std::move(_Right.m_ValueNotDone))
		, m_bResourcesValid(std::move(_Right.m_bResourcesValid))
		, m_ResourceAllocationEntries(std::move(_Right.m_ResourceAllocationEntries))
	{
	}
	HPMTaskIdealDaysHistoryEntry &operator =(HPMTaskIdealDaysHistoryEntry const &_Right)
	{
		m_TaskRefID = _Right.m_TaskRefID;
		m_Value = _Right.m_Value;
		m_ValueNotDone = _Right.m_ValueNotDone;
		m_bResourcesValid = _Right.m_bResourcesValid;
		m_ResourceAllocationEntries = _Right.m_ResourceAllocationEntries;
		return *this;
	}
	HPMTaskIdealDaysHistoryEntry &operator =(HPMTaskIdealDaysHistoryEntry &&_Right)
	{
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_Value = std::move(_Right.m_Value);
		m_ValueNotDone = std::move(_Right.m_ValueNotDone);
		m_bResourcesValid = std::move(_Right.m_bResourcesValid);
		m_ResourceAllocationEntries = std::move(_Right.m_ResourceAllocationEntries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_Value != _Right.m_Value)
			return false;
		if (m_ValueNotDone != _Right.m_ValueNotDone)
			return false;
		if (m_bResourcesValid != _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() != _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
			if (m_ResourceAllocationEntries[i] != _Right.m_ResourceAllocationEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_Value < _Right.m_Value)
			return true;
		if (m_Value > _Right.m_Value)
			return false;
		if (m_ValueNotDone < _Right.m_ValueNotDone)
			return true;
		if (m_ValueNotDone > _Right.m_ValueNotDone)
			return false;
		if (m_bResourcesValid < _Right.m_bResourcesValid)
			return true;
		if (m_bResourcesValid > _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() < _Right.m_ResourceAllocationEntries.size())
			return true;
		if (m_ResourceAllocationEntries.size() > _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
		{
			if (m_ResourceAllocationEntries[i] < _Right.m_ResourceAllocationEntries[i])
				return true;
			if (m_ResourceAllocationEntries[i] > _Right.m_ResourceAllocationEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskIdealDaysHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskIdealDaysHistory
{
	public:
	std::vector<HPMTaskIdealDaysHistoryEntry> m_Entries;
	HPMTaskIdealDaysHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskIdealDaysHistory(HPMTaskIdealDaysHistory const &_Right)
		: m_Entries(_Right.m_Entries)
	{
	}
	HPMTaskIdealDaysHistory(HPMTaskIdealDaysHistory &&_Right)
		: m_Entries(std::move(_Right.m_Entries))
	{
	}
	HPMTaskIdealDaysHistory &operator =(HPMTaskIdealDaysHistory const &_Right)
	{
		m_Entries = _Right.m_Entries;
		return *this;
	}
	HPMTaskIdealDaysHistory &operator =(HPMTaskIdealDaysHistory &&_Right)
	{
		m_Entries = std::move(_Right.m_Entries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskIdealDaysHistory &_Right) const
	{
		if (m_Entries.size() != _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
			if (m_Entries[i] != _Right.m_Entries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskIdealDaysHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskIdealDaysHistory &_Right) const
	{
		if (m_Entries.size() < _Right.m_Entries.size())
			return true;
		if (m_Entries.size() > _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
		{
			if (m_Entries[i] < _Right.m_Entries[i])
				return true;
			if (m_Entries[i] > _Right.m_Entries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskIdealDaysHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskIdealDaysHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskIdealDaysHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskPointsHistoryEntry
{
	public:
	HPMUniqueID m_TaskRefID;
	HPMInt32 m_Value;
	HPMInt32 m_ValueNotDone;
	bool m_bResourcesValid;
	std::vector<HPMResourceAllocationHistoryEntry> m_ResourceAllocationEntries;
	HPMTaskPointsHistoryEntry()
		: m_Value(0)
		, m_ValueNotDone(0)
		, m_bResourcesValid(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskPointsHistoryEntry(HPMTaskPointsHistoryEntry const &_Right)
		: m_TaskRefID(_Right.m_TaskRefID)
		, m_Value(_Right.m_Value)
		, m_ValueNotDone(_Right.m_ValueNotDone)
		, m_bResourcesValid(_Right.m_bResourcesValid)
		, m_ResourceAllocationEntries(_Right.m_ResourceAllocationEntries)
	{
	}
	HPMTaskPointsHistoryEntry(HPMTaskPointsHistoryEntry &&_Right)
		: m_TaskRefID(std::move(_Right.m_TaskRefID))
		, m_Value(std::move(_Right.m_Value))
		, m_ValueNotDone(std::move(_Right.m_ValueNotDone))
		, m_bResourcesValid(std::move(_Right.m_bResourcesValid))
		, m_ResourceAllocationEntries(std::move(_Right.m_ResourceAllocationEntries))
	{
	}
	HPMTaskPointsHistoryEntry &operator =(HPMTaskPointsHistoryEntry const &_Right)
	{
		m_TaskRefID = _Right.m_TaskRefID;
		m_Value = _Right.m_Value;
		m_ValueNotDone = _Right.m_ValueNotDone;
		m_bResourcesValid = _Right.m_bResourcesValid;
		m_ResourceAllocationEntries = _Right.m_ResourceAllocationEntries;
		return *this;
	}
	HPMTaskPointsHistoryEntry &operator =(HPMTaskPointsHistoryEntry &&_Right)
	{
		m_TaskRefID = std::move(_Right.m_TaskRefID);
		m_Value = std::move(_Right.m_Value);
		m_ValueNotDone = std::move(_Right.m_ValueNotDone);
		m_bResourcesValid = std::move(_Right.m_bResourcesValid);
		m_ResourceAllocationEntries = std::move(_Right.m_ResourceAllocationEntries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskPointsHistoryEntry &_Right) const
	{
		if (m_TaskRefID != _Right.m_TaskRefID)
			return false;
		if (m_Value != _Right.m_Value)
			return false;
		if (m_ValueNotDone != _Right.m_ValueNotDone)
			return false;
		if (m_bResourcesValid != _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() != _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
			if (m_ResourceAllocationEntries[i] != _Right.m_ResourceAllocationEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskPointsHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskPointsHistoryEntry &_Right) const
	{
		if (m_TaskRefID < _Right.m_TaskRefID)
			return true;
		if (m_TaskRefID > _Right.m_TaskRefID)
			return false;
		if (m_Value < _Right.m_Value)
			return true;
		if (m_Value > _Right.m_Value)
			return false;
		if (m_ValueNotDone < _Right.m_ValueNotDone)
			return true;
		if (m_ValueNotDone > _Right.m_ValueNotDone)
			return false;
		if (m_bResourcesValid < _Right.m_bResourcesValid)
			return true;
		if (m_bResourcesValid > _Right.m_bResourcesValid)
			return false;
		if (m_ResourceAllocationEntries.size() < _Right.m_ResourceAllocationEntries.size())
			return true;
		if (m_ResourceAllocationEntries.size() > _Right.m_ResourceAllocationEntries.size())
			return false;
		for (size_t i = 0; i < m_ResourceAllocationEntries.size(); ++i)
		{
			if (m_ResourceAllocationEntries[i] < _Right.m_ResourceAllocationEntries[i])
				return true;
			if (m_ResourceAllocationEntries[i] > _Right.m_ResourceAllocationEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskPointsHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskPointsHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskPointsHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskPointsHistory
{
	public:
	std::vector<HPMTaskPointsHistoryEntry> m_Entries;
	HPMTaskPointsHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskPointsHistory(HPMTaskPointsHistory const &_Right)
		: m_Entries(_Right.m_Entries)
	{
	}
	HPMTaskPointsHistory(HPMTaskPointsHistory &&_Right)
		: m_Entries(std::move(_Right.m_Entries))
	{
	}
	HPMTaskPointsHistory &operator =(HPMTaskPointsHistory const &_Right)
	{
		m_Entries = _Right.m_Entries;
		return *this;
	}
	HPMTaskPointsHistory &operator =(HPMTaskPointsHistory &&_Right)
	{
		m_Entries = std::move(_Right.m_Entries);
		return *this;
	}
#endif
	bool operator == (const HPMTaskPointsHistory &_Right) const
	{
		if (m_Entries.size() != _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
			if (m_Entries[i] != _Right.m_Entries[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskPointsHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskPointsHistory &_Right) const
	{
		if (m_Entries.size() < _Right.m_Entries.size())
			return true;
		if (m_Entries.size() > _Right.m_Entries.size())
			return false;
		for (size_t i = 0; i < m_Entries.size(); ++i)
		{
			if (m_Entries[i] < _Right.m_Entries[i])
				return true;
			if (m_Entries[i] > _Right.m_Entries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskPointsHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskPointsHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskPointsHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskHistoryDaysEnum
{
	public:
	std::vector<HPMUInt32> m_Days;
	HPMTaskHistoryDaysEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskHistoryDaysEnum(HPMTaskHistoryDaysEnum const &_Right)
		: m_Days(_Right.m_Days)
	{
	}
	HPMTaskHistoryDaysEnum(HPMTaskHistoryDaysEnum &&_Right)
		: m_Days(std::move(_Right.m_Days))
	{
	}
	HPMTaskHistoryDaysEnum &operator =(HPMTaskHistoryDaysEnum const &_Right)
	{
		m_Days = _Right.m_Days;
		return *this;
	}
	HPMTaskHistoryDaysEnum &operator =(HPMTaskHistoryDaysEnum &&_Right)
	{
		m_Days = std::move(_Right.m_Days);
		return *this;
	}
#endif
	bool operator == (const HPMTaskHistoryDaysEnum &_Right) const
	{
		if (m_Days.size() != _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
			if (m_Days[i] != _Right.m_Days[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskHistoryDaysEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskHistoryDaysEnum &_Right) const
	{
		if (m_Days.size() < _Right.m_Days.size())
			return true;
		if (m_Days.size() > _Right.m_Days.size())
			return false;
		for (size_t i = 0; i < m_Days.size(); ++i)
		{
			if (m_Days[i] < _Right.m_Days[i])
				return true;
			if (m_Days[i] > _Right.m_Days[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskHistoryDaysEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskHistoryDaysEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskHistoryDaysEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskVacationOptions
{
	public:
	EHPMTaskVacationOptionsFlag m_Flags;
	std::vector<HPMWorkDay> m_WorkDays;
	HPMTaskVacationOptions()
		: m_Flags(EHPMTaskVacationOptionsFlag_None)
	{
		m_WorkDays.resize(7);
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskVacationOptions(HPMTaskVacationOptions const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_WorkDays(_Right.m_WorkDays)
	{
	}
	HPMTaskVacationOptions(HPMTaskVacationOptions &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_WorkDays(std::move(_Right.m_WorkDays))
	{
	}
	HPMTaskVacationOptions &operator =(HPMTaskVacationOptions const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_WorkDays = _Right.m_WorkDays;
		return *this;
	}
	HPMTaskVacationOptions &operator =(HPMTaskVacationOptions &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_WorkDays = std::move(_Right.m_WorkDays);
		return *this;
	}
#endif
	bool operator == (const HPMTaskVacationOptions &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_WorkDays.size() != _Right.m_WorkDays.size())
			return false;
		for (size_t i = 0; i < m_WorkDays.size(); ++i)
			if (m_WorkDays[i] != _Right.m_WorkDays[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskVacationOptions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskVacationOptions &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_WorkDays.size() < _Right.m_WorkDays.size())
			return true;
		if (m_WorkDays.size() > _Right.m_WorkDays.size())
			return false;
		for (size_t i = 0; i < m_WorkDays.size(); ++i)
		{
			if (m_WorkDays[i] < _Right.m_WorkDays[i])
				return true;
			if (m_WorkDays[i] > _Right.m_WorkDays[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskVacationOptions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskVacationOptions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskVacationOptions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskLinkedToMilestones
{
	public:
	std::vector<HPMUniqueID> m_Milestones;
	HPMTaskLinkedToMilestones()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskLinkedToMilestones(HPMTaskLinkedToMilestones const &_Right)
		: m_Milestones(_Right.m_Milestones)
	{
	}
	HPMTaskLinkedToMilestones(HPMTaskLinkedToMilestones &&_Right)
		: m_Milestones(std::move(_Right.m_Milestones))
	{
	}
	HPMTaskLinkedToMilestones &operator =(HPMTaskLinkedToMilestones const &_Right)
	{
		m_Milestones = _Right.m_Milestones;
		return *this;
	}
	HPMTaskLinkedToMilestones &operator =(HPMTaskLinkedToMilestones &&_Right)
	{
		m_Milestones = std::move(_Right.m_Milestones);
		return *this;
	}
#endif
	bool operator == (const HPMTaskLinkedToMilestones &_Right) const
	{
		if (m_Milestones.size() != _Right.m_Milestones.size())
			return false;
		for (size_t i = 0; i < m_Milestones.size(); ++i)
			if (m_Milestones[i] != _Right.m_Milestones[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskLinkedToMilestones &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskLinkedToMilestones &_Right) const
	{
		if (m_Milestones.size() < _Right.m_Milestones.size())
			return true;
		if (m_Milestones.size() > _Right.m_Milestones.size())
			return false;
		for (size_t i = 0; i < m_Milestones.size(); ++i)
		{
			if (m_Milestones[i] < _Right.m_Milestones[i])
				return true;
			if (m_Milestones[i] > _Right.m_Milestones[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskLinkedToMilestones &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskLinkedToMilestones &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskLinkedToMilestones &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskEffectiveLinkedToMilestones
{
	public:
	bool m_bInherited;
	bool m_bInheritedFromBacklog;
	HPMTaskLinkedToMilestones m_Milestones;
	HPMTaskEffectiveLinkedToMilestones()
		: m_bInherited(0)
		, m_bInheritedFromBacklog(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskEffectiveLinkedToMilestones(HPMTaskEffectiveLinkedToMilestones const &_Right)
		: m_bInherited(_Right.m_bInherited)
		, m_bInheritedFromBacklog(_Right.m_bInheritedFromBacklog)
		, m_Milestones(_Right.m_Milestones)
	{
	}
	HPMTaskEffectiveLinkedToMilestones(HPMTaskEffectiveLinkedToMilestones &&_Right)
		: m_bInherited(std::move(_Right.m_bInherited))
		, m_bInheritedFromBacklog(std::move(_Right.m_bInheritedFromBacklog))
		, m_Milestones(std::move(_Right.m_Milestones))
	{
	}
	HPMTaskEffectiveLinkedToMilestones &operator =(HPMTaskEffectiveLinkedToMilestones const &_Right)
	{
		m_bInherited = _Right.m_bInherited;
		m_bInheritedFromBacklog = _Right.m_bInheritedFromBacklog;
		m_Milestones = _Right.m_Milestones;
		return *this;
	}
	HPMTaskEffectiveLinkedToMilestones &operator =(HPMTaskEffectiveLinkedToMilestones &&_Right)
	{
		m_bInherited = std::move(_Right.m_bInherited);
		m_bInheritedFromBacklog = std::move(_Right.m_bInheritedFromBacklog);
		m_Milestones = std::move(_Right.m_Milestones);
		return *this;
	}
#endif
	bool operator == (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		if (m_bInherited != _Right.m_bInherited)
			return false;
		if (m_bInheritedFromBacklog != _Right.m_bInheritedFromBacklog)
			return false;
		if (m_Milestones != _Right.m_Milestones)
			return false;
		return true;
	}
	bool operator != (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		if (m_bInherited < _Right.m_bInherited)
			return true;
		if (m_bInherited > _Right.m_bInherited)
			return false;
		if (m_bInheritedFromBacklog < _Right.m_bInheritedFromBacklog)
			return true;
		if (m_bInheritedFromBacklog > _Right.m_bInheritedFromBacklog)
			return false;
		if (m_Milestones < _Right.m_Milestones)
			return true;
		if (m_Milestones > _Right.m_Milestones)
			return false;
		return false;
	}
	bool operator > (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskEffectiveLinkedToMilestones &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskLinkedToLink
{
	public:
	EHPMTaskLinkedToLinkType m_LinkedToType;
	HPMUniqueID m_LinkedTo;
	HPMTaskLinkedToLink()
		: m_LinkedToType(EHPMTaskLinkedToLinkType_TaskItemOrBug)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskLinkedToLink(HPMTaskLinkedToLink const &_Right)
		: m_LinkedToType(_Right.m_LinkedToType)
		, m_LinkedTo(_Right.m_LinkedTo)
	{
	}
	HPMTaskLinkedToLink(HPMTaskLinkedToLink &&_Right)
		: m_LinkedToType(std::move(_Right.m_LinkedToType))
		, m_LinkedTo(std::move(_Right.m_LinkedTo))
	{
	}
	HPMTaskLinkedToLink &operator =(HPMTaskLinkedToLink const &_Right)
	{
		m_LinkedToType = _Right.m_LinkedToType;
		m_LinkedTo = _Right.m_LinkedTo;
		return *this;
	}
	HPMTaskLinkedToLink &operator =(HPMTaskLinkedToLink &&_Right)
	{
		m_LinkedToType = std::move(_Right.m_LinkedToType);
		m_LinkedTo = std::move(_Right.m_LinkedTo);
		return *this;
	}
#endif
	bool operator == (const HPMTaskLinkedToLink &_Right) const
	{
		if (m_LinkedToType != _Right.m_LinkedToType)
			return false;
		if (m_LinkedTo != _Right.m_LinkedTo)
			return false;
		return true;
	}
	bool operator != (const HPMTaskLinkedToLink &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskLinkedToLink &_Right) const
	{
		if (m_LinkedToType < _Right.m_LinkedToType)
			return true;
		if (m_LinkedToType > _Right.m_LinkedToType)
			return false;
		if (m_LinkedTo < _Right.m_LinkedTo)
			return true;
		if (m_LinkedTo > _Right.m_LinkedTo)
			return false;
		return false;
	}
	bool operator > (const HPMTaskLinkedToLink &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskLinkedToLink &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskLinkedToLink &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskLinkedTo
{
	public:
	std::vector<HPMTaskLinkedToLink> m_LinkedTo;
	HPMTaskLinkedTo()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskLinkedTo(HPMTaskLinkedTo const &_Right)
		: m_LinkedTo(_Right.m_LinkedTo)
	{
	}
	HPMTaskLinkedTo(HPMTaskLinkedTo &&_Right)
		: m_LinkedTo(std::move(_Right.m_LinkedTo))
	{
	}
	HPMTaskLinkedTo &operator =(HPMTaskLinkedTo const &_Right)
	{
		m_LinkedTo = _Right.m_LinkedTo;
		return *this;
	}
	HPMTaskLinkedTo &operator =(HPMTaskLinkedTo &&_Right)
	{
		m_LinkedTo = std::move(_Right.m_LinkedTo);
		return *this;
	}
#endif
	bool operator == (const HPMTaskLinkedTo &_Right) const
	{
		if (m_LinkedTo.size() != _Right.m_LinkedTo.size())
			return false;
		for (size_t i = 0; i < m_LinkedTo.size(); ++i)
			if (m_LinkedTo[i] != _Right.m_LinkedTo[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskLinkedTo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskLinkedTo &_Right) const
	{
		if (m_LinkedTo.size() < _Right.m_LinkedTo.size())
			return true;
		if (m_LinkedTo.size() > _Right.m_LinkedTo.size())
			return false;
		for (size_t i = 0; i < m_LinkedTo.size(); ++i)
		{
			if (m_LinkedTo[i] < _Right.m_LinkedTo[i])
				return true;
			if (m_LinkedTo[i] > _Right.m_LinkedTo[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskLinkedTo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskLinkedTo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskLinkedTo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskComment
{
	public:
	HPMInt32 m_ParentID;
	EHPMTaskCommentFlag m_Flags;
	HPMUInt64 m_PostDate;
	HPMUniqueID m_PostedByResourceID;
	HPMString m_PostedByResource;
	HPMString m_MessageText;
	HPMTaskComment()
		: m_ParentID(-1)
		, m_Flags(EHPMTaskCommentFlag_None)
		, m_PostDate(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskComment(HPMTaskComment const &_Right)
		: m_ParentID(_Right.m_ParentID)
		, m_Flags(_Right.m_Flags)
		, m_PostDate(_Right.m_PostDate)
		, m_PostedByResourceID(_Right.m_PostedByResourceID)
		, m_PostedByResource(_Right.m_PostedByResource)
		, m_MessageText(_Right.m_MessageText)
	{
	}
	HPMTaskComment(HPMTaskComment &&_Right)
		: m_ParentID(std::move(_Right.m_ParentID))
		, m_Flags(std::move(_Right.m_Flags))
		, m_PostDate(std::move(_Right.m_PostDate))
		, m_PostedByResourceID(std::move(_Right.m_PostedByResourceID))
		, m_PostedByResource(std::move(_Right.m_PostedByResource))
		, m_MessageText(std::move(_Right.m_MessageText))
	{
	}
	HPMTaskComment &operator =(HPMTaskComment const &_Right)
	{
		m_ParentID = _Right.m_ParentID;
		m_Flags = _Right.m_Flags;
		m_PostDate = _Right.m_PostDate;
		m_PostedByResourceID = _Right.m_PostedByResourceID;
		m_PostedByResource = _Right.m_PostedByResource;
		m_MessageText = _Right.m_MessageText;
		return *this;
	}
	HPMTaskComment &operator =(HPMTaskComment &&_Right)
	{
		m_ParentID = std::move(_Right.m_ParentID);
		m_Flags = std::move(_Right.m_Flags);
		m_PostDate = std::move(_Right.m_PostDate);
		m_PostedByResourceID = std::move(_Right.m_PostedByResourceID);
		m_PostedByResource = std::move(_Right.m_PostedByResource);
		m_MessageText = std::move(_Right.m_MessageText);
		return *this;
	}
#endif
	bool operator == (const HPMTaskComment &_Right) const
	{
		if (m_ParentID != _Right.m_ParentID)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_PostDate != _Right.m_PostDate)
			return false;
		if (m_PostedByResourceID != _Right.m_PostedByResourceID)
			return false;
		if (m_PostedByResource != _Right.m_PostedByResource)
			return false;
		if (m_MessageText != _Right.m_MessageText)
			return false;
		return true;
	}
	bool operator != (const HPMTaskComment &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskComment &_Right) const
	{
		if (m_ParentID < _Right.m_ParentID)
			return true;
		if (m_ParentID > _Right.m_ParentID)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_PostDate < _Right.m_PostDate)
			return true;
		if (m_PostDate > _Right.m_PostDate)
			return false;
		if (m_PostedByResourceID < _Right.m_PostedByResourceID)
			return true;
		if (m_PostedByResourceID > _Right.m_PostedByResourceID)
			return false;
		if (m_PostedByResource < _Right.m_PostedByResource)
			return true;
		if (m_PostedByResource > _Right.m_PostedByResource)
			return false;
		if (m_MessageText < _Right.m_MessageText)
			return true;
		if (m_MessageText > _Right.m_MessageText)
			return false;
		return false;
	}
	bool operator > (const HPMTaskComment &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskComment &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskComment &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCommentEnum
{
	public:
	std::vector<HPMInt32> m_Comments;
	HPMTaskCommentEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCommentEnum(HPMTaskCommentEnum const &_Right)
		: m_Comments(_Right.m_Comments)
	{
	}
	HPMTaskCommentEnum(HPMTaskCommentEnum &&_Right)
		: m_Comments(std::move(_Right.m_Comments))
	{
	}
	HPMTaskCommentEnum &operator =(HPMTaskCommentEnum const &_Right)
	{
		m_Comments = _Right.m_Comments;
		return *this;
	}
	HPMTaskCommentEnum &operator =(HPMTaskCommentEnum &&_Right)
	{
		m_Comments = std::move(_Right.m_Comments);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCommentEnum &_Right) const
	{
		if (m_Comments.size() != _Right.m_Comments.size())
			return false;
		for (size_t i = 0; i < m_Comments.size(); ++i)
			if (m_Comments[i] != _Right.m_Comments[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskCommentEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCommentEnum &_Right) const
	{
		if (m_Comments.size() < _Right.m_Comments.size())
			return true;
		if (m_Comments.size() > _Right.m_Comments.size())
			return false;
		for (size_t i = 0; i < m_Comments.size(); ++i)
		{
			if (m_Comments[i] < _Right.m_Comments[i])
				return true;
			if (m_Comments[i] > _Right.m_Comments[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskCommentEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCommentEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCommentEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCommentsOptions
{
	public:
	std::vector<HPMResourceReference> m_CCNotificationsTo;
	HPMTaskCommentsOptions()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCommentsOptions(HPMTaskCommentsOptions const &_Right)
		: m_CCNotificationsTo(_Right.m_CCNotificationsTo)
	{
	}
	HPMTaskCommentsOptions(HPMTaskCommentsOptions &&_Right)
		: m_CCNotificationsTo(std::move(_Right.m_CCNotificationsTo))
	{
	}
	HPMTaskCommentsOptions &operator =(HPMTaskCommentsOptions const &_Right)
	{
		m_CCNotificationsTo = _Right.m_CCNotificationsTo;
		return *this;
	}
	HPMTaskCommentsOptions &operator =(HPMTaskCommentsOptions &&_Right)
	{
		m_CCNotificationsTo = std::move(_Right.m_CCNotificationsTo);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCommentsOptions &_Right) const
	{
		if (m_CCNotificationsTo.size() != _Right.m_CCNotificationsTo.size())
			return false;
		for (size_t i = 0; i < m_CCNotificationsTo.size(); ++i)
			if (m_CCNotificationsTo[i] != _Right.m_CCNotificationsTo[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskCommentsOptions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCommentsOptions &_Right) const
	{
		if (m_CCNotificationsTo.size() < _Right.m_CCNotificationsTo.size())
			return true;
		if (m_CCNotificationsTo.size() > _Right.m_CCNotificationsTo.size())
			return false;
		for (size_t i = 0; i < m_CCNotificationsTo.size(); ++i)
		{
			if (m_CCNotificationsTo[i] < _Right.m_CCNotificationsTo[i])
				return true;
			if (m_CCNotificationsTo[i] > _Right.m_CCNotificationsTo[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskCommentsOptions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCommentsOptions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCommentsOptions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskWallPosition
{
	public:
	EHPMWallGroupingType m_GroupingType;
	HPMUInt32 m_GroupingID;
	HPMUniqueID m_GroupingSprintUID;
	HPMFP32 m_PositionX;
	HPMFP32 m_PositionY;
	bool m_bPositionHasBeenSet;
	HPMTaskWallPosition()
		: m_GroupingType(EHPMWallGroupingType_CustomGroups)
		, m_GroupingID(0)
		, m_PositionX(500)
		, m_PositionY(500)
		, m_bPositionHasBeenSet(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskWallPosition(HPMTaskWallPosition const &_Right)
		: m_GroupingType(_Right.m_GroupingType)
		, m_GroupingID(_Right.m_GroupingID)
		, m_GroupingSprintUID(_Right.m_GroupingSprintUID)
		, m_PositionX(_Right.m_PositionX)
		, m_PositionY(_Right.m_PositionY)
		, m_bPositionHasBeenSet(_Right.m_bPositionHasBeenSet)
	{
	}
	HPMTaskWallPosition(HPMTaskWallPosition &&_Right)
		: m_GroupingType(std::move(_Right.m_GroupingType))
		, m_GroupingID(std::move(_Right.m_GroupingID))
		, m_GroupingSprintUID(std::move(_Right.m_GroupingSprintUID))
		, m_PositionX(std::move(_Right.m_PositionX))
		, m_PositionY(std::move(_Right.m_PositionY))
		, m_bPositionHasBeenSet(std::move(_Right.m_bPositionHasBeenSet))
	{
	}
	HPMTaskWallPosition &operator =(HPMTaskWallPosition const &_Right)
	{
		m_GroupingType = _Right.m_GroupingType;
		m_GroupingID = _Right.m_GroupingID;
		m_GroupingSprintUID = _Right.m_GroupingSprintUID;
		m_PositionX = _Right.m_PositionX;
		m_PositionY = _Right.m_PositionY;
		m_bPositionHasBeenSet = _Right.m_bPositionHasBeenSet;
		return *this;
	}
	HPMTaskWallPosition &operator =(HPMTaskWallPosition &&_Right)
	{
		m_GroupingType = std::move(_Right.m_GroupingType);
		m_GroupingID = std::move(_Right.m_GroupingID);
		m_GroupingSprintUID = std::move(_Right.m_GroupingSprintUID);
		m_PositionX = std::move(_Right.m_PositionX);
		m_PositionY = std::move(_Right.m_PositionY);
		m_bPositionHasBeenSet = std::move(_Right.m_bPositionHasBeenSet);
		return *this;
	}
#endif
	bool operator == (const HPMTaskWallPosition &_Right) const
	{
		if (m_GroupingType != _Right.m_GroupingType)
			return false;
		if (m_GroupingID != _Right.m_GroupingID)
			return false;
		if (m_GroupingSprintUID != _Right.m_GroupingSprintUID)
			return false;
		if (m_PositionX != _Right.m_PositionX)
			return false;
		if (m_PositionY != _Right.m_PositionY)
			return false;
		if (m_bPositionHasBeenSet != _Right.m_bPositionHasBeenSet)
			return false;
		return true;
	}
	bool operator != (const HPMTaskWallPosition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskWallPosition &_Right) const
	{
		if (m_GroupingType < _Right.m_GroupingType)
			return true;
		if (m_GroupingType > _Right.m_GroupingType)
			return false;
		if (m_GroupingID < _Right.m_GroupingID)
			return true;
		if (m_GroupingID > _Right.m_GroupingID)
			return false;
		if (m_GroupingSprintUID < _Right.m_GroupingSprintUID)
			return true;
		if (m_GroupingSprintUID > _Right.m_GroupingSprintUID)
			return false;
		if (m_PositionX < _Right.m_PositionX)
			return true;
		if (m_PositionX > _Right.m_PositionX)
			return false;
		if (m_PositionY < _Right.m_PositionY)
			return true;
		if (m_PositionY > _Right.m_PositionY)
			return false;
		if (m_bPositionHasBeenSet < _Right.m_bPositionHasBeenSet)
			return true;
		if (m_bPositionHasBeenSet > _Right.m_bPositionHasBeenSet)
			return false;
		return false;
	}
	bool operator > (const HPMTaskWallPosition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskWallPosition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskWallPosition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskCustomSummaryValue
{
	public:
	HPMUInt32 m_Hash;
	EHPMProjectCustomColumnsColumnType m_Type;
	HPMInt32 m_IntegerValue;
	HPMFP64 m_FloatValue;
	HPMTaskCustomSummaryValue()
		: m_Hash(0)
		, m_Type(EHPMProjectCustomColumnsColumnType_IntegerNumber)
		, m_IntegerValue(0)
		, m_FloatValue(0.0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskCustomSummaryValue(HPMTaskCustomSummaryValue const &_Right)
		: m_Hash(_Right.m_Hash)
		, m_Type(_Right.m_Type)
		, m_IntegerValue(_Right.m_IntegerValue)
		, m_FloatValue(_Right.m_FloatValue)
	{
	}
	HPMTaskCustomSummaryValue(HPMTaskCustomSummaryValue &&_Right)
		: m_Hash(std::move(_Right.m_Hash))
		, m_Type(std::move(_Right.m_Type))
		, m_IntegerValue(std::move(_Right.m_IntegerValue))
		, m_FloatValue(std::move(_Right.m_FloatValue))
	{
	}
	HPMTaskCustomSummaryValue &operator =(HPMTaskCustomSummaryValue const &_Right)
	{
		m_Hash = _Right.m_Hash;
		m_Type = _Right.m_Type;
		m_IntegerValue = _Right.m_IntegerValue;
		m_FloatValue = _Right.m_FloatValue;
		return *this;
	}
	HPMTaskCustomSummaryValue &operator =(HPMTaskCustomSummaryValue &&_Right)
	{
		m_Hash = std::move(_Right.m_Hash);
		m_Type = std::move(_Right.m_Type);
		m_IntegerValue = std::move(_Right.m_IntegerValue);
		m_FloatValue = std::move(_Right.m_FloatValue);
		return *this;
	}
#endif
	bool operator == (const HPMTaskCustomSummaryValue &_Right) const
	{
		if (m_Hash != _Right.m_Hash)
			return false;
		if (m_Type != _Right.m_Type)
			return false;
		if (m_IntegerValue != _Right.m_IntegerValue)
			return false;
		if (m_FloatValue != _Right.m_FloatValue)
			return false;
		return true;
	}
	bool operator != (const HPMTaskCustomSummaryValue &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskCustomSummaryValue &_Right) const
	{
		if (m_Hash < _Right.m_Hash)
			return true;
		if (m_Hash > _Right.m_Hash)
			return false;
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_IntegerValue < _Right.m_IntegerValue)
			return true;
		if (m_IntegerValue > _Right.m_IntegerValue)
			return false;
		if (m_FloatValue < _Right.m_FloatValue)
			return true;
		if (m_FloatValue > _Right.m_FloatValue)
			return false;
		return false;
	}
	bool operator > (const HPMTaskCustomSummaryValue &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskCustomSummaryValue &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskCustomSummaryValue &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskWallPositions
{
	public:
	std::vector<HPMTaskWallPosition> m_WallPositions;
	HPMTaskWallPositions()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskWallPositions(HPMTaskWallPositions const &_Right)
		: m_WallPositions(_Right.m_WallPositions)
	{
	}
	HPMTaskWallPositions(HPMTaskWallPositions &&_Right)
		: m_WallPositions(std::move(_Right.m_WallPositions))
	{
	}
	HPMTaskWallPositions &operator =(HPMTaskWallPositions const &_Right)
	{
		m_WallPositions = _Right.m_WallPositions;
		return *this;
	}
	HPMTaskWallPositions &operator =(HPMTaskWallPositions &&_Right)
	{
		m_WallPositions = std::move(_Right.m_WallPositions);
		return *this;
	}
#endif
	bool operator == (const HPMTaskWallPositions &_Right) const
	{
		if (m_WallPositions.size() != _Right.m_WallPositions.size())
			return false;
		for (size_t i = 0; i < m_WallPositions.size(); ++i)
			if (m_WallPositions[i] != _Right.m_WallPositions[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskWallPositions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskWallPositions &_Right) const
	{
		if (m_WallPositions.size() < _Right.m_WallPositions.size())
			return true;
		if (m_WallPositions.size() > _Right.m_WallPositions.size())
			return false;
		for (size_t i = 0; i < m_WallPositions.size(); ++i)
		{
			if (m_WallPositions[i] < _Right.m_WallPositions[i])
				return true;
			if (m_WallPositions[i] > _Right.m_WallPositions[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskWallPositions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskWallPositions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskWallPositions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMTaskSummary
{
	public:
	HPMUInt32 m_Completed;
	HPMUInt32 m_Uncompleted;
	HPMUInt32 m_AssignedUncompleted;
	EHPMTaskStatus m_TaskStatus;
	HPMInt32 m_ComplexityPoints;
	HPMInt32 m_ComplexityPoints_NotDone;
	HPMInt32 m_EarnedValue;
	HPMInt32 m_BudgetedWork;
	HPMFP64 m_WorkRemaining;
	HPMFP64 m_EstimatedIdealDays;
	HPMFP64 m_EstimatedIdealDays_NotDone;
	HPMFP64 m_DurationDays;
	HPMFP64 m_DurationDays_NotDone;
	std::vector<HPMTaskCustomSummaryValue> m_CustomSummaryValues;
	HPMTaskSummary()
		: m_Completed(0)
		, m_Uncompleted(0)
		, m_AssignedUncompleted(0)
		, m_TaskStatus(EHPMTaskStatus_NotDone)
		, m_ComplexityPoints(0)
		, m_ComplexityPoints_NotDone(0)
		, m_EarnedValue(0)
		, m_BudgetedWork(0)
		, m_WorkRemaining(0.0)
		, m_EstimatedIdealDays(0.0)
		, m_EstimatedIdealDays_NotDone(0.0)
		, m_DurationDays(0.0)
		, m_DurationDays_NotDone(0.0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMTaskSummary(HPMTaskSummary const &_Right)
		: m_Completed(_Right.m_Completed)
		, m_Uncompleted(_Right.m_Uncompleted)
		, m_AssignedUncompleted(_Right.m_AssignedUncompleted)
		, m_TaskStatus(_Right.m_TaskStatus)
		, m_ComplexityPoints(_Right.m_ComplexityPoints)
		, m_ComplexityPoints_NotDone(_Right.m_ComplexityPoints_NotDone)
		, m_EarnedValue(_Right.m_EarnedValue)
		, m_BudgetedWork(_Right.m_BudgetedWork)
		, m_WorkRemaining(_Right.m_WorkRemaining)
		, m_EstimatedIdealDays(_Right.m_EstimatedIdealDays)
		, m_EstimatedIdealDays_NotDone(_Right.m_EstimatedIdealDays_NotDone)
		, m_DurationDays(_Right.m_DurationDays)
		, m_DurationDays_NotDone(_Right.m_DurationDays_NotDone)
		, m_CustomSummaryValues(_Right.m_CustomSummaryValues)
	{
	}
	HPMTaskSummary(HPMTaskSummary &&_Right)
		: m_Completed(std::move(_Right.m_Completed))
		, m_Uncompleted(std::move(_Right.m_Uncompleted))
		, m_AssignedUncompleted(std::move(_Right.m_AssignedUncompleted))
		, m_TaskStatus(std::move(_Right.m_TaskStatus))
		, m_ComplexityPoints(std::move(_Right.m_ComplexityPoints))
		, m_ComplexityPoints_NotDone(std::move(_Right.m_ComplexityPoints_NotDone))
		, m_EarnedValue(std::move(_Right.m_EarnedValue))
		, m_BudgetedWork(std::move(_Right.m_BudgetedWork))
		, m_WorkRemaining(std::move(_Right.m_WorkRemaining))
		, m_EstimatedIdealDays(std::move(_Right.m_EstimatedIdealDays))
		, m_EstimatedIdealDays_NotDone(std::move(_Right.m_EstimatedIdealDays_NotDone))
		, m_DurationDays(std::move(_Right.m_DurationDays))
		, m_DurationDays_NotDone(std::move(_Right.m_DurationDays_NotDone))
		, m_CustomSummaryValues(std::move(_Right.m_CustomSummaryValues))
	{
	}
	HPMTaskSummary &operator =(HPMTaskSummary const &_Right)
	{
		m_Completed = _Right.m_Completed;
		m_Uncompleted = _Right.m_Uncompleted;
		m_AssignedUncompleted = _Right.m_AssignedUncompleted;
		m_TaskStatus = _Right.m_TaskStatus;
		m_ComplexityPoints = _Right.m_ComplexityPoints;
		m_ComplexityPoints_NotDone = _Right.m_ComplexityPoints_NotDone;
		m_EarnedValue = _Right.m_EarnedValue;
		m_BudgetedWork = _Right.m_BudgetedWork;
		m_WorkRemaining = _Right.m_WorkRemaining;
		m_EstimatedIdealDays = _Right.m_EstimatedIdealDays;
		m_EstimatedIdealDays_NotDone = _Right.m_EstimatedIdealDays_NotDone;
		m_DurationDays = _Right.m_DurationDays;
		m_DurationDays_NotDone = _Right.m_DurationDays_NotDone;
		m_CustomSummaryValues = _Right.m_CustomSummaryValues;
		return *this;
	}
	HPMTaskSummary &operator =(HPMTaskSummary &&_Right)
	{
		m_Completed = std::move(_Right.m_Completed);
		m_Uncompleted = std::move(_Right.m_Uncompleted);
		m_AssignedUncompleted = std::move(_Right.m_AssignedUncompleted);
		m_TaskStatus = std::move(_Right.m_TaskStatus);
		m_ComplexityPoints = std::move(_Right.m_ComplexityPoints);
		m_ComplexityPoints_NotDone = std::move(_Right.m_ComplexityPoints_NotDone);
		m_EarnedValue = std::move(_Right.m_EarnedValue);
		m_BudgetedWork = std::move(_Right.m_BudgetedWork);
		m_WorkRemaining = std::move(_Right.m_WorkRemaining);
		m_EstimatedIdealDays = std::move(_Right.m_EstimatedIdealDays);
		m_EstimatedIdealDays_NotDone = std::move(_Right.m_EstimatedIdealDays_NotDone);
		m_DurationDays = std::move(_Right.m_DurationDays);
		m_DurationDays_NotDone = std::move(_Right.m_DurationDays_NotDone);
		m_CustomSummaryValues = std::move(_Right.m_CustomSummaryValues);
		return *this;
	}
#endif
	bool operator == (const HPMTaskSummary &_Right) const
	{
		if (m_Completed != _Right.m_Completed)
			return false;
		if (m_Uncompleted != _Right.m_Uncompleted)
			return false;
		if (m_AssignedUncompleted != _Right.m_AssignedUncompleted)
			return false;
		if (m_TaskStatus != _Right.m_TaskStatus)
			return false;
		if (m_ComplexityPoints != _Right.m_ComplexityPoints)
			return false;
		if (m_ComplexityPoints_NotDone != _Right.m_ComplexityPoints_NotDone)
			return false;
		if (m_EarnedValue != _Right.m_EarnedValue)
			return false;
		if (m_BudgetedWork != _Right.m_BudgetedWork)
			return false;
		if (m_WorkRemaining != _Right.m_WorkRemaining)
			return false;
		if (m_EstimatedIdealDays != _Right.m_EstimatedIdealDays)
			return false;
		if (m_EstimatedIdealDays_NotDone != _Right.m_EstimatedIdealDays_NotDone)
			return false;
		if (m_DurationDays != _Right.m_DurationDays)
			return false;
		if (m_DurationDays_NotDone != _Right.m_DurationDays_NotDone)
			return false;
		if (m_CustomSummaryValues.size() != _Right.m_CustomSummaryValues.size())
			return false;
		for (size_t i = 0; i < m_CustomSummaryValues.size(); ++i)
			if (m_CustomSummaryValues[i] != _Right.m_CustomSummaryValues[i])
				return false;
		return true;
	}
	bool operator != (const HPMTaskSummary &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMTaskSummary &_Right) const
	{
		if (m_Completed < _Right.m_Completed)
			return true;
		if (m_Completed > _Right.m_Completed)
			return false;
		if (m_Uncompleted < _Right.m_Uncompleted)
			return true;
		if (m_Uncompleted > _Right.m_Uncompleted)
			return false;
		if (m_AssignedUncompleted < _Right.m_AssignedUncompleted)
			return true;
		if (m_AssignedUncompleted > _Right.m_AssignedUncompleted)
			return false;
		if (m_TaskStatus < _Right.m_TaskStatus)
			return true;
		if (m_TaskStatus > _Right.m_TaskStatus)
			return false;
		if (m_ComplexityPoints < _Right.m_ComplexityPoints)
			return true;
		if (m_ComplexityPoints > _Right.m_ComplexityPoints)
			return false;
		if (m_ComplexityPoints_NotDone < _Right.m_ComplexityPoints_NotDone)
			return true;
		if (m_ComplexityPoints_NotDone > _Right.m_ComplexityPoints_NotDone)
			return false;
		if (m_EarnedValue < _Right.m_EarnedValue)
			return true;
		if (m_EarnedValue > _Right.m_EarnedValue)
			return false;
		if (m_BudgetedWork < _Right.m_BudgetedWork)
			return true;
		if (m_BudgetedWork > _Right.m_BudgetedWork)
			return false;
		if (m_WorkRemaining < _Right.m_WorkRemaining)
			return true;
		if (m_WorkRemaining > _Right.m_WorkRemaining)
			return false;
		if (m_EstimatedIdealDays < _Right.m_EstimatedIdealDays)
			return true;
		if (m_EstimatedIdealDays > _Right.m_EstimatedIdealDays)
			return false;
		if (m_EstimatedIdealDays_NotDone < _Right.m_EstimatedIdealDays_NotDone)
			return true;
		if (m_EstimatedIdealDays_NotDone > _Right.m_EstimatedIdealDays_NotDone)
			return false;
		if (m_DurationDays < _Right.m_DurationDays)
			return true;
		if (m_DurationDays > _Right.m_DurationDays)
			return false;
		if (m_DurationDays_NotDone < _Right.m_DurationDays_NotDone)
			return true;
		if (m_DurationDays_NotDone > _Right.m_DurationDays_NotDone)
			return false;
		if (m_CustomSummaryValues.size() < _Right.m_CustomSummaryValues.size())
			return true;
		if (m_CustomSummaryValues.size() > _Right.m_CustomSummaryValues.size())
			return false;
		for (size_t i = 0; i < m_CustomSummaryValues.size(); ++i)
		{
			if (m_CustomSummaryValues[i] < _Right.m_CustomSummaryValues[i])
				return true;
			if (m_CustomSummaryValues[i] > _Right.m_CustomSummaryValues[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMTaskSummary &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMTaskSummary &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMTaskSummary &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMMilestoneSummary
{
	public:
	HPMUInt32 m_Completed;
	HPMUInt32 m_Uncompleted;
	HPMUInt32 m_Overdue;
	HPMUInt32 m_AssignedUncompleted;
	std::vector<HPMUniqueID> m_MilestoneDependantIDs;
	HPMFP64 m_IdealDays;
	HPMFP64 m_IdealDays_NotDone;
	HPMFP64 m_WorkRemaining;
	HPMUInt32 m_Points;
	HPMUInt32 m_Points_NotDone;
	HPMFP64 m_DurationDays;
	HPMFP64 m_DurationDays_NotDone;
	HPMUInt64 m_StartTime;
	HPMMilestoneSummary()
		: m_Completed(0)
		, m_Uncompleted(0)
		, m_Overdue(0)
		, m_AssignedUncompleted(0)
		, m_IdealDays(0.0)
		, m_IdealDays_NotDone(0.0)
		, m_WorkRemaining(0.0)
		, m_Points(0)
		, m_Points_NotDone(0)
		, m_DurationDays(0.0)
		, m_DurationDays_NotDone(0.0)
		, m_StartTime(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMMilestoneSummary(HPMMilestoneSummary const &_Right)
		: m_Completed(_Right.m_Completed)
		, m_Uncompleted(_Right.m_Uncompleted)
		, m_Overdue(_Right.m_Overdue)
		, m_AssignedUncompleted(_Right.m_AssignedUncompleted)
		, m_MilestoneDependantIDs(_Right.m_MilestoneDependantIDs)
		, m_IdealDays(_Right.m_IdealDays)
		, m_IdealDays_NotDone(_Right.m_IdealDays_NotDone)
		, m_WorkRemaining(_Right.m_WorkRemaining)
		, m_Points(_Right.m_Points)
		, m_Points_NotDone(_Right.m_Points_NotDone)
		, m_DurationDays(_Right.m_DurationDays)
		, m_DurationDays_NotDone(_Right.m_DurationDays_NotDone)
		, m_StartTime(_Right.m_StartTime)
	{
	}
	HPMMilestoneSummary(HPMMilestoneSummary &&_Right)
		: m_Completed(std::move(_Right.m_Completed))
		, m_Uncompleted(std::move(_Right.m_Uncompleted))
		, m_Overdue(std::move(_Right.m_Overdue))
		, m_AssignedUncompleted(std::move(_Right.m_AssignedUncompleted))
		, m_MilestoneDependantIDs(std::move(_Right.m_MilestoneDependantIDs))
		, m_IdealDays(std::move(_Right.m_IdealDays))
		, m_IdealDays_NotDone(std::move(_Right.m_IdealDays_NotDone))
		, m_WorkRemaining(std::move(_Right.m_WorkRemaining))
		, m_Points(std::move(_Right.m_Points))
		, m_Points_NotDone(std::move(_Right.m_Points_NotDone))
		, m_DurationDays(std::move(_Right.m_DurationDays))
		, m_DurationDays_NotDone(std::move(_Right.m_DurationDays_NotDone))
		, m_StartTime(std::move(_Right.m_StartTime))
	{
	}
	HPMMilestoneSummary &operator =(HPMMilestoneSummary const &_Right)
	{
		m_Completed = _Right.m_Completed;
		m_Uncompleted = _Right.m_Uncompleted;
		m_Overdue = _Right.m_Overdue;
		m_AssignedUncompleted = _Right.m_AssignedUncompleted;
		m_MilestoneDependantIDs = _Right.m_MilestoneDependantIDs;
		m_IdealDays = _Right.m_IdealDays;
		m_IdealDays_NotDone = _Right.m_IdealDays_NotDone;
		m_WorkRemaining = _Right.m_WorkRemaining;
		m_Points = _Right.m_Points;
		m_Points_NotDone = _Right.m_Points_NotDone;
		m_DurationDays = _Right.m_DurationDays;
		m_DurationDays_NotDone = _Right.m_DurationDays_NotDone;
		m_StartTime = _Right.m_StartTime;
		return *this;
	}
	HPMMilestoneSummary &operator =(HPMMilestoneSummary &&_Right)
	{
		m_Completed = std::move(_Right.m_Completed);
		m_Uncompleted = std::move(_Right.m_Uncompleted);
		m_Overdue = std::move(_Right.m_Overdue);
		m_AssignedUncompleted = std::move(_Right.m_AssignedUncompleted);
		m_MilestoneDependantIDs = std::move(_Right.m_MilestoneDependantIDs);
		m_IdealDays = std::move(_Right.m_IdealDays);
		m_IdealDays_NotDone = std::move(_Right.m_IdealDays_NotDone);
		m_WorkRemaining = std::move(_Right.m_WorkRemaining);
		m_Points = std::move(_Right.m_Points);
		m_Points_NotDone = std::move(_Right.m_Points_NotDone);
		m_DurationDays = std::move(_Right.m_DurationDays);
		m_DurationDays_NotDone = std::move(_Right.m_DurationDays_NotDone);
		m_StartTime = std::move(_Right.m_StartTime);
		return *this;
	}
#endif
	bool operator == (const HPMMilestoneSummary &_Right) const
	{
		if (m_Completed != _Right.m_Completed)
			return false;
		if (m_Uncompleted != _Right.m_Uncompleted)
			return false;
		if (m_Overdue != _Right.m_Overdue)
			return false;
		if (m_AssignedUncompleted != _Right.m_AssignedUncompleted)
			return false;
		if (m_MilestoneDependantIDs.size() != _Right.m_MilestoneDependantIDs.size())
			return false;
		for (size_t i = 0; i < m_MilestoneDependantIDs.size(); ++i)
			if (m_MilestoneDependantIDs[i] != _Right.m_MilestoneDependantIDs[i])
				return false;
		if (m_IdealDays != _Right.m_IdealDays)
			return false;
		if (m_IdealDays_NotDone != _Right.m_IdealDays_NotDone)
			return false;
		if (m_WorkRemaining != _Right.m_WorkRemaining)
			return false;
		if (m_Points != _Right.m_Points)
			return false;
		if (m_Points_NotDone != _Right.m_Points_NotDone)
			return false;
		if (m_DurationDays != _Right.m_DurationDays)
			return false;
		if (m_DurationDays_NotDone != _Right.m_DurationDays_NotDone)
			return false;
		if (m_StartTime != _Right.m_StartTime)
			return false;
		return true;
	}
	bool operator != (const HPMMilestoneSummary &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMMilestoneSummary &_Right) const
	{
		if (m_Completed < _Right.m_Completed)
			return true;
		if (m_Completed > _Right.m_Completed)
			return false;
		if (m_Uncompleted < _Right.m_Uncompleted)
			return true;
		if (m_Uncompleted > _Right.m_Uncompleted)
			return false;
		if (m_Overdue < _Right.m_Overdue)
			return true;
		if (m_Overdue > _Right.m_Overdue)
			return false;
		if (m_AssignedUncompleted < _Right.m_AssignedUncompleted)
			return true;
		if (m_AssignedUncompleted > _Right.m_AssignedUncompleted)
			return false;
		if (m_MilestoneDependantIDs.size() < _Right.m_MilestoneDependantIDs.size())
			return true;
		if (m_MilestoneDependantIDs.size() > _Right.m_MilestoneDependantIDs.size())
			return false;
		for (size_t i = 0; i < m_MilestoneDependantIDs.size(); ++i)
		{
			if (m_MilestoneDependantIDs[i] < _Right.m_MilestoneDependantIDs[i])
				return true;
			if (m_MilestoneDependantIDs[i] > _Right.m_MilestoneDependantIDs[i])
				return false;
		}
		if (m_IdealDays < _Right.m_IdealDays)
			return true;
		if (m_IdealDays > _Right.m_IdealDays)
			return false;
		if (m_IdealDays_NotDone < _Right.m_IdealDays_NotDone)
			return true;
		if (m_IdealDays_NotDone > _Right.m_IdealDays_NotDone)
			return false;
		if (m_WorkRemaining < _Right.m_WorkRemaining)
			return true;
		if (m_WorkRemaining > _Right.m_WorkRemaining)
			return false;
		if (m_Points < _Right.m_Points)
			return true;
		if (m_Points > _Right.m_Points)
			return false;
		if (m_Points_NotDone < _Right.m_Points_NotDone)
			return true;
		if (m_Points_NotDone > _Right.m_Points_NotDone)
			return false;
		if (m_DurationDays < _Right.m_DurationDays)
			return true;
		if (m_DurationDays > _Right.m_DurationDays)
			return false;
		if (m_DurationDays_NotDone < _Right.m_DurationDays_NotDone)
			return true;
		if (m_DurationDays_NotDone > _Right.m_DurationDays_NotDone)
			return false;
		if (m_StartTime < _Right.m_StartTime)
			return true;
		if (m_StartTime > _Right.m_StartTime)
			return false;
		return false;
	}
	bool operator > (const HPMMilestoneSummary &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMMilestoneSummary &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMMilestoneSummary &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlMetaDataEntry
{
	public:
	EHPMVersionControlMetaDataType m_Type;
	HPMString m_Name;
	HPMString m_Data;
	HPMVersionControlMetaDataEntry()
		: m_Type(EHPMVersionControlMetaDataType_NewVersionOfSDKRequired)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlMetaDataEntry(HPMVersionControlMetaDataEntry const &_Right)
		: m_Type(_Right.m_Type)
		, m_Name(_Right.m_Name)
		, m_Data(_Right.m_Data)
	{
	}
	HPMVersionControlMetaDataEntry(HPMVersionControlMetaDataEntry &&_Right)
		: m_Type(std::move(_Right.m_Type))
		, m_Name(std::move(_Right.m_Name))
		, m_Data(std::move(_Right.m_Data))
	{
	}
	HPMVersionControlMetaDataEntry &operator =(HPMVersionControlMetaDataEntry const &_Right)
	{
		m_Type = _Right.m_Type;
		m_Name = _Right.m_Name;
		m_Data = _Right.m_Data;
		return *this;
	}
	HPMVersionControlMetaDataEntry &operator =(HPMVersionControlMetaDataEntry &&_Right)
	{
		m_Type = std::move(_Right.m_Type);
		m_Name = std::move(_Right.m_Name);
		m_Data = std::move(_Right.m_Data);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlMetaDataEntry &_Right) const
	{
		if (m_Type != _Right.m_Type)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		if (m_Data != _Right.m_Data)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlMetaDataEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlMetaDataEntry &_Right) const
	{
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_Data < _Right.m_Data)
			return true;
		if (m_Data > _Right.m_Data)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlMetaDataEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlMetaDataEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlMetaDataEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFileList
{
	public:
	std::vector<HPMString> m_Files;
	HPMVersionControlFileList()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFileList(HPMVersionControlFileList const &_Right)
		: m_Files(_Right.m_Files)
	{
	}
	HPMVersionControlFileList(HPMVersionControlFileList &&_Right)
		: m_Files(std::move(_Right.m_Files))
	{
	}
	HPMVersionControlFileList &operator =(HPMVersionControlFileList const &_Right)
	{
		m_Files = _Right.m_Files;
		return *this;
	}
	HPMVersionControlFileList &operator =(HPMVersionControlFileList &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFileList &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFileList &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFileList &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFileList &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFileList &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFileList &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFileHistoryEntry
{
	public:
	EHPMVersionControlFileAttributesFlag m_FileAttributes;
	HPMUInt64 m_Version;
	HPMUInt64 m_Revision;
	EHPMVersionControlVersionAction m_Action;
	EHPMVersionControlVersionActionInfo m_ActionInfoID;
	HPMUInt64 m_Date;
	HPMMD5Checksum m_Checksum;
	HPMString m_FileName;
	HPMString m_Comment;
	HPMString m_User;
	HPMString m_ActionInfo;
	HPMString m_ActionInfoArg;
	std::vector<HPMVersionControlMetaDataEntry> m_MetaDataEntries;
	HPMVersionControlFileHistoryEntry()
		: m_FileAttributes(EHPMVersionControlFileAttributesFlag_None)
		, m_Version(0)
		, m_Revision(0)
		, m_Action(EHPMVersionControlVersionAction_None)
		, m_ActionInfoID(EHPMVersionControlVersionActionInfo_None)
		, m_Date(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFileHistoryEntry(HPMVersionControlFileHistoryEntry const &_Right)
		: m_FileAttributes(_Right.m_FileAttributes)
		, m_Version(_Right.m_Version)
		, m_Revision(_Right.m_Revision)
		, m_Action(_Right.m_Action)
		, m_ActionInfoID(_Right.m_ActionInfoID)
		, m_Date(_Right.m_Date)
		, m_Checksum(_Right.m_Checksum)
		, m_FileName(_Right.m_FileName)
		, m_Comment(_Right.m_Comment)
		, m_User(_Right.m_User)
		, m_ActionInfo(_Right.m_ActionInfo)
		, m_ActionInfoArg(_Right.m_ActionInfoArg)
		, m_MetaDataEntries(_Right.m_MetaDataEntries)
	{
	}
	HPMVersionControlFileHistoryEntry(HPMVersionControlFileHistoryEntry &&_Right)
		: m_FileAttributes(std::move(_Right.m_FileAttributes))
		, m_Version(std::move(_Right.m_Version))
		, m_Revision(std::move(_Right.m_Revision))
		, m_Action(std::move(_Right.m_Action))
		, m_ActionInfoID(std::move(_Right.m_ActionInfoID))
		, m_Date(std::move(_Right.m_Date))
		, m_Checksum(std::move(_Right.m_Checksum))
		, m_FileName(std::move(_Right.m_FileName))
		, m_Comment(std::move(_Right.m_Comment))
		, m_User(std::move(_Right.m_User))
		, m_ActionInfo(std::move(_Right.m_ActionInfo))
		, m_ActionInfoArg(std::move(_Right.m_ActionInfoArg))
		, m_MetaDataEntries(std::move(_Right.m_MetaDataEntries))
	{
	}
	HPMVersionControlFileHistoryEntry &operator =(HPMVersionControlFileHistoryEntry const &_Right)
	{
		m_FileAttributes = _Right.m_FileAttributes;
		m_Version = _Right.m_Version;
		m_Revision = _Right.m_Revision;
		m_Action = _Right.m_Action;
		m_ActionInfoID = _Right.m_ActionInfoID;
		m_Date = _Right.m_Date;
		m_Checksum = _Right.m_Checksum;
		m_FileName = _Right.m_FileName;
		m_Comment = _Right.m_Comment;
		m_User = _Right.m_User;
		m_ActionInfo = _Right.m_ActionInfo;
		m_ActionInfoArg = _Right.m_ActionInfoArg;
		m_MetaDataEntries = _Right.m_MetaDataEntries;
		return *this;
	}
	HPMVersionControlFileHistoryEntry &operator =(HPMVersionControlFileHistoryEntry &&_Right)
	{
		m_FileAttributes = std::move(_Right.m_FileAttributes);
		m_Version = std::move(_Right.m_Version);
		m_Revision = std::move(_Right.m_Revision);
		m_Action = std::move(_Right.m_Action);
		m_ActionInfoID = std::move(_Right.m_ActionInfoID);
		m_Date = std::move(_Right.m_Date);
		m_Checksum = std::move(_Right.m_Checksum);
		m_FileName = std::move(_Right.m_FileName);
		m_Comment = std::move(_Right.m_Comment);
		m_User = std::move(_Right.m_User);
		m_ActionInfo = std::move(_Right.m_ActionInfo);
		m_ActionInfoArg = std::move(_Right.m_ActionInfoArg);
		m_MetaDataEntries = std::move(_Right.m_MetaDataEntries);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		if (m_FileAttributes != _Right.m_FileAttributes)
			return false;
		if (m_Version != _Right.m_Version)
			return false;
		if (m_Revision != _Right.m_Revision)
			return false;
		if (m_Action != _Right.m_Action)
			return false;
		if (m_ActionInfoID != _Right.m_ActionInfoID)
			return false;
		if (m_Date != _Right.m_Date)
			return false;
		if (m_Checksum != _Right.m_Checksum)
			return false;
		if (m_FileName != _Right.m_FileName)
			return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_User != _Right.m_User)
			return false;
		if (m_ActionInfo != _Right.m_ActionInfo)
			return false;
		if (m_ActionInfoArg != _Right.m_ActionInfoArg)
			return false;
		if (m_MetaDataEntries.size() != _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
			if (m_MetaDataEntries[i] != _Right.m_MetaDataEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		if (m_FileAttributes < _Right.m_FileAttributes)
			return true;
		if (m_FileAttributes > _Right.m_FileAttributes)
			return false;
		if (m_Version < _Right.m_Version)
			return true;
		if (m_Version > _Right.m_Version)
			return false;
		if (m_Revision < _Right.m_Revision)
			return true;
		if (m_Revision > _Right.m_Revision)
			return false;
		if (m_Action < _Right.m_Action)
			return true;
		if (m_Action > _Right.m_Action)
			return false;
		if (m_ActionInfoID < _Right.m_ActionInfoID)
			return true;
		if (m_ActionInfoID > _Right.m_ActionInfoID)
			return false;
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_Checksum < _Right.m_Checksum)
			return true;
		if (m_Checksum > _Right.m_Checksum)
			return false;
		if (m_FileName < _Right.m_FileName)
			return true;
		if (m_FileName > _Right.m_FileName)
			return false;
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_User < _Right.m_User)
			return true;
		if (m_User > _Right.m_User)
			return false;
		if (m_ActionInfo < _Right.m_ActionInfo)
			return true;
		if (m_ActionInfo > _Right.m_ActionInfo)
			return false;
		if (m_ActionInfoArg < _Right.m_ActionInfoArg)
			return true;
		if (m_ActionInfoArg > _Right.m_ActionInfoArg)
			return false;
		if (m_MetaDataEntries.size() < _Right.m_MetaDataEntries.size())
			return true;
		if (m_MetaDataEntries.size() > _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
		{
			if (m_MetaDataEntries[i] < _Right.m_MetaDataEntries[i])
				return true;
			if (m_MetaDataEntries[i] > _Right.m_MetaDataEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFileHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFileHistory
{
	public:
	std::vector<HPMVersionControlFileHistoryEntry> m_HistoryEntries;
	HPMVersionControlFileHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFileHistory(HPMVersionControlFileHistory const &_Right)
		: m_HistoryEntries(_Right.m_HistoryEntries)
	{
	}
	HPMVersionControlFileHistory(HPMVersionControlFileHistory &&_Right)
		: m_HistoryEntries(std::move(_Right.m_HistoryEntries))
	{
	}
	HPMVersionControlFileHistory &operator =(HPMVersionControlFileHistory const &_Right)
	{
		m_HistoryEntries = _Right.m_HistoryEntries;
		return *this;
	}
	HPMVersionControlFileHistory &operator =(HPMVersionControlFileHistory &&_Right)
	{
		m_HistoryEntries = std::move(_Right.m_HistoryEntries);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFileHistory &_Right) const
	{
		if (m_HistoryEntries.size() != _Right.m_HistoryEntries.size())
			return false;
		for (size_t i = 0; i < m_HistoryEntries.size(); ++i)
			if (m_HistoryEntries[i] != _Right.m_HistoryEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFileHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFileHistory &_Right) const
	{
		if (m_HistoryEntries.size() < _Right.m_HistoryEntries.size())
			return true;
		if (m_HistoryEntries.size() > _Right.m_HistoryEntries.size())
			return false;
		for (size_t i = 0; i < m_HistoryEntries.size(); ++i)
		{
			if (m_HistoryEntries[i] < _Right.m_HistoryEntries[i])
				return true;
			if (m_HistoryEntries[i] > _Right.m_HistoryEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFileHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFileHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFileHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlAccessRight
{
	public:
	HPMUniqueID m_Object;
	EHPMResourceGroupingType m_Type;
	EHPMVersionControlAccessRightFlag m_GrantFlags;
	EHPMVersionControlAccessRightFlag m_RejectFlags;
	HPMVersionControlAccessRight()
		: m_Type(EHPMResourceGroupingType_Resource)
		, m_GrantFlags(EHPMVersionControlAccessRightFlag_None)
		, m_RejectFlags(EHPMVersionControlAccessRightFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlAccessRight(HPMVersionControlAccessRight const &_Right)
		: m_Object(_Right.m_Object)
		, m_Type(_Right.m_Type)
		, m_GrantFlags(_Right.m_GrantFlags)
		, m_RejectFlags(_Right.m_RejectFlags)
	{
	}
	HPMVersionControlAccessRight(HPMVersionControlAccessRight &&_Right)
		: m_Object(std::move(_Right.m_Object))
		, m_Type(std::move(_Right.m_Type))
		, m_GrantFlags(std::move(_Right.m_GrantFlags))
		, m_RejectFlags(std::move(_Right.m_RejectFlags))
	{
	}
	HPMVersionControlAccessRight &operator =(HPMVersionControlAccessRight const &_Right)
	{
		m_Object = _Right.m_Object;
		m_Type = _Right.m_Type;
		m_GrantFlags = _Right.m_GrantFlags;
		m_RejectFlags = _Right.m_RejectFlags;
		return *this;
	}
	HPMVersionControlAccessRight &operator =(HPMVersionControlAccessRight &&_Right)
	{
		m_Object = std::move(_Right.m_Object);
		m_Type = std::move(_Right.m_Type);
		m_GrantFlags = std::move(_Right.m_GrantFlags);
		m_RejectFlags = std::move(_Right.m_RejectFlags);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlAccessRight &_Right) const
	{
		if (m_Object != _Right.m_Object)
			return false;
		if (m_Type != _Right.m_Type)
			return false;
		if (m_GrantFlags != _Right.m_GrantFlags)
			return false;
		if (m_RejectFlags != _Right.m_RejectFlags)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlAccessRight &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlAccessRight &_Right) const
	{
		if (m_Object < _Right.m_Object)
			return true;
		if (m_Object > _Right.m_Object)
			return false;
		if (m_Type < _Right.m_Type)
			return true;
		if (m_Type > _Right.m_Type)
			return false;
		if (m_GrantFlags < _Right.m_GrantFlags)
			return true;
		if (m_GrantFlags > _Right.m_GrantFlags)
			return false;
		if (m_RejectFlags < _Right.m_RejectFlags)
			return true;
		if (m_RejectFlags > _Right.m_RejectFlags)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlAccessRight &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlAccessRight &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlAccessRight &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlAccessRights
{
	public:
	bool m_bInherit;
	bool m_bUseInheritedRights;
	std::vector<HPMVersionControlAccessRight> m_AccessRights;
	std::vector<HPMVersionControlAccessRight> m_InheritedAccessRights;
	HPMVersionControlAccessRights()
		: m_bInherit(1)
		, m_bUseInheritedRights(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlAccessRights(HPMVersionControlAccessRights const &_Right)
		: m_bInherit(_Right.m_bInherit)
		, m_bUseInheritedRights(_Right.m_bUseInheritedRights)
		, m_AccessRights(_Right.m_AccessRights)
		, m_InheritedAccessRights(_Right.m_InheritedAccessRights)
	{
	}
	HPMVersionControlAccessRights(HPMVersionControlAccessRights &&_Right)
		: m_bInherit(std::move(_Right.m_bInherit))
		, m_bUseInheritedRights(std::move(_Right.m_bUseInheritedRights))
		, m_AccessRights(std::move(_Right.m_AccessRights))
		, m_InheritedAccessRights(std::move(_Right.m_InheritedAccessRights))
	{
	}
	HPMVersionControlAccessRights &operator =(HPMVersionControlAccessRights const &_Right)
	{
		m_bInherit = _Right.m_bInherit;
		m_bUseInheritedRights = _Right.m_bUseInheritedRights;
		m_AccessRights = _Right.m_AccessRights;
		m_InheritedAccessRights = _Right.m_InheritedAccessRights;
		return *this;
	}
	HPMVersionControlAccessRights &operator =(HPMVersionControlAccessRights &&_Right)
	{
		m_bInherit = std::move(_Right.m_bInherit);
		m_bUseInheritedRights = std::move(_Right.m_bUseInheritedRights);
		m_AccessRights = std::move(_Right.m_AccessRights);
		m_InheritedAccessRights = std::move(_Right.m_InheritedAccessRights);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlAccessRights &_Right) const
	{
		if (m_bInherit != _Right.m_bInherit)
			return false;
		if (m_bUseInheritedRights != _Right.m_bUseInheritedRights)
			return false;
		if (m_AccessRights.size() != _Right.m_AccessRights.size())
			return false;
		for (size_t i = 0; i < m_AccessRights.size(); ++i)
			if (m_AccessRights[i] != _Right.m_AccessRights[i])
				return false;
		if (m_InheritedAccessRights.size() != _Right.m_InheritedAccessRights.size())
			return false;
		for (size_t i = 0; i < m_InheritedAccessRights.size(); ++i)
			if (m_InheritedAccessRights[i] != _Right.m_InheritedAccessRights[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlAccessRights &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlAccessRights &_Right) const
	{
		if (m_bInherit < _Right.m_bInherit)
			return true;
		if (m_bInherit > _Right.m_bInherit)
			return false;
		if (m_bUseInheritedRights < _Right.m_bUseInheritedRights)
			return true;
		if (m_bUseInheritedRights > _Right.m_bUseInheritedRights)
			return false;
		if (m_AccessRights.size() < _Right.m_AccessRights.size())
			return true;
		if (m_AccessRights.size() > _Right.m_AccessRights.size())
			return false;
		for (size_t i = 0; i < m_AccessRights.size(); ++i)
		{
			if (m_AccessRights[i] < _Right.m_AccessRights[i])
				return true;
			if (m_AccessRights[i] > _Right.m_AccessRights[i])
				return false;
		}
		if (m_InheritedAccessRights.size() < _Right.m_InheritedAccessRights.size())
			return true;
		if (m_InheritedAccessRights.size() > _Right.m_InheritedAccessRights.size())
			return false;
		for (size_t i = 0; i < m_InheritedAccessRights.size(); ++i)
		{
			if (m_InheritedAccessRights[i] < _Right.m_InheritedAccessRights[i])
				return true;
			if (m_InheritedAccessRights[i] > _Right.m_InheritedAccessRights[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlAccessRights &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlAccessRights &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlAccessRights &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFile
{
	public:
	EHPMVersionControlFileAttributesFlag m_FileAttributes;
	HPMUInt64 m_FileID;
	HPMUInt64 m_Version;
	HPMUInt64 m_Revision;
	HPMInt64 m_Size;
	EHPMVersionControlVersionAction m_Action;
	EHPMVersionControlFileInfoFlag m_Flags;
	EHPMVersionControlAccessRightFlag m_EffectiveAccessRights;
	HPMUInt64 m_Date;
	HPMMD5Checksum m_Checksum;
	HPMString m_FileName;
	HPMString m_CheckedOutBy;
	HPMString m_Comment;
	HPMString m_User;
	HPMUniqueID m_OriginalCreator;
	std::vector<HPMVersionControlMetaDataEntry> m_MetaDataEntries;
	HPMVersionControlFile()
		: m_FileAttributes(EHPMVersionControlFileAttributesFlag_None)
		, m_FileID(0)
		, m_Version(0)
		, m_Revision(0)
		, m_Size(0)
		, m_Action(EHPMVersionControlVersionAction_None)
		, m_Flags(EHPMVersionControlFileInfoFlag_None)
		, m_EffectiveAccessRights(EHPMVersionControlAccessRightFlag_None)
		, m_Date(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFile(HPMVersionControlFile const &_Right)
		: m_FileAttributes(_Right.m_FileAttributes)
		, m_FileID(_Right.m_FileID)
		, m_Version(_Right.m_Version)
		, m_Revision(_Right.m_Revision)
		, m_Size(_Right.m_Size)
		, m_Action(_Right.m_Action)
		, m_Flags(_Right.m_Flags)
		, m_EffectiveAccessRights(_Right.m_EffectiveAccessRights)
		, m_Date(_Right.m_Date)
		, m_Checksum(_Right.m_Checksum)
		, m_FileName(_Right.m_FileName)
		, m_CheckedOutBy(_Right.m_CheckedOutBy)
		, m_Comment(_Right.m_Comment)
		, m_User(_Right.m_User)
		, m_OriginalCreator(_Right.m_OriginalCreator)
		, m_MetaDataEntries(_Right.m_MetaDataEntries)
	{
	}
	HPMVersionControlFile(HPMVersionControlFile &&_Right)
		: m_FileAttributes(std::move(_Right.m_FileAttributes))
		, m_FileID(std::move(_Right.m_FileID))
		, m_Version(std::move(_Right.m_Version))
		, m_Revision(std::move(_Right.m_Revision))
		, m_Size(std::move(_Right.m_Size))
		, m_Action(std::move(_Right.m_Action))
		, m_Flags(std::move(_Right.m_Flags))
		, m_EffectiveAccessRights(std::move(_Right.m_EffectiveAccessRights))
		, m_Date(std::move(_Right.m_Date))
		, m_Checksum(std::move(_Right.m_Checksum))
		, m_FileName(std::move(_Right.m_FileName))
		, m_CheckedOutBy(std::move(_Right.m_CheckedOutBy))
		, m_Comment(std::move(_Right.m_Comment))
		, m_User(std::move(_Right.m_User))
		, m_OriginalCreator(std::move(_Right.m_OriginalCreator))
		, m_MetaDataEntries(std::move(_Right.m_MetaDataEntries))
	{
	}
	HPMVersionControlFile &operator =(HPMVersionControlFile const &_Right)
	{
		m_FileAttributes = _Right.m_FileAttributes;
		m_FileID = _Right.m_FileID;
		m_Version = _Right.m_Version;
		m_Revision = _Right.m_Revision;
		m_Size = _Right.m_Size;
		m_Action = _Right.m_Action;
		m_Flags = _Right.m_Flags;
		m_EffectiveAccessRights = _Right.m_EffectiveAccessRights;
		m_Date = _Right.m_Date;
		m_Checksum = _Right.m_Checksum;
		m_FileName = _Right.m_FileName;
		m_CheckedOutBy = _Right.m_CheckedOutBy;
		m_Comment = _Right.m_Comment;
		m_User = _Right.m_User;
		m_OriginalCreator = _Right.m_OriginalCreator;
		m_MetaDataEntries = _Right.m_MetaDataEntries;
		return *this;
	}
	HPMVersionControlFile &operator =(HPMVersionControlFile &&_Right)
	{
		m_FileAttributes = std::move(_Right.m_FileAttributes);
		m_FileID = std::move(_Right.m_FileID);
		m_Version = std::move(_Right.m_Version);
		m_Revision = std::move(_Right.m_Revision);
		m_Size = std::move(_Right.m_Size);
		m_Action = std::move(_Right.m_Action);
		m_Flags = std::move(_Right.m_Flags);
		m_EffectiveAccessRights = std::move(_Right.m_EffectiveAccessRights);
		m_Date = std::move(_Right.m_Date);
		m_Checksum = std::move(_Right.m_Checksum);
		m_FileName = std::move(_Right.m_FileName);
		m_CheckedOutBy = std::move(_Right.m_CheckedOutBy);
		m_Comment = std::move(_Right.m_Comment);
		m_User = std::move(_Right.m_User);
		m_OriginalCreator = std::move(_Right.m_OriginalCreator);
		m_MetaDataEntries = std::move(_Right.m_MetaDataEntries);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFile &_Right) const
	{
		if (m_FileAttributes != _Right.m_FileAttributes)
			return false;
		if (m_FileID != _Right.m_FileID)
			return false;
		if (m_Version != _Right.m_Version)
			return false;
		if (m_Revision != _Right.m_Revision)
			return false;
		if (m_Size != _Right.m_Size)
			return false;
		if (m_Action != _Right.m_Action)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_EffectiveAccessRights != _Right.m_EffectiveAccessRights)
			return false;
		if (m_Date != _Right.m_Date)
			return false;
		if (m_Checksum != _Right.m_Checksum)
			return false;
		if (m_FileName != _Right.m_FileName)
			return false;
		if (m_CheckedOutBy != _Right.m_CheckedOutBy)
			return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_User != _Right.m_User)
			return false;
		if (m_OriginalCreator != _Right.m_OriginalCreator)
			return false;
		if (m_MetaDataEntries.size() != _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
			if (m_MetaDataEntries[i] != _Right.m_MetaDataEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFile &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFile &_Right) const
	{
		if (m_FileAttributes < _Right.m_FileAttributes)
			return true;
		if (m_FileAttributes > _Right.m_FileAttributes)
			return false;
		if (m_FileID < _Right.m_FileID)
			return true;
		if (m_FileID > _Right.m_FileID)
			return false;
		if (m_Version < _Right.m_Version)
			return true;
		if (m_Version > _Right.m_Version)
			return false;
		if (m_Revision < _Right.m_Revision)
			return true;
		if (m_Revision > _Right.m_Revision)
			return false;
		if (m_Size < _Right.m_Size)
			return true;
		if (m_Size > _Right.m_Size)
			return false;
		if (m_Action < _Right.m_Action)
			return true;
		if (m_Action > _Right.m_Action)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_EffectiveAccessRights < _Right.m_EffectiveAccessRights)
			return true;
		if (m_EffectiveAccessRights > _Right.m_EffectiveAccessRights)
			return false;
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_Checksum < _Right.m_Checksum)
			return true;
		if (m_Checksum > _Right.m_Checksum)
			return false;
		if (m_FileName < _Right.m_FileName)
			return true;
		if (m_FileName > _Right.m_FileName)
			return false;
		if (m_CheckedOutBy < _Right.m_CheckedOutBy)
			return true;
		if (m_CheckedOutBy > _Right.m_CheckedOutBy)
			return false;
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_User < _Right.m_User)
			return true;
		if (m_User > _Right.m_User)
			return false;
		if (m_OriginalCreator < _Right.m_OriginalCreator)
			return true;
		if (m_OriginalCreator > _Right.m_OriginalCreator)
			return false;
		if (m_MetaDataEntries.size() < _Right.m_MetaDataEntries.size())
			return true;
		if (m_MetaDataEntries.size() > _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
		{
			if (m_MetaDataEntries[i] < _Right.m_MetaDataEntries[i])
				return true;
			if (m_MetaDataEntries[i] > _Right.m_MetaDataEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFile &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFile &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFile &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFilesEnum
{
	public:
	std::vector<HPMVersionControlFile> m_Files;
	HPMVersionControlFilesEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFilesEnum(HPMVersionControlFilesEnum const &_Right)
		: m_Files(_Right.m_Files)
	{
	}
	HPMVersionControlFilesEnum(HPMVersionControlFilesEnum &&_Right)
		: m_Files(std::move(_Right.m_Files))
	{
	}
	HPMVersionControlFilesEnum &operator =(HPMVersionControlFilesEnum const &_Right)
	{
		m_Files = _Right.m_Files;
		return *this;
	}
	HPMVersionControlFilesEnum &operator =(HPMVersionControlFilesEnum &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFilesEnum &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFilesEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFilesEnum &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFilesEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFilesEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFilesEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlFileSpec
{
	public:
	HPMString m_Path;
	std::vector<HPMVersionControlMetaDataEntry> m_MetaDataEntries;
	HPMVersionControlFileSpec()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlFileSpec(HPMVersionControlFileSpec const &_Right)
		: m_Path(_Right.m_Path)
		, m_MetaDataEntries(_Right.m_MetaDataEntries)
	{
	}
	HPMVersionControlFileSpec(HPMVersionControlFileSpec &&_Right)
		: m_Path(std::move(_Right.m_Path))
		, m_MetaDataEntries(std::move(_Right.m_MetaDataEntries))
	{
	}
	HPMVersionControlFileSpec &operator =(HPMVersionControlFileSpec const &_Right)
	{
		m_Path = _Right.m_Path;
		m_MetaDataEntries = _Right.m_MetaDataEntries;
		return *this;
	}
	HPMVersionControlFileSpec &operator =(HPMVersionControlFileSpec &&_Right)
	{
		m_Path = std::move(_Right.m_Path);
		m_MetaDataEntries = std::move(_Right.m_MetaDataEntries);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlFileSpec &_Right) const
	{
		if (m_Path != _Right.m_Path)
			return false;
		if (m_MetaDataEntries.size() != _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
			if (m_MetaDataEntries[i] != _Right.m_MetaDataEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlFileSpec &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlFileSpec &_Right) const
	{
		if (m_Path < _Right.m_Path)
			return true;
		if (m_Path > _Right.m_Path)
			return false;
		if (m_MetaDataEntries.size() < _Right.m_MetaDataEntries.size())
			return true;
		if (m_MetaDataEntries.size() > _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
		{
			if (m_MetaDataEntries[i] < _Right.m_MetaDataEntries[i])
				return true;
			if (m_MetaDataEntries[i] > _Right.m_MetaDataEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlFileSpec &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlFileSpec &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlFileSpec &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlLocalFilePair
{
	public:
	HPMVersionControlFileSpec m_FileSpec;
	HPMString m_LocalPath;
	std::vector<HPMUInt8> m_FileData;
	HPMVersionControlLocalFilePair()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlLocalFilePair(HPMVersionControlLocalFilePair const &_Right)
		: m_FileSpec(_Right.m_FileSpec)
		, m_LocalPath(_Right.m_LocalPath)
		, m_FileData(_Right.m_FileData)
	{
	}
	HPMVersionControlLocalFilePair(HPMVersionControlLocalFilePair &&_Right)
		: m_FileSpec(std::move(_Right.m_FileSpec))
		, m_LocalPath(std::move(_Right.m_LocalPath))
		, m_FileData(std::move(_Right.m_FileData))
	{
	}
	HPMVersionControlLocalFilePair &operator =(HPMVersionControlLocalFilePair const &_Right)
	{
		m_FileSpec = _Right.m_FileSpec;
		m_LocalPath = _Right.m_LocalPath;
		m_FileData = _Right.m_FileData;
		return *this;
	}
	HPMVersionControlLocalFilePair &operator =(HPMVersionControlLocalFilePair &&_Right)
	{
		m_FileSpec = std::move(_Right.m_FileSpec);
		m_LocalPath = std::move(_Right.m_LocalPath);
		m_FileData = std::move(_Right.m_FileData);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlLocalFilePair &_Right) const
	{
		if (m_FileSpec != _Right.m_FileSpec)
			return false;
		if (m_LocalPath != _Right.m_LocalPath)
			return false;
		if (m_FileData.size() != _Right.m_FileData.size())
			return false;
		for (size_t i = 0; i < m_FileData.size(); ++i)
			if (m_FileData[i] != _Right.m_FileData[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlLocalFilePair &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlLocalFilePair &_Right) const
	{
		if (m_FileSpec < _Right.m_FileSpec)
			return true;
		if (m_FileSpec > _Right.m_FileSpec)
			return false;
		if (m_LocalPath < _Right.m_LocalPath)
			return true;
		if (m_LocalPath > _Right.m_LocalPath)
			return false;
		if (m_FileData.size() < _Right.m_FileData.size())
			return true;
		if (m_FileData.size() > _Right.m_FileData.size())
			return false;
		for (size_t i = 0; i < m_FileData.size(); ++i)
		{
			if (m_FileData[i] < _Right.m_FileData[i])
				return true;
			if (m_FileData[i] > _Right.m_FileData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlLocalFilePair &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlLocalFilePair &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlLocalFilePair &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlAddFiles
{
	public:
	std::vector<HPMVersionControlLocalFilePair> m_FilesToAdd;
	HPMString m_Comment;
	bool m_bDeleteSourceFiles;
	std::vector<HPMUInt8> m_ExtraData;
	HPMVersionControlAddFiles()
		: m_bDeleteSourceFiles(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlAddFiles(HPMVersionControlAddFiles const &_Right)
		: m_FilesToAdd(_Right.m_FilesToAdd)
		, m_Comment(_Right.m_Comment)
		, m_bDeleteSourceFiles(_Right.m_bDeleteSourceFiles)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMVersionControlAddFiles(HPMVersionControlAddFiles &&_Right)
		: m_FilesToAdd(std::move(_Right.m_FilesToAdd))
		, m_Comment(std::move(_Right.m_Comment))
		, m_bDeleteSourceFiles(std::move(_Right.m_bDeleteSourceFiles))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMVersionControlAddFiles &operator =(HPMVersionControlAddFiles const &_Right)
	{
		m_FilesToAdd = _Right.m_FilesToAdd;
		m_Comment = _Right.m_Comment;
		m_bDeleteSourceFiles = _Right.m_bDeleteSourceFiles;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMVersionControlAddFiles &operator =(HPMVersionControlAddFiles &&_Right)
	{
		m_FilesToAdd = std::move(_Right.m_FilesToAdd);
		m_Comment = std::move(_Right.m_Comment);
		m_bDeleteSourceFiles = std::move(_Right.m_bDeleteSourceFiles);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlAddFiles &_Right) const
	{
		if (m_FilesToAdd.size() != _Right.m_FilesToAdd.size())
			return false;
		for (size_t i = 0; i < m_FilesToAdd.size(); ++i)
			if (m_FilesToAdd[i] != _Right.m_FilesToAdd[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_bDeleteSourceFiles != _Right.m_bDeleteSourceFiles)
			return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlAddFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlAddFiles &_Right) const
	{
		if (m_FilesToAdd.size() < _Right.m_FilesToAdd.size())
			return true;
		if (m_FilesToAdd.size() > _Right.m_FilesToAdd.size())
			return false;
		for (size_t i = 0; i < m_FilesToAdd.size(); ++i)
		{
			if (m_FilesToAdd[i] < _Right.m_FilesToAdd[i])
				return true;
			if (m_FilesToAdd[i] > _Right.m_FilesToAdd[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_bDeleteSourceFiles < _Right.m_bDeleteSourceFiles)
			return true;
		if (m_bDeleteSourceFiles > _Right.m_bDeleteSourceFiles)
			return false;
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlAddFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlAddFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlAddFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlCreateDirectories
{
	public:
	std::vector<HPMVersionControlFileSpec> m_Files;
	HPMString m_Comment;
	std::vector<HPMUInt8> m_ExtraData;
	HPMVersionControlCreateDirectories()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlCreateDirectories(HPMVersionControlCreateDirectories const &_Right)
		: m_Files(_Right.m_Files)
		, m_Comment(_Right.m_Comment)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMVersionControlCreateDirectories(HPMVersionControlCreateDirectories &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_Comment(std::move(_Right.m_Comment))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMVersionControlCreateDirectories &operator =(HPMVersionControlCreateDirectories const &_Right)
	{
		m_Files = _Right.m_Files;
		m_Comment = _Right.m_Comment;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMVersionControlCreateDirectories &operator =(HPMVersionControlCreateDirectories &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_Comment = std::move(_Right.m_Comment);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlCreateDirectories &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlCreateDirectories &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlCreateDirectories &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlCreateDirectories &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlCreateDirectories &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlCreateDirectories &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlCheckInFiles
{
	public:
	std::vector<HPMVersionControlFileSpec> m_Files;
	HPMString m_Comment;
	bool m_bRecursive;
	bool m_bKeepCheckedOut;
	bool m_bKeepUnchangedCheckedOut;
	bool m_bDeleteSourceFiles;
	std::vector<HPMUInt8> m_ExtraData;
	HPMVersionControlCheckInFiles()
		: m_bRecursive(1)
		, m_bKeepCheckedOut(0)
		, m_bKeepUnchangedCheckedOut(0)
		, m_bDeleteSourceFiles(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlCheckInFiles(HPMVersionControlCheckInFiles const &_Right)
		: m_Files(_Right.m_Files)
		, m_Comment(_Right.m_Comment)
		, m_bRecursive(_Right.m_bRecursive)
		, m_bKeepCheckedOut(_Right.m_bKeepCheckedOut)
		, m_bKeepUnchangedCheckedOut(_Right.m_bKeepUnchangedCheckedOut)
		, m_bDeleteSourceFiles(_Right.m_bDeleteSourceFiles)
		, m_ExtraData(_Right.m_ExtraData)
	{
	}
	HPMVersionControlCheckInFiles(HPMVersionControlCheckInFiles &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_Comment(std::move(_Right.m_Comment))
		, m_bRecursive(std::move(_Right.m_bRecursive))
		, m_bKeepCheckedOut(std::move(_Right.m_bKeepCheckedOut))
		, m_bKeepUnchangedCheckedOut(std::move(_Right.m_bKeepUnchangedCheckedOut))
		, m_bDeleteSourceFiles(std::move(_Right.m_bDeleteSourceFiles))
		, m_ExtraData(std::move(_Right.m_ExtraData))
	{
	}
	HPMVersionControlCheckInFiles &operator =(HPMVersionControlCheckInFiles const &_Right)
	{
		m_Files = _Right.m_Files;
		m_Comment = _Right.m_Comment;
		m_bRecursive = _Right.m_bRecursive;
		m_bKeepCheckedOut = _Right.m_bKeepCheckedOut;
		m_bKeepUnchangedCheckedOut = _Right.m_bKeepUnchangedCheckedOut;
		m_bDeleteSourceFiles = _Right.m_bDeleteSourceFiles;
		m_ExtraData = _Right.m_ExtraData;
		return *this;
	}
	HPMVersionControlCheckInFiles &operator =(HPMVersionControlCheckInFiles &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_Comment = std::move(_Right.m_Comment);
		m_bRecursive = std::move(_Right.m_bRecursive);
		m_bKeepCheckedOut = std::move(_Right.m_bKeepCheckedOut);
		m_bKeepUnchangedCheckedOut = std::move(_Right.m_bKeepUnchangedCheckedOut);
		m_bDeleteSourceFiles = std::move(_Right.m_bDeleteSourceFiles);
		m_ExtraData = std::move(_Right.m_ExtraData);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlCheckInFiles &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_bRecursive != _Right.m_bRecursive)
			return false;
		if (m_bKeepCheckedOut != _Right.m_bKeepCheckedOut)
			return false;
		if (m_bKeepUnchangedCheckedOut != _Right.m_bKeepUnchangedCheckedOut)
			return false;
		if (m_bDeleteSourceFiles != _Right.m_bDeleteSourceFiles)
			return false;
		if (m_ExtraData.size() != _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
			if (m_ExtraData[i] != _Right.m_ExtraData[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlCheckInFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlCheckInFiles &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_bRecursive < _Right.m_bRecursive)
			return true;
		if (m_bRecursive > _Right.m_bRecursive)
			return false;
		if (m_bKeepCheckedOut < _Right.m_bKeepCheckedOut)
			return true;
		if (m_bKeepCheckedOut > _Right.m_bKeepCheckedOut)
			return false;
		if (m_bKeepUnchangedCheckedOut < _Right.m_bKeepUnchangedCheckedOut)
			return true;
		if (m_bKeepUnchangedCheckedOut > _Right.m_bKeepUnchangedCheckedOut)
			return false;
		if (m_bDeleteSourceFiles < _Right.m_bDeleteSourceFiles)
			return true;
		if (m_bDeleteSourceFiles > _Right.m_bDeleteSourceFiles)
			return false;
		if (m_ExtraData.size() < _Right.m_ExtraData.size())
			return true;
		if (m_ExtraData.size() > _Right.m_ExtraData.size())
			return false;
		for (size_t i = 0; i < m_ExtraData.size(); ++i)
		{
			if (m_ExtraData[i] < _Right.m_ExtraData[i])
				return true;
			if (m_ExtraData[i] > _Right.m_ExtraData[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlCheckInFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlCheckInFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlCheckInFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlRenameFiles
{
	public:
	std::vector<HPMVersionControlFileSpec> m_Files;
	HPMString m_Comment;
	HPMString m_RenameTo;
	HPMVersionControlRenameFiles()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlRenameFiles(HPMVersionControlRenameFiles const &_Right)
		: m_Files(_Right.m_Files)
		, m_Comment(_Right.m_Comment)
		, m_RenameTo(_Right.m_RenameTo)
	{
	}
	HPMVersionControlRenameFiles(HPMVersionControlRenameFiles &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_Comment(std::move(_Right.m_Comment))
		, m_RenameTo(std::move(_Right.m_RenameTo))
	{
	}
	HPMVersionControlRenameFiles &operator =(HPMVersionControlRenameFiles const &_Right)
	{
		m_Files = _Right.m_Files;
		m_Comment = _Right.m_Comment;
		m_RenameTo = _Right.m_RenameTo;
		return *this;
	}
	HPMVersionControlRenameFiles &operator =(HPMVersionControlRenameFiles &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_Comment = std::move(_Right.m_Comment);
		m_RenameTo = std::move(_Right.m_RenameTo);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlRenameFiles &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_RenameTo != _Right.m_RenameTo)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlRenameFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlRenameFiles &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_RenameTo < _Right.m_RenameTo)
			return true;
		if (m_RenameTo > _Right.m_RenameTo)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlRenameFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlRenameFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlRenameFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlRevertFiles
{
	public:
	std::vector<HPMString> m_Files;
	bool m_bRecursive;
	bool m_bReplaceLocally;
	bool m_bForceRevert;
	HPMVersionControlRevertFiles()
		: m_bRecursive(0)
		, m_bReplaceLocally(0)
		, m_bForceRevert(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlRevertFiles(HPMVersionControlRevertFiles const &_Right)
		: m_Files(_Right.m_Files)
		, m_bRecursive(_Right.m_bRecursive)
		, m_bReplaceLocally(_Right.m_bReplaceLocally)
		, m_bForceRevert(_Right.m_bForceRevert)
	{
	}
	HPMVersionControlRevertFiles(HPMVersionControlRevertFiles &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_bRecursive(std::move(_Right.m_bRecursive))
		, m_bReplaceLocally(std::move(_Right.m_bReplaceLocally))
		, m_bForceRevert(std::move(_Right.m_bForceRevert))
	{
	}
	HPMVersionControlRevertFiles &operator =(HPMVersionControlRevertFiles const &_Right)
	{
		m_Files = _Right.m_Files;
		m_bRecursive = _Right.m_bRecursive;
		m_bReplaceLocally = _Right.m_bReplaceLocally;
		m_bForceRevert = _Right.m_bForceRevert;
		return *this;
	}
	HPMVersionControlRevertFiles &operator =(HPMVersionControlRevertFiles &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_bRecursive = std::move(_Right.m_bRecursive);
		m_bReplaceLocally = std::move(_Right.m_bReplaceLocally);
		m_bForceRevert = std::move(_Right.m_bForceRevert);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlRevertFiles &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_bRecursive != _Right.m_bRecursive)
			return false;
		if (m_bReplaceLocally != _Right.m_bReplaceLocally)
			return false;
		if (m_bForceRevert != _Right.m_bForceRevert)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlRevertFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlRevertFiles &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_bRecursive < _Right.m_bRecursive)
			return true;
		if (m_bRecursive > _Right.m_bRecursive)
			return false;
		if (m_bReplaceLocally < _Right.m_bReplaceLocally)
			return true;
		if (m_bReplaceLocally > _Right.m_bReplaceLocally)
			return false;
		if (m_bForceRevert < _Right.m_bForceRevert)
			return true;
		if (m_bForceRevert > _Right.m_bForceRevert)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlRevertFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlRevertFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlRevertFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlDeleteFiles
{
	public:
	std::vector<HPMVersionControlFileSpec> m_Files;
	HPMString m_Comment;
	bool m_bPermanent;
	bool m_bDeleteLocally;
	HPMVersionControlDeleteFiles()
		: m_bPermanent(0)
		, m_bDeleteLocally(1)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlDeleteFiles(HPMVersionControlDeleteFiles const &_Right)
		: m_Files(_Right.m_Files)
		, m_Comment(_Right.m_Comment)
		, m_bPermanent(_Right.m_bPermanent)
		, m_bDeleteLocally(_Right.m_bDeleteLocally)
	{
	}
	HPMVersionControlDeleteFiles(HPMVersionControlDeleteFiles &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_Comment(std::move(_Right.m_Comment))
		, m_bPermanent(std::move(_Right.m_bPermanent))
		, m_bDeleteLocally(std::move(_Right.m_bDeleteLocally))
	{
	}
	HPMVersionControlDeleteFiles &operator =(HPMVersionControlDeleteFiles const &_Right)
	{
		m_Files = _Right.m_Files;
		m_Comment = _Right.m_Comment;
		m_bPermanent = _Right.m_bPermanent;
		m_bDeleteLocally = _Right.m_bDeleteLocally;
		return *this;
	}
	HPMVersionControlDeleteFiles &operator =(HPMVersionControlDeleteFiles &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_Comment = std::move(_Right.m_Comment);
		m_bPermanent = std::move(_Right.m_bPermanent);
		m_bDeleteLocally = std::move(_Right.m_bDeleteLocally);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlDeleteFiles &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_bPermanent != _Right.m_bPermanent)
			return false;
		if (m_bDeleteLocally != _Right.m_bDeleteLocally)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlDeleteFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlDeleteFiles &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_bPermanent < _Right.m_bPermanent)
			return true;
		if (m_bPermanent > _Right.m_bPermanent)
			return false;
		if (m_bDeleteLocally < _Right.m_bDeleteLocally)
			return true;
		if (m_bDeleteLocally > _Right.m_bDeleteLocally)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlDeleteFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlDeleteFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlDeleteFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlRestoreDeletedFiles
{
	public:
	std::vector<HPMVersionControlFileSpec> m_Files;
	HPMString m_Comment;
	HPMVersionControlRestoreDeletedFiles()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlRestoreDeletedFiles(HPMVersionControlRestoreDeletedFiles const &_Right)
		: m_Files(_Right.m_Files)
		, m_Comment(_Right.m_Comment)
	{
	}
	HPMVersionControlRestoreDeletedFiles(HPMVersionControlRestoreDeletedFiles &&_Right)
		: m_Files(std::move(_Right.m_Files))
		, m_Comment(std::move(_Right.m_Comment))
	{
	}
	HPMVersionControlRestoreDeletedFiles &operator =(HPMVersionControlRestoreDeletedFiles const &_Right)
	{
		m_Files = _Right.m_Files;
		m_Comment = _Right.m_Comment;
		return *this;
	}
	HPMVersionControlRestoreDeletedFiles &operator =(HPMVersionControlRestoreDeletedFiles &&_Right)
	{
		m_Files = std::move(_Right.m_Files);
		m_Comment = std::move(_Right.m_Comment);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		if (m_Files.size() != _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
			if (m_Files[i] != _Right.m_Files[i])
				return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		if (m_Files.size() < _Right.m_Files.size())
			return true;
		if (m_Files.size() > _Right.m_Files.size())
			return false;
		for (size_t i = 0; i < m_Files.size(); ++i)
		{
			if (m_Files[i] < _Right.m_Files[i])
				return true;
			if (m_Files[i] > _Right.m_Files[i])
				return false;
		}
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlRestoreDeletedFiles &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlDeleteVersions
{
	public:
	HPMString m_Path;
	std::vector<HPMUInt64> m_VersionsToDelete;
	HPMVersionControlDeleteVersions()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlDeleteVersions(HPMVersionControlDeleteVersions const &_Right)
		: m_Path(_Right.m_Path)
		, m_VersionsToDelete(_Right.m_VersionsToDelete)
	{
	}
	HPMVersionControlDeleteVersions(HPMVersionControlDeleteVersions &&_Right)
		: m_Path(std::move(_Right.m_Path))
		, m_VersionsToDelete(std::move(_Right.m_VersionsToDelete))
	{
	}
	HPMVersionControlDeleteVersions &operator =(HPMVersionControlDeleteVersions const &_Right)
	{
		m_Path = _Right.m_Path;
		m_VersionsToDelete = _Right.m_VersionsToDelete;
		return *this;
	}
	HPMVersionControlDeleteVersions &operator =(HPMVersionControlDeleteVersions &&_Right)
	{
		m_Path = std::move(_Right.m_Path);
		m_VersionsToDelete = std::move(_Right.m_VersionsToDelete);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlDeleteVersions &_Right) const
	{
		if (m_Path != _Right.m_Path)
			return false;
		if (m_VersionsToDelete.size() != _Right.m_VersionsToDelete.size())
			return false;
		for (size_t i = 0; i < m_VersionsToDelete.size(); ++i)
			if (m_VersionsToDelete[i] != _Right.m_VersionsToDelete[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlDeleteVersions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlDeleteVersions &_Right) const
	{
		if (m_Path < _Right.m_Path)
			return true;
		if (m_Path > _Right.m_Path)
			return false;
		if (m_VersionsToDelete.size() < _Right.m_VersionsToDelete.size())
			return true;
		if (m_VersionsToDelete.size() > _Right.m_VersionsToDelete.size())
			return false;
		for (size_t i = 0; i < m_VersionsToDelete.size(); ++i)
		{
			if (m_VersionsToDelete[i] < _Right.m_VersionsToDelete[i])
				return true;
			if (m_VersionsToDelete[i] > _Right.m_VersionsToDelete[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlDeleteVersions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlDeleteVersions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlDeleteVersions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlRollbackFile
{
	public:
	HPMString m_Path;
	HPMString m_Comment;
	HPMUInt64 m_FromVersion;
	HPMVersionControlRollbackFile()
		: m_FromVersion(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlRollbackFile(HPMVersionControlRollbackFile const &_Right)
		: m_Path(_Right.m_Path)
		, m_Comment(_Right.m_Comment)
		, m_FromVersion(_Right.m_FromVersion)
	{
	}
	HPMVersionControlRollbackFile(HPMVersionControlRollbackFile &&_Right)
		: m_Path(std::move(_Right.m_Path))
		, m_Comment(std::move(_Right.m_Comment))
		, m_FromVersion(std::move(_Right.m_FromVersion))
	{
	}
	HPMVersionControlRollbackFile &operator =(HPMVersionControlRollbackFile const &_Right)
	{
		m_Path = _Right.m_Path;
		m_Comment = _Right.m_Comment;
		m_FromVersion = _Right.m_FromVersion;
		return *this;
	}
	HPMVersionControlRollbackFile &operator =(HPMVersionControlRollbackFile &&_Right)
	{
		m_Path = std::move(_Right.m_Path);
		m_Comment = std::move(_Right.m_Comment);
		m_FromVersion = std::move(_Right.m_FromVersion);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlRollbackFile &_Right) const
	{
		if (m_Path != _Right.m_Path)
			return false;
		if (m_Comment != _Right.m_Comment)
			return false;
		if (m_FromVersion != _Right.m_FromVersion)
			return false;
		return true;
	}
	bool operator != (const HPMVersionControlRollbackFile &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlRollbackFile &_Right) const
	{
		if (m_Path < _Right.m_Path)
			return true;
		if (m_Path > _Right.m_Path)
			return false;
		if (m_Comment < _Right.m_Comment)
			return true;
		if (m_Comment > _Right.m_Comment)
			return false;
		if (m_FromVersion < _Right.m_FromVersion)
			return true;
		if (m_FromVersion > _Right.m_FromVersion)
			return false;
		return false;
	}
	bool operator > (const HPMVersionControlRollbackFile &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlRollbackFile &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlRollbackFile &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMVersionControlCallbackInfo
{
	public:
	EHPMVersionControlCallbackOperation m_Operation;
	EHPMVersionControlFileAttributesFlag m_FileAttributes;
	HPMUInt64 m_Date;
	HPMString m_FileName;
	HPMString m_Resource;
	HPMString m_ResourceComment;
	HPMString m_LocalTemporaryFileName;
	std::vector<HPMVersionControlMetaDataEntry> m_MetaDataEntries;
	HPMVersionControlCallbackInfo()
		: m_Operation(EHPMVersionControlCallbackOperation_None)
		, m_FileAttributes(EHPMVersionControlFileAttributesFlag_None)
		, m_Date(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMVersionControlCallbackInfo(HPMVersionControlCallbackInfo const &_Right)
		: m_Operation(_Right.m_Operation)
		, m_FileAttributes(_Right.m_FileAttributes)
		, m_Date(_Right.m_Date)
		, m_FileName(_Right.m_FileName)
		, m_Resource(_Right.m_Resource)
		, m_ResourceComment(_Right.m_ResourceComment)
		, m_LocalTemporaryFileName(_Right.m_LocalTemporaryFileName)
		, m_MetaDataEntries(_Right.m_MetaDataEntries)
	{
	}
	HPMVersionControlCallbackInfo(HPMVersionControlCallbackInfo &&_Right)
		: m_Operation(std::move(_Right.m_Operation))
		, m_FileAttributes(std::move(_Right.m_FileAttributes))
		, m_Date(std::move(_Right.m_Date))
		, m_FileName(std::move(_Right.m_FileName))
		, m_Resource(std::move(_Right.m_Resource))
		, m_ResourceComment(std::move(_Right.m_ResourceComment))
		, m_LocalTemporaryFileName(std::move(_Right.m_LocalTemporaryFileName))
		, m_MetaDataEntries(std::move(_Right.m_MetaDataEntries))
	{
	}
	HPMVersionControlCallbackInfo &operator =(HPMVersionControlCallbackInfo const &_Right)
	{
		m_Operation = _Right.m_Operation;
		m_FileAttributes = _Right.m_FileAttributes;
		m_Date = _Right.m_Date;
		m_FileName = _Right.m_FileName;
		m_Resource = _Right.m_Resource;
		m_ResourceComment = _Right.m_ResourceComment;
		m_LocalTemporaryFileName = _Right.m_LocalTemporaryFileName;
		m_MetaDataEntries = _Right.m_MetaDataEntries;
		return *this;
	}
	HPMVersionControlCallbackInfo &operator =(HPMVersionControlCallbackInfo &&_Right)
	{
		m_Operation = std::move(_Right.m_Operation);
		m_FileAttributes = std::move(_Right.m_FileAttributes);
		m_Date = std::move(_Right.m_Date);
		m_FileName = std::move(_Right.m_FileName);
		m_Resource = std::move(_Right.m_Resource);
		m_ResourceComment = std::move(_Right.m_ResourceComment);
		m_LocalTemporaryFileName = std::move(_Right.m_LocalTemporaryFileName);
		m_MetaDataEntries = std::move(_Right.m_MetaDataEntries);
		return *this;
	}
#endif
	bool operator == (const HPMVersionControlCallbackInfo &_Right) const
	{
		if (m_Operation != _Right.m_Operation)
			return false;
		if (m_FileAttributes != _Right.m_FileAttributes)
			return false;
		if (m_Date != _Right.m_Date)
			return false;
		if (m_FileName != _Right.m_FileName)
			return false;
		if (m_Resource != _Right.m_Resource)
			return false;
		if (m_ResourceComment != _Right.m_ResourceComment)
			return false;
		if (m_LocalTemporaryFileName != _Right.m_LocalTemporaryFileName)
			return false;
		if (m_MetaDataEntries.size() != _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
			if (m_MetaDataEntries[i] != _Right.m_MetaDataEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMVersionControlCallbackInfo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMVersionControlCallbackInfo &_Right) const
	{
		if (m_Operation < _Right.m_Operation)
			return true;
		if (m_Operation > _Right.m_Operation)
			return false;
		if (m_FileAttributes < _Right.m_FileAttributes)
			return true;
		if (m_FileAttributes > _Right.m_FileAttributes)
			return false;
		if (m_Date < _Right.m_Date)
			return true;
		if (m_Date > _Right.m_Date)
			return false;
		if (m_FileName < _Right.m_FileName)
			return true;
		if (m_FileName > _Right.m_FileName)
			return false;
		if (m_Resource < _Right.m_Resource)
			return true;
		if (m_Resource > _Right.m_Resource)
			return false;
		if (m_ResourceComment < _Right.m_ResourceComment)
			return true;
		if (m_ResourceComment > _Right.m_ResourceComment)
			return false;
		if (m_LocalTemporaryFileName < _Right.m_LocalTemporaryFileName)
			return true;
		if (m_LocalTemporaryFileName > _Right.m_LocalTemporaryFileName)
			return false;
		if (m_MetaDataEntries.size() < _Right.m_MetaDataEntries.size())
			return true;
		if (m_MetaDataEntries.size() > _Right.m_MetaDataEntries.size())
			return false;
		for (size_t i = 0; i < m_MetaDataEntries.size(); ++i)
		{
			if (m_MetaDataEntries[i] < _Right.m_MetaDataEntries[i])
				return true;
			if (m_MetaDataEntries[i] > _Right.m_MetaDataEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMVersionControlCallbackInfo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMVersionControlCallbackInfo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMVersionControlCallbackInfo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryEntryFilter
{
	public:
	EHPMDataHistoryEntryFilterFlag m_Flags;
	EHPMDataHistoryEntryType m_EntryType;
	EHPMDataHistoryEntryKind m_EntryKind;
	HPMInt32 m_FieldID;
	HPMUInt32 m_FieldData;
	HPMDataHistoryEntryFilter()
		: m_Flags(EHPMDataHistoryEntryFilterFlag_None)
		, m_EntryType(EHPMDataHistoryEntryType_FieldCreated)
		, m_EntryKind(EHPMDataHistoryEntryKind_Default)
		, m_FieldID(0)
		, m_FieldData(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryEntryFilter(HPMDataHistoryEntryFilter const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_EntryType(_Right.m_EntryType)
		, m_EntryKind(_Right.m_EntryKind)
		, m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
	{
	}
	HPMDataHistoryEntryFilter(HPMDataHistoryEntryFilter &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_EntryType(std::move(_Right.m_EntryType))
		, m_EntryKind(std::move(_Right.m_EntryKind))
		, m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
	{
	}
	HPMDataHistoryEntryFilter &operator =(HPMDataHistoryEntryFilter const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_EntryType = _Right.m_EntryType;
		m_EntryKind = _Right.m_EntryKind;
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		return *this;
	}
	HPMDataHistoryEntryFilter &operator =(HPMDataHistoryEntryFilter &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_EntryType = std::move(_Right.m_EntryType);
		m_EntryKind = std::move(_Right.m_EntryKind);
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryEntryFilter &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_EntryType != _Right.m_EntryType)
			return false;
		if (m_EntryKind != _Right.m_EntryKind)
			return false;
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryEntryFilter &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryEntryFilter &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_EntryType < _Right.m_EntryType)
			return true;
		if (m_EntryType > _Right.m_EntryType)
			return false;
		if (m_EntryKind < _Right.m_EntryKind)
			return true;
		if (m_EntryKind > _Right.m_EntryKind)
			return false;
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryEntryFilter &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryEntryFilter &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryEntryFilter &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryFilter
{
	public:
	EHPMDataHistoryFilterOperatorFlag m_Flags;
	HPMDataHistoryEntryFilter m_EntryFilter;
	std::vector<HPMDataHistoryFilter> m_Filters;
	HPMDataHistoryFilter()
		: m_Flags(EHPMDataHistoryFilterOperatorFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryFilter(HPMDataHistoryFilter const &_Right)
		: m_Flags(_Right.m_Flags)
		, m_EntryFilter(_Right.m_EntryFilter)
		, m_Filters(_Right.m_Filters)
	{
	}
	HPMDataHistoryFilter(HPMDataHistoryFilter &&_Right)
		: m_Flags(std::move(_Right.m_Flags))
		, m_EntryFilter(std::move(_Right.m_EntryFilter))
		, m_Filters(std::move(_Right.m_Filters))
	{
	}
	HPMDataHistoryFilter &operator =(HPMDataHistoryFilter const &_Right)
	{
		m_Flags = _Right.m_Flags;
		m_EntryFilter = _Right.m_EntryFilter;
		m_Filters = _Right.m_Filters;
		return *this;
	}
	HPMDataHistoryFilter &operator =(HPMDataHistoryFilter &&_Right)
	{
		m_Flags = std::move(_Right.m_Flags);
		m_EntryFilter = std::move(_Right.m_EntryFilter);
		m_Filters = std::move(_Right.m_Filters);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryFilter &_Right) const
	{
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_EntryFilter != _Right.m_EntryFilter)
			return false;
		if (m_Filters.size() != _Right.m_Filters.size())
			return false;
		for (size_t i = 0; i < m_Filters.size(); ++i)
			if (m_Filters[i] != _Right.m_Filters[i])
				return false;
		return true;
	}
	bool operator != (const HPMDataHistoryFilter &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryFilter &_Right) const
	{
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_EntryFilter < _Right.m_EntryFilter)
			return true;
		if (m_EntryFilter > _Right.m_EntryFilter)
			return false;
		if (m_Filters.size() < _Right.m_Filters.size())
			return true;
		if (m_Filters.size() > _Right.m_Filters.size())
			return false;
		for (size_t i = 0; i < m_Filters.size(); ++i)
		{
			if (m_Filters[i] < _Right.m_Filters[i])
				return true;
			if (m_Filters[i] > _Right.m_Filters[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMDataHistoryFilter &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryFilter &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryFilter &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTimePosition
{
	public:
	HPMUInt64 m_Time;
	HPMInt64 m_Position;
	HPMDataHistoryTimePosition()
		: m_Time(0)
		, m_Position(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTimePosition(HPMDataHistoryTimePosition const &_Right)
		: m_Time(_Right.m_Time)
		, m_Position(_Right.m_Position)
	{
	}
	HPMDataHistoryTimePosition(HPMDataHistoryTimePosition &&_Right)
		: m_Time(std::move(_Right.m_Time))
		, m_Position(std::move(_Right.m_Position))
	{
	}
	HPMDataHistoryTimePosition &operator =(HPMDataHistoryTimePosition const &_Right)
	{
		m_Time = _Right.m_Time;
		m_Position = _Right.m_Position;
		return *this;
	}
	HPMDataHistoryTimePosition &operator =(HPMDataHistoryTimePosition &&_Right)
	{
		m_Time = std::move(_Right.m_Time);
		m_Position = std::move(_Right.m_Position);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTimePosition &_Right) const
	{
		if (m_Time != _Right.m_Time)
			return false;
		if (m_Position != _Right.m_Position)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTimePosition &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTimePosition &_Right) const
	{
		if (m_Time < _Right.m_Time)
			return true;
		if (m_Time > _Right.m_Time)
			return false;
		if (m_Position < _Right.m_Position)
			return true;
		if (m_Position > _Right.m_Position)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTimePosition &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTimePosition &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTimePosition &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryGetHistoryParameters
{
	public:
	HPMUniqueID m_DataID;
	EHPMStatisticsField m_FieldID;
	HPMUInt32 m_FieldData;
	EHPMStatisticsScope m_DataIdent0;
	HPMUInt32 m_DataIdent1;
	EHPMDataHistoryFlag m_Flags;
	HPMUInt32 m_MaxEntries;
	HPMDataHistoryTimePosition m_Start;
	HPMDataHistoryTimePosition m_End;
	HPMDataHistoryFilter m_Filter;
	HPMDataHistoryGetHistoryParameters()
		: m_FieldID(EHPMStatisticsField_NoStatistics)
		, m_FieldData(0)
		, m_DataIdent0(EHPMStatisticsScope_NoStatisticsScope)
		, m_DataIdent1(0)
		, m_Flags(EHPMDataHistoryFlag_None)
		, m_MaxEntries(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryGetHistoryParameters(HPMDataHistoryGetHistoryParameters const &_Right)
		: m_DataID(_Right.m_DataID)
		, m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
		, m_DataIdent0(_Right.m_DataIdent0)
		, m_DataIdent1(_Right.m_DataIdent1)
		, m_Flags(_Right.m_Flags)
		, m_MaxEntries(_Right.m_MaxEntries)
		, m_Start(_Right.m_Start)
		, m_End(_Right.m_End)
		, m_Filter(_Right.m_Filter)
	{
	}
	HPMDataHistoryGetHistoryParameters(HPMDataHistoryGetHistoryParameters &&_Right)
		: m_DataID(std::move(_Right.m_DataID))
		, m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
		, m_DataIdent0(std::move(_Right.m_DataIdent0))
		, m_DataIdent1(std::move(_Right.m_DataIdent1))
		, m_Flags(std::move(_Right.m_Flags))
		, m_MaxEntries(std::move(_Right.m_MaxEntries))
		, m_Start(std::move(_Right.m_Start))
		, m_End(std::move(_Right.m_End))
		, m_Filter(std::move(_Right.m_Filter))
	{
	}
	HPMDataHistoryGetHistoryParameters &operator =(HPMDataHistoryGetHistoryParameters const &_Right)
	{
		m_DataID = _Right.m_DataID;
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		m_DataIdent0 = _Right.m_DataIdent0;
		m_DataIdent1 = _Right.m_DataIdent1;
		m_Flags = _Right.m_Flags;
		m_MaxEntries = _Right.m_MaxEntries;
		m_Start = _Right.m_Start;
		m_End = _Right.m_End;
		m_Filter = _Right.m_Filter;
		return *this;
	}
	HPMDataHistoryGetHistoryParameters &operator =(HPMDataHistoryGetHistoryParameters &&_Right)
	{
		m_DataID = std::move(_Right.m_DataID);
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		m_DataIdent0 = std::move(_Right.m_DataIdent0);
		m_DataIdent1 = std::move(_Right.m_DataIdent1);
		m_Flags = std::move(_Right.m_Flags);
		m_MaxEntries = std::move(_Right.m_MaxEntries);
		m_Start = std::move(_Right.m_Start);
		m_End = std::move(_Right.m_End);
		m_Filter = std::move(_Right.m_Filter);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		if (m_DataID != _Right.m_DataID)
			return false;
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		if (m_DataIdent0 != _Right.m_DataIdent0)
			return false;
		if (m_DataIdent1 != _Right.m_DataIdent1)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		if (m_MaxEntries != _Right.m_MaxEntries)
			return false;
		if (m_Start != _Right.m_Start)
			return false;
		if (m_End != _Right.m_End)
			return false;
		if (m_Filter != _Right.m_Filter)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		if (m_DataID < _Right.m_DataID)
			return true;
		if (m_DataID > _Right.m_DataID)
			return false;
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		if (m_DataIdent0 < _Right.m_DataIdent0)
			return true;
		if (m_DataIdent0 > _Right.m_DataIdent0)
			return false;
		if (m_DataIdent1 < _Right.m_DataIdent1)
			return true;
		if (m_DataIdent1 > _Right.m_DataIdent1)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		if (m_MaxEntries < _Right.m_MaxEntries)
			return true;
		if (m_MaxEntries > _Right.m_MaxEntries)
			return false;
		if (m_Start < _Right.m_Start)
			return true;
		if (m_Start > _Right.m_Start)
			return false;
		if (m_End < _Right.m_End)
			return true;
		if (m_End > _Right.m_End)
			return false;
		if (m_Filter < _Right.m_Filter)
			return true;
		if (m_Filter > _Right.m_Filter)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryGetHistoryParameters &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryEntry
{
	public:
	HPMUInt64 m_Time;
	HPMUniqueID m_ResourceID;
	HPMString m_Resource;
	HPMUniqueID m_ObjectID;
	HPMUniqueID m_NonImpersonatedResourceID;
	HPMString m_NonImpersonatedResource;
	EHPMDataHistoryEntryType m_EntryType;
	EHPMDataHistoryEntryKind m_EntryKind;
	HPMInt32 m_FieldID;
	HPMUInt32 m_FieldData;
	EHPMDataHistoryOrigin m_Origin;
	EHPMDataHistoryClientOrigin m_ClientOrigin;
	HPMUntranslatedString m_ClientCustomOrigin;
	bool m_bHasDataRecorded;
	HPMDataHistoryEntry()
		: m_Time(0)
		, m_EntryType(EHPMDataHistoryEntryType_FieldCreated)
		, m_EntryKind(EHPMDataHistoryEntryKind_Default)
		, m_FieldID(0)
		, m_FieldData(0)
		, m_Origin(EHPMDataHistoryOrigin_None)
		, m_ClientOrigin(EHPMDataHistoryClientOrigin_None)
		, m_bHasDataRecorded(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryEntry(HPMDataHistoryEntry const &_Right)
		: m_Time(_Right.m_Time)
		, m_ResourceID(_Right.m_ResourceID)
		, m_Resource(_Right.m_Resource)
		, m_ObjectID(_Right.m_ObjectID)
		, m_NonImpersonatedResourceID(_Right.m_NonImpersonatedResourceID)
		, m_NonImpersonatedResource(_Right.m_NonImpersonatedResource)
		, m_EntryType(_Right.m_EntryType)
		, m_EntryKind(_Right.m_EntryKind)
		, m_FieldID(_Right.m_FieldID)
		, m_FieldData(_Right.m_FieldData)
		, m_Origin(_Right.m_Origin)
		, m_ClientOrigin(_Right.m_ClientOrigin)
		, m_ClientCustomOrigin(_Right.m_ClientCustomOrigin)
		, m_bHasDataRecorded(_Right.m_bHasDataRecorded)
	{
	}
	HPMDataHistoryEntry(HPMDataHistoryEntry &&_Right)
		: m_Time(std::move(_Right.m_Time))
		, m_ResourceID(std::move(_Right.m_ResourceID))
		, m_Resource(std::move(_Right.m_Resource))
		, m_ObjectID(std::move(_Right.m_ObjectID))
		, m_NonImpersonatedResourceID(std::move(_Right.m_NonImpersonatedResourceID))
		, m_NonImpersonatedResource(std::move(_Right.m_NonImpersonatedResource))
		, m_EntryType(std::move(_Right.m_EntryType))
		, m_EntryKind(std::move(_Right.m_EntryKind))
		, m_FieldID(std::move(_Right.m_FieldID))
		, m_FieldData(std::move(_Right.m_FieldData))
		, m_Origin(std::move(_Right.m_Origin))
		, m_ClientOrigin(std::move(_Right.m_ClientOrigin))
		, m_ClientCustomOrigin(std::move(_Right.m_ClientCustomOrigin))
		, m_bHasDataRecorded(std::move(_Right.m_bHasDataRecorded))
	{
	}
	HPMDataHistoryEntry &operator =(HPMDataHistoryEntry const &_Right)
	{
		m_Time = _Right.m_Time;
		m_ResourceID = _Right.m_ResourceID;
		m_Resource = _Right.m_Resource;
		m_ObjectID = _Right.m_ObjectID;
		m_NonImpersonatedResourceID = _Right.m_NonImpersonatedResourceID;
		m_NonImpersonatedResource = _Right.m_NonImpersonatedResource;
		m_EntryType = _Right.m_EntryType;
		m_EntryKind = _Right.m_EntryKind;
		m_FieldID = _Right.m_FieldID;
		m_FieldData = _Right.m_FieldData;
		m_Origin = _Right.m_Origin;
		m_ClientOrigin = _Right.m_ClientOrigin;
		m_ClientCustomOrigin = _Right.m_ClientCustomOrigin;
		m_bHasDataRecorded = _Right.m_bHasDataRecorded;
		return *this;
	}
	HPMDataHistoryEntry &operator =(HPMDataHistoryEntry &&_Right)
	{
		m_Time = std::move(_Right.m_Time);
		m_ResourceID = std::move(_Right.m_ResourceID);
		m_Resource = std::move(_Right.m_Resource);
		m_ObjectID = std::move(_Right.m_ObjectID);
		m_NonImpersonatedResourceID = std::move(_Right.m_NonImpersonatedResourceID);
		m_NonImpersonatedResource = std::move(_Right.m_NonImpersonatedResource);
		m_EntryType = std::move(_Right.m_EntryType);
		m_EntryKind = std::move(_Right.m_EntryKind);
		m_FieldID = std::move(_Right.m_FieldID);
		m_FieldData = std::move(_Right.m_FieldData);
		m_Origin = std::move(_Right.m_Origin);
		m_ClientOrigin = std::move(_Right.m_ClientOrigin);
		m_ClientCustomOrigin = std::move(_Right.m_ClientCustomOrigin);
		m_bHasDataRecorded = std::move(_Right.m_bHasDataRecorded);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryEntry &_Right) const
	{
		if (m_Time != _Right.m_Time)
			return false;
		if (m_ResourceID != _Right.m_ResourceID)
			return false;
		if (m_Resource != _Right.m_Resource)
			return false;
		if (m_ObjectID != _Right.m_ObjectID)
			return false;
		if (m_NonImpersonatedResourceID != _Right.m_NonImpersonatedResourceID)
			return false;
		if (m_NonImpersonatedResource != _Right.m_NonImpersonatedResource)
			return false;
		if (m_EntryType != _Right.m_EntryType)
			return false;
		if (m_EntryKind != _Right.m_EntryKind)
			return false;
		if (m_FieldID != _Right.m_FieldID)
			return false;
		if (m_FieldData != _Right.m_FieldData)
			return false;
		if (m_Origin != _Right.m_Origin)
			return false;
		if (m_ClientOrigin != _Right.m_ClientOrigin)
			return false;
		if (m_ClientCustomOrigin != _Right.m_ClientCustomOrigin)
			return false;
		if (m_bHasDataRecorded != _Right.m_bHasDataRecorded)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryEntry &_Right) const
	{
		if (m_Time < _Right.m_Time)
			return true;
		if (m_Time > _Right.m_Time)
			return false;
		if (m_ResourceID < _Right.m_ResourceID)
			return true;
		if (m_ResourceID > _Right.m_ResourceID)
			return false;
		if (m_Resource < _Right.m_Resource)
			return true;
		if (m_Resource > _Right.m_Resource)
			return false;
		if (m_ObjectID < _Right.m_ObjectID)
			return true;
		if (m_ObjectID > _Right.m_ObjectID)
			return false;
		if (m_NonImpersonatedResourceID < _Right.m_NonImpersonatedResourceID)
			return true;
		if (m_NonImpersonatedResourceID > _Right.m_NonImpersonatedResourceID)
			return false;
		if (m_NonImpersonatedResource < _Right.m_NonImpersonatedResource)
			return true;
		if (m_NonImpersonatedResource > _Right.m_NonImpersonatedResource)
			return false;
		if (m_EntryType < _Right.m_EntryType)
			return true;
		if (m_EntryType > _Right.m_EntryType)
			return false;
		if (m_EntryKind < _Right.m_EntryKind)
			return true;
		if (m_EntryKind > _Right.m_EntryKind)
			return false;
		if (m_FieldID < _Right.m_FieldID)
			return true;
		if (m_FieldID > _Right.m_FieldID)
			return false;
		if (m_FieldData < _Right.m_FieldData)
			return true;
		if (m_FieldData > _Right.m_FieldData)
			return false;
		if (m_Origin < _Right.m_Origin)
			return true;
		if (m_Origin > _Right.m_Origin)
			return false;
		if (m_ClientOrigin < _Right.m_ClientOrigin)
			return true;
		if (m_ClientOrigin > _Right.m_ClientOrigin)
			return false;
		if (m_ClientCustomOrigin < _Right.m_ClientCustomOrigin)
			return true;
		if (m_ClientCustomOrigin > _Right.m_ClientCustomOrigin)
			return false;
		if (m_bHasDataRecorded < _Right.m_bHasDataRecorded)
			return true;
		if (m_bHasDataRecorded > _Right.m_bHasDataRecorded)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMStatisticsMultiFrequencyEntry
{
	public:
	HPMInt32 m_UniqueID;
	HPMInt32 m_Frequency;
	HPMFP64 m_FrequencyFP;
	HPMStatisticsMultiFrequencyEntry()
		: m_UniqueID(0)
		, m_Frequency(0)
		, m_FrequencyFP(0.0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMStatisticsMultiFrequencyEntry(HPMStatisticsMultiFrequencyEntry const &_Right)
		: m_UniqueID(_Right.m_UniqueID)
		, m_Frequency(_Right.m_Frequency)
		, m_FrequencyFP(_Right.m_FrequencyFP)
	{
	}
	HPMStatisticsMultiFrequencyEntry(HPMStatisticsMultiFrequencyEntry &&_Right)
		: m_UniqueID(std::move(_Right.m_UniqueID))
		, m_Frequency(std::move(_Right.m_Frequency))
		, m_FrequencyFP(std::move(_Right.m_FrequencyFP))
	{
	}
	HPMStatisticsMultiFrequencyEntry &operator =(HPMStatisticsMultiFrequencyEntry const &_Right)
	{
		m_UniqueID = _Right.m_UniqueID;
		m_Frequency = _Right.m_Frequency;
		m_FrequencyFP = _Right.m_FrequencyFP;
		return *this;
	}
	HPMStatisticsMultiFrequencyEntry &operator =(HPMStatisticsMultiFrequencyEntry &&_Right)
	{
		m_UniqueID = std::move(_Right.m_UniqueID);
		m_Frequency = std::move(_Right.m_Frequency);
		m_FrequencyFP = std::move(_Right.m_FrequencyFP);
		return *this;
	}
#endif
	bool operator == (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		if (m_UniqueID != _Right.m_UniqueID)
			return false;
		if (m_Frequency != _Right.m_Frequency)
			return false;
		if (m_FrequencyFP != _Right.m_FrequencyFP)
			return false;
		return true;
	}
	bool operator != (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		if (m_UniqueID < _Right.m_UniqueID)
			return true;
		if (m_UniqueID > _Right.m_UniqueID)
			return false;
		if (m_Frequency < _Right.m_Frequency)
			return true;
		if (m_Frequency > _Right.m_Frequency)
			return false;
		if (m_FrequencyFP < _Right.m_FrequencyFP)
			return true;
		if (m_FrequencyFP > _Right.m_FrequencyFP)
			return false;
		return false;
	}
	bool operator > (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMStatisticsMultiFrequencyEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMStatisticsMultiFrequency
{
	public:
	std::vector<HPMStatisticsMultiFrequencyEntry> m_FrequencyEntries;
	HPMStatisticsMultiFrequency()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMStatisticsMultiFrequency(HPMStatisticsMultiFrequency const &_Right)
		: m_FrequencyEntries(_Right.m_FrequencyEntries)
	{
	}
	HPMStatisticsMultiFrequency(HPMStatisticsMultiFrequency &&_Right)
		: m_FrequencyEntries(std::move(_Right.m_FrequencyEntries))
	{
	}
	HPMStatisticsMultiFrequency &operator =(HPMStatisticsMultiFrequency const &_Right)
	{
		m_FrequencyEntries = _Right.m_FrequencyEntries;
		return *this;
	}
	HPMStatisticsMultiFrequency &operator =(HPMStatisticsMultiFrequency &&_Right)
	{
		m_FrequencyEntries = std::move(_Right.m_FrequencyEntries);
		return *this;
	}
#endif
	bool operator == (const HPMStatisticsMultiFrequency &_Right) const
	{
		if (m_FrequencyEntries.size() != _Right.m_FrequencyEntries.size())
			return false;
		for (size_t i = 0; i < m_FrequencyEntries.size(); ++i)
			if (m_FrequencyEntries[i] != _Right.m_FrequencyEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMStatisticsMultiFrequency &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMStatisticsMultiFrequency &_Right) const
	{
		if (m_FrequencyEntries.size() < _Right.m_FrequencyEntries.size())
			return true;
		if (m_FrequencyEntries.size() > _Right.m_FrequencyEntries.size())
			return false;
		for (size_t i = 0; i < m_FrequencyEntries.size(); ++i)
		{
			if (m_FrequencyEntries[i] < _Right.m_FrequencyEntries[i])
				return true;
			if (m_FrequencyEntries[i] > _Right.m_FrequencyEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMStatisticsMultiFrequency &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMStatisticsMultiFrequency &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMStatisticsMultiFrequency &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskCreated
{
	public:
	HPMUniqueID m_Container;
	HPMUniqueID m_TaskMainReferenceID;
	HPMUInt32 m_ID;
	HPMDataHistoryTaskCreated()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskCreated(HPMDataHistoryTaskCreated const &_Right)
		: m_Container(_Right.m_Container)
		, m_TaskMainReferenceID(_Right.m_TaskMainReferenceID)
		, m_ID(_Right.m_ID)
	{
	}
	HPMDataHistoryTaskCreated(HPMDataHistoryTaskCreated &&_Right)
		: m_Container(std::move(_Right.m_Container))
		, m_TaskMainReferenceID(std::move(_Right.m_TaskMainReferenceID))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMDataHistoryTaskCreated &operator =(HPMDataHistoryTaskCreated const &_Right)
	{
		m_Container = _Right.m_Container;
		m_TaskMainReferenceID = _Right.m_TaskMainReferenceID;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMDataHistoryTaskCreated &operator =(HPMDataHistoryTaskCreated &&_Right)
	{
		m_Container = std::move(_Right.m_Container);
		m_TaskMainReferenceID = std::move(_Right.m_TaskMainReferenceID);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskCreated &_Right) const
	{
		if (m_Container != _Right.m_Container)
			return false;
		if (m_TaskMainReferenceID != _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskCreated &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskCreated &_Right) const
	{
		if (m_Container < _Right.m_Container)
			return true;
		if (m_Container > _Right.m_Container)
			return false;
		if (m_TaskMainReferenceID < _Right.m_TaskMainReferenceID)
			return true;
		if (m_TaskMainReferenceID > _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskCreated &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskCreated &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskCreated &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskRestoredFromHistory
{
	public:
	HPMUniqueID m_Container;
	HPMUniqueID m_TaskMainReferenceID;
	HPMUInt32 m_ID;
	HPMDataHistoryTaskRestoredFromHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskRestoredFromHistory(HPMDataHistoryTaskRestoredFromHistory const &_Right)
		: m_Container(_Right.m_Container)
		, m_TaskMainReferenceID(_Right.m_TaskMainReferenceID)
		, m_ID(_Right.m_ID)
	{
	}
	HPMDataHistoryTaskRestoredFromHistory(HPMDataHistoryTaskRestoredFromHistory &&_Right)
		: m_Container(std::move(_Right.m_Container))
		, m_TaskMainReferenceID(std::move(_Right.m_TaskMainReferenceID))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMDataHistoryTaskRestoredFromHistory &operator =(HPMDataHistoryTaskRestoredFromHistory const &_Right)
	{
		m_Container = _Right.m_Container;
		m_TaskMainReferenceID = _Right.m_TaskMainReferenceID;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMDataHistoryTaskRestoredFromHistory &operator =(HPMDataHistoryTaskRestoredFromHistory &&_Right)
	{
		m_Container = std::move(_Right.m_Container);
		m_TaskMainReferenceID = std::move(_Right.m_TaskMainReferenceID);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		if (m_Container != _Right.m_Container)
			return false;
		if (m_TaskMainReferenceID != _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		if (m_Container < _Right.m_Container)
			return true;
		if (m_Container > _Right.m_Container)
			return false;
		if (m_TaskMainReferenceID < _Right.m_TaskMainReferenceID)
			return true;
		if (m_TaskMainReferenceID > _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskRestoredFromHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskMoved
{
	public:
	HPMUniqueID m_ContainerFrom;
	HPMUniqueID m_ContainerTo;
	HPMUniqueID m_TaskMainReferenceID;
	HPMUInt32 m_ID;
	HPMDataHistoryTaskMoved()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskMoved(HPMDataHistoryTaskMoved const &_Right)
		: m_ContainerFrom(_Right.m_ContainerFrom)
		, m_ContainerTo(_Right.m_ContainerTo)
		, m_TaskMainReferenceID(_Right.m_TaskMainReferenceID)
		, m_ID(_Right.m_ID)
	{
	}
	HPMDataHistoryTaskMoved(HPMDataHistoryTaskMoved &&_Right)
		: m_ContainerFrom(std::move(_Right.m_ContainerFrom))
		, m_ContainerTo(std::move(_Right.m_ContainerTo))
		, m_TaskMainReferenceID(std::move(_Right.m_TaskMainReferenceID))
		, m_ID(std::move(_Right.m_ID))
	{
	}
	HPMDataHistoryTaskMoved &operator =(HPMDataHistoryTaskMoved const &_Right)
	{
		m_ContainerFrom = _Right.m_ContainerFrom;
		m_ContainerTo = _Right.m_ContainerTo;
		m_TaskMainReferenceID = _Right.m_TaskMainReferenceID;
		m_ID = _Right.m_ID;
		return *this;
	}
	HPMDataHistoryTaskMoved &operator =(HPMDataHistoryTaskMoved &&_Right)
	{
		m_ContainerFrom = std::move(_Right.m_ContainerFrom);
		m_ContainerTo = std::move(_Right.m_ContainerTo);
		m_TaskMainReferenceID = std::move(_Right.m_TaskMainReferenceID);
		m_ID = std::move(_Right.m_ID);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskMoved &_Right) const
	{
		if (m_ContainerFrom != _Right.m_ContainerFrom)
			return false;
		if (m_ContainerTo != _Right.m_ContainerTo)
			return false;
		if (m_TaskMainReferenceID != _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID != _Right.m_ID)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskMoved &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskMoved &_Right) const
	{
		if (m_ContainerFrom < _Right.m_ContainerFrom)
			return true;
		if (m_ContainerFrom > _Right.m_ContainerFrom)
			return false;
		if (m_ContainerTo < _Right.m_ContainerTo)
			return true;
		if (m_ContainerTo > _Right.m_ContainerTo)
			return false;
		if (m_TaskMainReferenceID < _Right.m_TaskMainReferenceID)
			return true;
		if (m_TaskMainReferenceID > _Right.m_TaskMainReferenceID)
			return false;
		if (m_ID < _Right.m_ID)
			return true;
		if (m_ID > _Right.m_ID)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskMoved &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskMoved &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskMoved &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskProxyCreated
{
	public:
	HPMUniqueID m_Container;
	HPMUniqueID m_TaskReferenceID;
	HPMDataHistoryTaskProxyCreated()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskProxyCreated(HPMDataHistoryTaskProxyCreated const &_Right)
		: m_Container(_Right.m_Container)
		, m_TaskReferenceID(_Right.m_TaskReferenceID)
	{
	}
	HPMDataHistoryTaskProxyCreated(HPMDataHistoryTaskProxyCreated &&_Right)
		: m_Container(std::move(_Right.m_Container))
		, m_TaskReferenceID(std::move(_Right.m_TaskReferenceID))
	{
	}
	HPMDataHistoryTaskProxyCreated &operator =(HPMDataHistoryTaskProxyCreated const &_Right)
	{
		m_Container = _Right.m_Container;
		m_TaskReferenceID = _Right.m_TaskReferenceID;
		return *this;
	}
	HPMDataHistoryTaskProxyCreated &operator =(HPMDataHistoryTaskProxyCreated &&_Right)
	{
		m_Container = std::move(_Right.m_Container);
		m_TaskReferenceID = std::move(_Right.m_TaskReferenceID);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		if (m_Container != _Right.m_Container)
			return false;
		if (m_TaskReferenceID != _Right.m_TaskReferenceID)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		if (m_Container < _Right.m_Container)
			return true;
		if (m_Container > _Right.m_Container)
			return false;
		if (m_TaskReferenceID < _Right.m_TaskReferenceID)
			return true;
		if (m_TaskReferenceID > _Right.m_TaskReferenceID)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskProxyCreated &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskProxyDeleted
{
	public:
	HPMUniqueID m_Container;
	HPMUniqueID m_TaskReferenceID;
	HPMDataHistoryTaskProxyDeleted()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskProxyDeleted(HPMDataHistoryTaskProxyDeleted const &_Right)
		: m_Container(_Right.m_Container)
		, m_TaskReferenceID(_Right.m_TaskReferenceID)
	{
	}
	HPMDataHistoryTaskProxyDeleted(HPMDataHistoryTaskProxyDeleted &&_Right)
		: m_Container(std::move(_Right.m_Container))
		, m_TaskReferenceID(std::move(_Right.m_TaskReferenceID))
	{
	}
	HPMDataHistoryTaskProxyDeleted &operator =(HPMDataHistoryTaskProxyDeleted const &_Right)
	{
		m_Container = _Right.m_Container;
		m_TaskReferenceID = _Right.m_TaskReferenceID;
		return *this;
	}
	HPMDataHistoryTaskProxyDeleted &operator =(HPMDataHistoryTaskProxyDeleted &&_Right)
	{
		m_Container = std::move(_Right.m_Container);
		m_TaskReferenceID = std::move(_Right.m_TaskReferenceID);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		if (m_Container != _Right.m_Container)
			return false;
		if (m_TaskReferenceID != _Right.m_TaskReferenceID)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		if (m_Container < _Right.m_Container)
			return true;
		if (m_Container > _Right.m_Container)
			return false;
		if (m_TaskReferenceID < _Right.m_TaskReferenceID)
			return true;
		if (m_TaskReferenceID > _Right.m_TaskReferenceID)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskProxyDeleted &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistoryTaskRenameCustomColumn
{
	public:
	HPMUInt32 m_HashFrom;
	HPMUInt32 m_HashTo;
	HPMDataHistoryTaskRenameCustomColumn()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistoryTaskRenameCustomColumn(HPMDataHistoryTaskRenameCustomColumn const &_Right)
		: m_HashFrom(_Right.m_HashFrom)
		, m_HashTo(_Right.m_HashTo)
	{
	}
	HPMDataHistoryTaskRenameCustomColumn(HPMDataHistoryTaskRenameCustomColumn &&_Right)
		: m_HashFrom(std::move(_Right.m_HashFrom))
		, m_HashTo(std::move(_Right.m_HashTo))
	{
	}
	HPMDataHistoryTaskRenameCustomColumn &operator =(HPMDataHistoryTaskRenameCustomColumn const &_Right)
	{
		m_HashFrom = _Right.m_HashFrom;
		m_HashTo = _Right.m_HashTo;
		return *this;
	}
	HPMDataHistoryTaskRenameCustomColumn &operator =(HPMDataHistoryTaskRenameCustomColumn &&_Right)
	{
		m_HashFrom = std::move(_Right.m_HashFrom);
		m_HashTo = std::move(_Right.m_HashTo);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		if (m_HashFrom != _Right.m_HashFrom)
			return false;
		if (m_HashTo != _Right.m_HashTo)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		if (m_HashFrom < _Right.m_HashFrom)
			return true;
		if (m_HashFrom > _Right.m_HashFrom)
			return false;
		if (m_HashTo < _Right.m_HashTo)
			return true;
		if (m_HashTo > _Right.m_HashTo)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistoryTaskRenameCustomColumn &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMStatisticsCustomStatisticsFrequencyEntry
{
	public:
	std::vector<HPMInt32> m_FieldData;
	HPMInt32 m_Frequency;
	HPMStatisticsCustomStatisticsFrequencyEntry()
		: m_Frequency(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMStatisticsCustomStatisticsFrequencyEntry(HPMStatisticsCustomStatisticsFrequencyEntry const &_Right)
		: m_FieldData(_Right.m_FieldData)
		, m_Frequency(_Right.m_Frequency)
	{
	}
	HPMStatisticsCustomStatisticsFrequencyEntry(HPMStatisticsCustomStatisticsFrequencyEntry &&_Right)
		: m_FieldData(std::move(_Right.m_FieldData))
		, m_Frequency(std::move(_Right.m_Frequency))
	{
	}
	HPMStatisticsCustomStatisticsFrequencyEntry &operator =(HPMStatisticsCustomStatisticsFrequencyEntry const &_Right)
	{
		m_FieldData = _Right.m_FieldData;
		m_Frequency = _Right.m_Frequency;
		return *this;
	}
	HPMStatisticsCustomStatisticsFrequencyEntry &operator =(HPMStatisticsCustomStatisticsFrequencyEntry &&_Right)
	{
		m_FieldData = std::move(_Right.m_FieldData);
		m_Frequency = std::move(_Right.m_Frequency);
		return *this;
	}
#endif
	bool operator == (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		if (m_FieldData.size() != _Right.m_FieldData.size())
			return false;
		for (size_t i = 0; i < m_FieldData.size(); ++i)
			if (m_FieldData[i] != _Right.m_FieldData[i])
				return false;
		if (m_Frequency != _Right.m_Frequency)
			return false;
		return true;
	}
	bool operator != (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		if (m_FieldData.size() < _Right.m_FieldData.size())
			return true;
		if (m_FieldData.size() > _Right.m_FieldData.size())
			return false;
		for (size_t i = 0; i < m_FieldData.size(); ++i)
		{
			if (m_FieldData[i] < _Right.m_FieldData[i])
				return true;
			if (m_FieldData[i] > _Right.m_FieldData[i])
				return false;
		}
		if (m_Frequency < _Right.m_Frequency)
			return true;
		if (m_Frequency > _Right.m_Frequency)
			return false;
		return false;
	}
	bool operator > (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMStatisticsCustomStatisticsFrequencyEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMStatisticsCustomStatisticsFrequency
{
	public:
	std::vector<HPMCustomStatisticsField> m_Fields;
	std::vector<HPMStatisticsCustomStatisticsFrequencyEntry> m_FrequencyEntries;
	HPMStatisticsCustomStatisticsFrequency()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMStatisticsCustomStatisticsFrequency(HPMStatisticsCustomStatisticsFrequency const &_Right)
		: m_Fields(_Right.m_Fields)
		, m_FrequencyEntries(_Right.m_FrequencyEntries)
	{
	}
	HPMStatisticsCustomStatisticsFrequency(HPMStatisticsCustomStatisticsFrequency &&_Right)
		: m_Fields(std::move(_Right.m_Fields))
		, m_FrequencyEntries(std::move(_Right.m_FrequencyEntries))
	{
	}
	HPMStatisticsCustomStatisticsFrequency &operator =(HPMStatisticsCustomStatisticsFrequency const &_Right)
	{
		m_Fields = _Right.m_Fields;
		m_FrequencyEntries = _Right.m_FrequencyEntries;
		return *this;
	}
	HPMStatisticsCustomStatisticsFrequency &operator =(HPMStatisticsCustomStatisticsFrequency &&_Right)
	{
		m_Fields = std::move(_Right.m_Fields);
		m_FrequencyEntries = std::move(_Right.m_FrequencyEntries);
		return *this;
	}
#endif
	bool operator == (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		if (m_Fields.size() != _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
			if (m_Fields[i] != _Right.m_Fields[i])
				return false;
		if (m_FrequencyEntries.size() != _Right.m_FrequencyEntries.size())
			return false;
		for (size_t i = 0; i < m_FrequencyEntries.size(); ++i)
			if (m_FrequencyEntries[i] != _Right.m_FrequencyEntries[i])
				return false;
		return true;
	}
	bool operator != (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		if (m_Fields.size() < _Right.m_Fields.size())
			return true;
		if (m_Fields.size() > _Right.m_Fields.size())
			return false;
		for (size_t i = 0; i < m_Fields.size(); ++i)
		{
			if (m_Fields[i] < _Right.m_Fields[i])
				return true;
			if (m_Fields[i] > _Right.m_Fields[i])
				return false;
		}
		if (m_FrequencyEntries.size() < _Right.m_FrequencyEntries.size())
			return true;
		if (m_FrequencyEntries.size() > _Right.m_FrequencyEntries.size())
			return false;
		for (size_t i = 0; i < m_FrequencyEntries.size(); ++i)
		{
			if (m_FrequencyEntries[i] < _Right.m_FrequencyEntries[i])
				return true;
			if (m_FrequencyEntries[i] > _Right.m_FrequencyEntries[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMStatisticsCustomStatisticsFrequency &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomChoiceValue
{
	public:
	EHPMCustomChoiceValueType m_ValueType;
	HPMUniqueID m_UniqueID;
	HPMUniqueID m_UniqueID2;
	HPMUInt32 m_IntValue;
	HPMCustomChoiceValue()
		: m_ValueType(EHPMCustomChoiceValueType_Unknown)
		, m_IntValue(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomChoiceValue(HPMCustomChoiceValue const &_Right)
		: m_ValueType(_Right.m_ValueType)
		, m_UniqueID(_Right.m_UniqueID)
		, m_UniqueID2(_Right.m_UniqueID2)
		, m_IntValue(_Right.m_IntValue)
	{
	}
	HPMCustomChoiceValue(HPMCustomChoiceValue &&_Right)
		: m_ValueType(std::move(_Right.m_ValueType))
		, m_UniqueID(std::move(_Right.m_UniqueID))
		, m_UniqueID2(std::move(_Right.m_UniqueID2))
		, m_IntValue(std::move(_Right.m_IntValue))
	{
	}
	HPMCustomChoiceValue &operator =(HPMCustomChoiceValue const &_Right)
	{
		m_ValueType = _Right.m_ValueType;
		m_UniqueID = _Right.m_UniqueID;
		m_UniqueID2 = _Right.m_UniqueID2;
		m_IntValue = _Right.m_IntValue;
		return *this;
	}
	HPMCustomChoiceValue &operator =(HPMCustomChoiceValue &&_Right)
	{
		m_ValueType = std::move(_Right.m_ValueType);
		m_UniqueID = std::move(_Right.m_UniqueID);
		m_UniqueID2 = std::move(_Right.m_UniqueID2);
		m_IntValue = std::move(_Right.m_IntValue);
		return *this;
	}
#endif
	bool operator == (const HPMCustomChoiceValue &_Right) const
	{
		if (m_ValueType != _Right.m_ValueType)
			return false;
		if (m_UniqueID != _Right.m_UniqueID)
			return false;
		if (m_UniqueID2 != _Right.m_UniqueID2)
			return false;
		if (m_IntValue != _Right.m_IntValue)
			return false;
		return true;
	}
	bool operator != (const HPMCustomChoiceValue &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomChoiceValue &_Right) const
	{
		if (m_ValueType < _Right.m_ValueType)
			return true;
		if (m_ValueType > _Right.m_ValueType)
			return false;
		if (m_UniqueID < _Right.m_UniqueID)
			return true;
		if (m_UniqueID > _Right.m_UniqueID)
			return false;
		if (m_UniqueID2 < _Right.m_UniqueID2)
			return true;
		if (m_UniqueID2 > _Right.m_UniqueID2)
			return false;
		if (m_IntValue < _Right.m_IntValue)
			return true;
		if (m_IntValue > _Right.m_IntValue)
			return false;
		return false;
	}
	bool operator > (const HPMCustomChoiceValue &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomChoiceValue &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomChoiceValue &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCommunicationChannelData
{
	public:
	std::vector<HPMUInt8> m_Bytes;
	HPMCommunicationChannelData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCommunicationChannelData(HPMCommunicationChannelData const &_Right)
		: m_Bytes(_Right.m_Bytes)
	{
	}
	HPMCommunicationChannelData(HPMCommunicationChannelData &&_Right)
		: m_Bytes(std::move(_Right.m_Bytes))
	{
	}
	HPMCommunicationChannelData &operator =(HPMCommunicationChannelData const &_Right)
	{
		m_Bytes = _Right.m_Bytes;
		return *this;
	}
	HPMCommunicationChannelData &operator =(HPMCommunicationChannelData &&_Right)
	{
		m_Bytes = std::move(_Right.m_Bytes);
		return *this;
	}
#endif
	bool operator == (const HPMCommunicationChannelData &_Right) const
	{
		if (m_Bytes.size() != _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
			if (m_Bytes[i] != _Right.m_Bytes[i])
				return false;
		return true;
	}
	bool operator != (const HPMCommunicationChannelData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCommunicationChannelData &_Right) const
	{
		if (m_Bytes.size() < _Right.m_Bytes.size())
			return true;
		if (m_Bytes.size() > _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
		{
			if (m_Bytes[i] < _Right.m_Bytes[i])
				return true;
			if (m_Bytes[i] > _Right.m_Bytes[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCommunicationChannelData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCommunicationChannelData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCommunicationChannelData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCommunicationChannelProperties
{
	public:
	HPMString m_ChannelName;
	HPMUInt64 m_OwnerSessionID;
	HPMString m_DatabaseGUID;
	HPMString m_Description;
	HPMCommunicationChannelData m_ChannelData;
	EHPMChannelFlag m_Flags;
	HPMCommunicationChannelProperties()
		: m_OwnerSessionID(0)
		, m_Flags(EHPMChannelFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCommunicationChannelProperties(HPMCommunicationChannelProperties const &_Right)
		: m_ChannelName(_Right.m_ChannelName)
		, m_OwnerSessionID(_Right.m_OwnerSessionID)
		, m_DatabaseGUID(_Right.m_DatabaseGUID)
		, m_Description(_Right.m_Description)
		, m_ChannelData(_Right.m_ChannelData)
		, m_Flags(_Right.m_Flags)
	{
	}
	HPMCommunicationChannelProperties(HPMCommunicationChannelProperties &&_Right)
		: m_ChannelName(std::move(_Right.m_ChannelName))
		, m_OwnerSessionID(std::move(_Right.m_OwnerSessionID))
		, m_DatabaseGUID(std::move(_Right.m_DatabaseGUID))
		, m_Description(std::move(_Right.m_Description))
		, m_ChannelData(std::move(_Right.m_ChannelData))
		, m_Flags(std::move(_Right.m_Flags))
	{
	}
	HPMCommunicationChannelProperties &operator =(HPMCommunicationChannelProperties const &_Right)
	{
		m_ChannelName = _Right.m_ChannelName;
		m_OwnerSessionID = _Right.m_OwnerSessionID;
		m_DatabaseGUID = _Right.m_DatabaseGUID;
		m_Description = _Right.m_Description;
		m_ChannelData = _Right.m_ChannelData;
		m_Flags = _Right.m_Flags;
		return *this;
	}
	HPMCommunicationChannelProperties &operator =(HPMCommunicationChannelProperties &&_Right)
	{
		m_ChannelName = std::move(_Right.m_ChannelName);
		m_OwnerSessionID = std::move(_Right.m_OwnerSessionID);
		m_DatabaseGUID = std::move(_Right.m_DatabaseGUID);
		m_Description = std::move(_Right.m_Description);
		m_ChannelData = std::move(_Right.m_ChannelData);
		m_Flags = std::move(_Right.m_Flags);
		return *this;
	}
#endif
	bool operator == (const HPMCommunicationChannelProperties &_Right) const
	{
		if (m_ChannelName != _Right.m_ChannelName)
			return false;
		if (m_OwnerSessionID != _Right.m_OwnerSessionID)
			return false;
		if (m_DatabaseGUID != _Right.m_DatabaseGUID)
			return false;
		if (m_Description != _Right.m_Description)
			return false;
		if (m_ChannelData != _Right.m_ChannelData)
			return false;
		if (m_Flags != _Right.m_Flags)
			return false;
		return true;
	}
	bool operator != (const HPMCommunicationChannelProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCommunicationChannelProperties &_Right) const
	{
		if (m_ChannelName < _Right.m_ChannelName)
			return true;
		if (m_ChannelName > _Right.m_ChannelName)
			return false;
		if (m_OwnerSessionID < _Right.m_OwnerSessionID)
			return true;
		if (m_OwnerSessionID > _Right.m_OwnerSessionID)
			return false;
		if (m_DatabaseGUID < _Right.m_DatabaseGUID)
			return true;
		if (m_DatabaseGUID > _Right.m_DatabaseGUID)
			return false;
		if (m_Description < _Right.m_Description)
			return true;
		if (m_Description > _Right.m_Description)
			return false;
		if (m_ChannelData < _Right.m_ChannelData)
			return true;
		if (m_ChannelData > _Right.m_ChannelData)
			return false;
		if (m_Flags < _Right.m_Flags)
			return true;
		if (m_Flags > _Right.m_Flags)
			return false;
		return false;
	}
	bool operator > (const HPMCommunicationChannelProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCommunicationChannelProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCommunicationChannelProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCommunicationChannelEnum
{
	public:
	std::vector<HPMCommunicationChannelProperties> m_Channels;
	HPMCommunicationChannelEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCommunicationChannelEnum(HPMCommunicationChannelEnum const &_Right)
		: m_Channels(_Right.m_Channels)
	{
	}
	HPMCommunicationChannelEnum(HPMCommunicationChannelEnum &&_Right)
		: m_Channels(std::move(_Right.m_Channels))
	{
	}
	HPMCommunicationChannelEnum &operator =(HPMCommunicationChannelEnum const &_Right)
	{
		m_Channels = _Right.m_Channels;
		return *this;
	}
	HPMCommunicationChannelEnum &operator =(HPMCommunicationChannelEnum &&_Right)
	{
		m_Channels = std::move(_Right.m_Channels);
		return *this;
	}
#endif
	bool operator == (const HPMCommunicationChannelEnum &_Right) const
	{
		if (m_Channels.size() != _Right.m_Channels.size())
			return false;
		for (size_t i = 0; i < m_Channels.size(); ++i)
			if (m_Channels[i] != _Right.m_Channels[i])
				return false;
		return true;
	}
	bool operator != (const HPMCommunicationChannelEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCommunicationChannelEnum &_Right) const
	{
		if (m_Channels.size() < _Right.m_Channels.size())
			return true;
		if (m_Channels.size() > _Right.m_Channels.size())
			return false;
		for (size_t i = 0; i < m_Channels.size(); ++i)
		{
			if (m_Channels[i] < _Right.m_Channels[i])
				return true;
			if (m_Channels[i] > _Right.m_Channels[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCommunicationChannelEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCommunicationChannelEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCommunicationChannelEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCredentialResolutionSessionIDsEnum
{
	public:
	std::vector<HPMUInt64> m_SessionIDs;
	HPMCredentialResolutionSessionIDsEnum()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCredentialResolutionSessionIDsEnum(HPMCredentialResolutionSessionIDsEnum const &_Right)
		: m_SessionIDs(_Right.m_SessionIDs)
	{
	}
	HPMCredentialResolutionSessionIDsEnum(HPMCredentialResolutionSessionIDsEnum &&_Right)
		: m_SessionIDs(std::move(_Right.m_SessionIDs))
	{
	}
	HPMCredentialResolutionSessionIDsEnum &operator =(HPMCredentialResolutionSessionIDsEnum const &_Right)
	{
		m_SessionIDs = _Right.m_SessionIDs;
		return *this;
	}
	HPMCredentialResolutionSessionIDsEnum &operator =(HPMCredentialResolutionSessionIDsEnum &&_Right)
	{
		m_SessionIDs = std::move(_Right.m_SessionIDs);
		return *this;
	}
#endif
	bool operator == (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		if (m_SessionIDs.size() != _Right.m_SessionIDs.size())
			return false;
		for (size_t i = 0; i < m_SessionIDs.size(); ++i)
			if (m_SessionIDs[i] != _Right.m_SessionIDs[i])
				return false;
		return true;
	}
	bool operator != (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		if (m_SessionIDs.size() < _Right.m_SessionIDs.size())
			return true;
		if (m_SessionIDs.size() > _Right.m_SessionIDs.size())
			return false;
		for (size_t i = 0; i < m_SessionIDs.size(); ++i)
		{
			if (m_SessionIDs[i] < _Right.m_SessionIDs[i])
				return true;
			if (m_SessionIDs[i] > _Right.m_SessionIDs[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCredentialResolutionSessionIDsEnum &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCertificateData
{
	public:
	std::vector<HPMUInt8> m_Bytes;
	HPMCertificateData()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCertificateData(HPMCertificateData const &_Right)
		: m_Bytes(_Right.m_Bytes)
	{
	}
	HPMCertificateData(HPMCertificateData &&_Right)
		: m_Bytes(std::move(_Right.m_Bytes))
	{
	}
	HPMCertificateData &operator =(HPMCertificateData const &_Right)
	{
		m_Bytes = _Right.m_Bytes;
		return *this;
	}
	HPMCertificateData &operator =(HPMCertificateData &&_Right)
	{
		m_Bytes = std::move(_Right.m_Bytes);
		return *this;
	}
#endif
	bool operator == (const HPMCertificateData &_Right) const
	{
		if (m_Bytes.size() != _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
			if (m_Bytes[i] != _Right.m_Bytes[i])
				return false;
		return true;
	}
	bool operator != (const HPMCertificateData &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCertificateData &_Right) const
	{
		if (m_Bytes.size() < _Right.m_Bytes.size())
			return true;
		if (m_Bytes.size() > _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
		{
			if (m_Bytes[i] < _Right.m_Bytes[i])
				return true;
			if (m_Bytes[i] > _Right.m_Bytes[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMCertificateData &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCertificateData &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCertificateData &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCertificateSettings
{
	public:
	EHPMCertificateVerificationFlag m_VerificationFlags;
	HPMCertificateData m_PublicCertificateData;
	HPMCertificateData m_PrivateKeyData;
	HPMCertificateData m_CRLData;
	HPMCertificateData m_CACertificateData;
	HPMString m_CAStoreLocation;
	HPMString m_PathToCRLs;
	HPMInt32 m_VerificationDepth;
	HPMCertificateSettings()
		: m_VerificationFlags(EHPMCertificateVerificationFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCertificateSettings(HPMCertificateSettings const &_Right)
		: m_VerificationFlags(_Right.m_VerificationFlags)
		, m_PublicCertificateData(_Right.m_PublicCertificateData)
		, m_PrivateKeyData(_Right.m_PrivateKeyData)
		, m_CRLData(_Right.m_CRLData)
		, m_CACertificateData(_Right.m_CACertificateData)
		, m_CAStoreLocation(_Right.m_CAStoreLocation)
		, m_PathToCRLs(_Right.m_PathToCRLs)
		, m_VerificationDepth(_Right.m_VerificationDepth)
	{
	}
	HPMCertificateSettings(HPMCertificateSettings &&_Right)
		: m_VerificationFlags(std::move(_Right.m_VerificationFlags))
		, m_PublicCertificateData(std::move(_Right.m_PublicCertificateData))
		, m_PrivateKeyData(std::move(_Right.m_PrivateKeyData))
		, m_CRLData(std::move(_Right.m_CRLData))
		, m_CACertificateData(std::move(_Right.m_CACertificateData))
		, m_CAStoreLocation(std::move(_Right.m_CAStoreLocation))
		, m_PathToCRLs(std::move(_Right.m_PathToCRLs))
		, m_VerificationDepth(std::move(_Right.m_VerificationDepth))
	{
	}
	HPMCertificateSettings &operator =(HPMCertificateSettings const &_Right)
	{
		m_VerificationFlags = _Right.m_VerificationFlags;
		m_PublicCertificateData = _Right.m_PublicCertificateData;
		m_PrivateKeyData = _Right.m_PrivateKeyData;
		m_CRLData = _Right.m_CRLData;
		m_CACertificateData = _Right.m_CACertificateData;
		m_CAStoreLocation = _Right.m_CAStoreLocation;
		m_PathToCRLs = _Right.m_PathToCRLs;
		m_VerificationDepth = _Right.m_VerificationDepth;
		return *this;
	}
	HPMCertificateSettings &operator =(HPMCertificateSettings &&_Right)
	{
		m_VerificationFlags = std::move(_Right.m_VerificationFlags);
		m_PublicCertificateData = std::move(_Right.m_PublicCertificateData);
		m_PrivateKeyData = std::move(_Right.m_PrivateKeyData);
		m_CRLData = std::move(_Right.m_CRLData);
		m_CACertificateData = std::move(_Right.m_CACertificateData);
		m_CAStoreLocation = std::move(_Right.m_CAStoreLocation);
		m_PathToCRLs = std::move(_Right.m_PathToCRLs);
		m_VerificationDepth = std::move(_Right.m_VerificationDepth);
		return *this;
	}
#endif
	bool operator == (const HPMCertificateSettings &_Right) const
	{
		if (m_VerificationFlags != _Right.m_VerificationFlags)
			return false;
		if (m_PublicCertificateData != _Right.m_PublicCertificateData)
			return false;
		if (m_PrivateKeyData != _Right.m_PrivateKeyData)
			return false;
		if (m_CRLData != _Right.m_CRLData)
			return false;
		if (m_CACertificateData != _Right.m_CACertificateData)
			return false;
		if (m_CAStoreLocation != _Right.m_CAStoreLocation)
			return false;
		if (m_PathToCRLs != _Right.m_PathToCRLs)
			return false;
		if (m_VerificationDepth != _Right.m_VerificationDepth)
			return false;
		return true;
	}
	bool operator != (const HPMCertificateSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCertificateSettings &_Right) const
	{
		if (m_VerificationFlags < _Right.m_VerificationFlags)
			return true;
		if (m_VerificationFlags > _Right.m_VerificationFlags)
			return false;
		if (m_PublicCertificateData < _Right.m_PublicCertificateData)
			return true;
		if (m_PublicCertificateData > _Right.m_PublicCertificateData)
			return false;
		if (m_PrivateKeyData < _Right.m_PrivateKeyData)
			return true;
		if (m_PrivateKeyData > _Right.m_PrivateKeyData)
			return false;
		if (m_CRLData < _Right.m_CRLData)
			return true;
		if (m_CRLData > _Right.m_CRLData)
			return false;
		if (m_CACertificateData < _Right.m_CACertificateData)
			return true;
		if (m_CACertificateData > _Right.m_CACertificateData)
			return false;
		if (m_CAStoreLocation < _Right.m_CAStoreLocation)
			return true;
		if (m_CAStoreLocation > _Right.m_CAStoreLocation)
			return false;
		if (m_PathToCRLs < _Right.m_PathToCRLs)
			return true;
		if (m_PathToCRLs > _Right.m_PathToCRLs)
			return false;
		if (m_VerificationDepth < _Right.m_VerificationDepth)
			return true;
		if (m_VerificationDepth > _Right.m_VerificationDepth)
			return false;
		return false;
	}
	bool operator > (const HPMCertificateSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCertificateSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCertificateSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDataHistory
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMDataHistory *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMDataHistory *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	std::vector<HPMDataHistoryEntry> m_HistoryEntries;
	HPMDataHistoryTimePosition m_Delivered;
	HPMDataHistoryTimePosition m_Earliest;
	HPMDataHistoryTimePosition m_Latests;
	HPMDataHistory()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDataHistory(HPMDataHistory const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
		, m_HistoryEntries(_Right.m_HistoryEntries)
		, m_Delivered(_Right.m_Delivered)
		, m_Earliest(_Right.m_Earliest)
		, m_Latests(_Right.m_Latests)
	{
	}
	HPMDataHistory(HPMDataHistory &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
		, m_HistoryEntries(std::move(_Right.m_HistoryEntries))
		, m_Delivered(std::move(_Right.m_Delivered))
		, m_Earliest(std::move(_Right.m_Earliest))
		, m_Latests(std::move(_Right.m_Latests))
	{
	}
	HPMDataHistory &operator =(HPMDataHistory const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		m_HistoryEntries = _Right.m_HistoryEntries;
		m_Delivered = _Right.m_Delivered;
		m_Earliest = _Right.m_Earliest;
		m_Latests = _Right.m_Latests;
		return *this;
	}
	HPMDataHistory &operator =(HPMDataHistory &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		m_HistoryEntries = std::move(_Right.m_HistoryEntries);
		m_Delivered = std::move(_Right.m_Delivered);
		m_Earliest = std::move(_Right.m_Earliest);
		m_Latests = std::move(_Right.m_Latests);
		return *this;
	}
#endif
	bool operator == (const HPMDataHistory &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		if (m_HistoryEntries.size() != _Right.m_HistoryEntries.size())
			return false;
		for (size_t i = 0; i < m_HistoryEntries.size(); ++i)
			if (m_HistoryEntries[i] != _Right.m_HistoryEntries[i])
				return false;
		if (m_Delivered != _Right.m_Delivered)
			return false;
		if (m_Earliest != _Right.m_Earliest)
			return false;
		if (m_Latests != _Right.m_Latests)
			return false;
		return true;
	}
	bool operator != (const HPMDataHistory &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDataHistory &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		if (m_HistoryEntries.size() < _Right.m_HistoryEntries.size())
			return true;
		if (m_HistoryEntries.size() > _Right.m_HistoryEntries.size())
			return false;
		for (size_t i = 0; i < m_HistoryEntries.size(); ++i)
		{
			if (m_HistoryEntries[i] < _Right.m_HistoryEntries[i])
				return true;
			if (m_HistoryEntries[i] > _Right.m_HistoryEntries[i])
				return false;
		}
		if (m_Delivered < _Right.m_Delivered)
			return true;
		if (m_Delivered > _Right.m_Delivered)
			return false;
		if (m_Earliest < _Right.m_Earliest)
			return true;
		if (m_Earliest > _Right.m_Earliest)
			return false;
		if (m_Latests < _Right.m_Latests)
			return true;
		if (m_Latests > _Right.m_Latests)
			return false;
		return false;
	}
	bool operator > (const HPMDataHistory &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDataHistory &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDataHistory &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMCustomTaskStatusDialogValues
{
	public:
	HPMUntranslatedString m_Title;
	HPMUntranslatedString m_InfoText;
	HPMUntranslatedString m_ButtonLabel;
	HPMUntranslatedString m_CancelLabel;
	HPMUntranslatedString m_SelectionActionText;
	HPMUntranslatedString m_OptionalTextHeading;
	HPMString m_OptionalText;
	HPMCustomTaskStatusDialogValues()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMCustomTaskStatusDialogValues(HPMCustomTaskStatusDialogValues const &_Right)
		: m_Title(_Right.m_Title)
		, m_InfoText(_Right.m_InfoText)
		, m_ButtonLabel(_Right.m_ButtonLabel)
		, m_CancelLabel(_Right.m_CancelLabel)
		, m_SelectionActionText(_Right.m_SelectionActionText)
		, m_OptionalTextHeading(_Right.m_OptionalTextHeading)
		, m_OptionalText(_Right.m_OptionalText)
	{
	}
	HPMCustomTaskStatusDialogValues(HPMCustomTaskStatusDialogValues &&_Right)
		: m_Title(std::move(_Right.m_Title))
		, m_InfoText(std::move(_Right.m_InfoText))
		, m_ButtonLabel(std::move(_Right.m_ButtonLabel))
		, m_CancelLabel(std::move(_Right.m_CancelLabel))
		, m_SelectionActionText(std::move(_Right.m_SelectionActionText))
		, m_OptionalTextHeading(std::move(_Right.m_OptionalTextHeading))
		, m_OptionalText(std::move(_Right.m_OptionalText))
	{
	}
	HPMCustomTaskStatusDialogValues &operator =(HPMCustomTaskStatusDialogValues const &_Right)
	{
		m_Title = _Right.m_Title;
		m_InfoText = _Right.m_InfoText;
		m_ButtonLabel = _Right.m_ButtonLabel;
		m_CancelLabel = _Right.m_CancelLabel;
		m_SelectionActionText = _Right.m_SelectionActionText;
		m_OptionalTextHeading = _Right.m_OptionalTextHeading;
		m_OptionalText = _Right.m_OptionalText;
		return *this;
	}
	HPMCustomTaskStatusDialogValues &operator =(HPMCustomTaskStatusDialogValues &&_Right)
	{
		m_Title = std::move(_Right.m_Title);
		m_InfoText = std::move(_Right.m_InfoText);
		m_ButtonLabel = std::move(_Right.m_ButtonLabel);
		m_CancelLabel = std::move(_Right.m_CancelLabel);
		m_SelectionActionText = std::move(_Right.m_SelectionActionText);
		m_OptionalTextHeading = std::move(_Right.m_OptionalTextHeading);
		m_OptionalText = std::move(_Right.m_OptionalText);
		return *this;
	}
#endif
	bool operator == (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		if (m_Title != _Right.m_Title)
			return false;
		if (m_InfoText != _Right.m_InfoText)
			return false;
		if (m_ButtonLabel != _Right.m_ButtonLabel)
			return false;
		if (m_CancelLabel != _Right.m_CancelLabel)
			return false;
		if (m_SelectionActionText != _Right.m_SelectionActionText)
			return false;
		if (m_OptionalTextHeading != _Right.m_OptionalTextHeading)
			return false;
		if (m_OptionalText != _Right.m_OptionalText)
			return false;
		return true;
	}
	bool operator != (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		if (m_Title < _Right.m_Title)
			return true;
		if (m_Title > _Right.m_Title)
			return false;
		if (m_InfoText < _Right.m_InfoText)
			return true;
		if (m_InfoText > _Right.m_InfoText)
			return false;
		if (m_ButtonLabel < _Right.m_ButtonLabel)
			return true;
		if (m_ButtonLabel > _Right.m_ButtonLabel)
			return false;
		if (m_CancelLabel < _Right.m_CancelLabel)
			return true;
		if (m_CancelLabel > _Right.m_CancelLabel)
			return false;
		if (m_SelectionActionText < _Right.m_SelectionActionText)
			return true;
		if (m_SelectionActionText > _Right.m_SelectionActionText)
			return false;
		if (m_OptionalTextHeading < _Right.m_OptionalTextHeading)
			return true;
		if (m_OptionalTextHeading > _Right.m_OptionalTextHeading)
			return false;
		if (m_OptionalText < _Right.m_OptionalText)
			return true;
		if (m_OptionalText > _Right.m_OptionalText)
			return false;
		return false;
	}
	bool operator > (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMCustomTaskStatusDialogValues &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMSessionInfo
{
	public:
	HPMString m_Address;
	HPMInt32 m_Port;
	HPMString m_Database;
	HPMString m_ResourceName;
	HPMUInt64 m_SessionID;
	HPMSessionInfo()
		: m_Port(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMSessionInfo(HPMSessionInfo const &_Right)
		: m_Address(_Right.m_Address)
		, m_Port(_Right.m_Port)
		, m_Database(_Right.m_Database)
		, m_ResourceName(_Right.m_ResourceName)
		, m_SessionID(_Right.m_SessionID)
	{
	}
	HPMSessionInfo(HPMSessionInfo &&_Right)
		: m_Address(std::move(_Right.m_Address))
		, m_Port(std::move(_Right.m_Port))
		, m_Database(std::move(_Right.m_Database))
		, m_ResourceName(std::move(_Right.m_ResourceName))
		, m_SessionID(std::move(_Right.m_SessionID))
	{
	}
	HPMSessionInfo &operator =(HPMSessionInfo const &_Right)
	{
		m_Address = _Right.m_Address;
		m_Port = _Right.m_Port;
		m_Database = _Right.m_Database;
		m_ResourceName = _Right.m_ResourceName;
		m_SessionID = _Right.m_SessionID;
		return *this;
	}
	HPMSessionInfo &operator =(HPMSessionInfo &&_Right)
	{
		m_Address = std::move(_Right.m_Address);
		m_Port = std::move(_Right.m_Port);
		m_Database = std::move(_Right.m_Database);
		m_ResourceName = std::move(_Right.m_ResourceName);
		m_SessionID = std::move(_Right.m_SessionID);
		return *this;
	}
#endif
	bool operator == (const HPMSessionInfo &_Right) const
	{
		if (m_Address != _Right.m_Address)
			return false;
		if (m_Port != _Right.m_Port)
			return false;
		if (m_Database != _Right.m_Database)
			return false;
		if (m_ResourceName != _Right.m_ResourceName)
			return false;
		if (m_SessionID != _Right.m_SessionID)
			return false;
		return true;
	}
	bool operator != (const HPMSessionInfo &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMSessionInfo &_Right) const
	{
		if (m_Address < _Right.m_Address)
			return true;
		if (m_Address > _Right.m_Address)
			return false;
		if (m_Port < _Right.m_Port)
			return true;
		if (m_Port > _Right.m_Port)
			return false;
		if (m_Database < _Right.m_Database)
			return true;
		if (m_Database > _Right.m_Database)
			return false;
		if (m_ResourceName < _Right.m_ResourceName)
			return true;
		if (m_ResourceName > _Right.m_ResourceName)
			return false;
		if (m_SessionID < _Right.m_SessionID)
			return true;
		if (m_SessionID > _Right.m_SessionID)
			return false;
		return false;
	}
	bool operator > (const HPMSessionInfo &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMSessionInfo &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMSessionInfo &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMSessionLock
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMSessionLock *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMSessionLock *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMSessionLock()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMSessionLock(HPMSessionLock const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMSessionLock(HPMSessionLock &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMSessionLock &operator =(HPMSessionLock const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMSessionLock &operator =(HPMSessionLock &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMSessionLock &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMSessionLock &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMSessionLock &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMSessionLock &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMSessionLock &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMSessionLock &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMAuthenticationLoginNameEntry
{
	public:
	HPMString m_DisplayName;
	EHPMAuthenticationLoginNameFlag m_NameFlags;
	HPMAuthenticationLoginNameEntry()
		: m_NameFlags(EHPMAuthenticationLoginNameFlag_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMAuthenticationLoginNameEntry(HPMAuthenticationLoginNameEntry const &_Right)
		: m_DisplayName(_Right.m_DisplayName)
		, m_NameFlags(_Right.m_NameFlags)
	{
	}
	HPMAuthenticationLoginNameEntry(HPMAuthenticationLoginNameEntry &&_Right)
		: m_DisplayName(std::move(_Right.m_DisplayName))
		, m_NameFlags(std::move(_Right.m_NameFlags))
	{
	}
	HPMAuthenticationLoginNameEntry &operator =(HPMAuthenticationLoginNameEntry const &_Right)
	{
		m_DisplayName = _Right.m_DisplayName;
		m_NameFlags = _Right.m_NameFlags;
		return *this;
	}
	HPMAuthenticationLoginNameEntry &operator =(HPMAuthenticationLoginNameEntry &&_Right)
	{
		m_DisplayName = std::move(_Right.m_DisplayName);
		m_NameFlags = std::move(_Right.m_NameFlags);
		return *this;
	}
#endif
	bool operator == (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		if (m_DisplayName != _Right.m_DisplayName)
			return false;
		if (m_NameFlags != _Right.m_NameFlags)
			return false;
		return true;
	}
	bool operator != (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		if (m_DisplayName < _Right.m_DisplayName)
			return true;
		if (m_DisplayName > _Right.m_DisplayName)
			return false;
		if (m_NameFlags < _Right.m_NameFlags)
			return true;
		if (m_NameFlags > _Right.m_NameFlags)
			return false;
		return false;
	}
	bool operator > (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMAuthenticationLoginNameEntry &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMAuthenticationClientPluginProperties
{
	public:
	HPMString m_Name;
	std::vector<HPMAuthenticationLoginNameEntry> m_LoginNames;
	HPMUntranslatedString m_NoPasswordText;
	HPMAuthenticationClientPluginProperties()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMAuthenticationClientPluginProperties(HPMAuthenticationClientPluginProperties const &_Right)
		: m_Name(_Right.m_Name)
		, m_LoginNames(_Right.m_LoginNames)
		, m_NoPasswordText(_Right.m_NoPasswordText)
	{
	}
	HPMAuthenticationClientPluginProperties(HPMAuthenticationClientPluginProperties &&_Right)
		: m_Name(std::move(_Right.m_Name))
		, m_LoginNames(std::move(_Right.m_LoginNames))
		, m_NoPasswordText(std::move(_Right.m_NoPasswordText))
	{
	}
	HPMAuthenticationClientPluginProperties &operator =(HPMAuthenticationClientPluginProperties const &_Right)
	{
		m_Name = _Right.m_Name;
		m_LoginNames = _Right.m_LoginNames;
		m_NoPasswordText = _Right.m_NoPasswordText;
		return *this;
	}
	HPMAuthenticationClientPluginProperties &operator =(HPMAuthenticationClientPluginProperties &&_Right)
	{
		m_Name = std::move(_Right.m_Name);
		m_LoginNames = std::move(_Right.m_LoginNames);
		m_NoPasswordText = std::move(_Right.m_NoPasswordText);
		return *this;
	}
#endif
	bool operator == (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		if (m_Name != _Right.m_Name)
			return false;
		if (m_LoginNames.size() != _Right.m_LoginNames.size())
			return false;
		for (size_t i = 0; i < m_LoginNames.size(); ++i)
			if (m_LoginNames[i] != _Right.m_LoginNames[i])
				return false;
		if (m_NoPasswordText != _Right.m_NoPasswordText)
			return false;
		return true;
	}
	bool operator != (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_LoginNames.size() < _Right.m_LoginNames.size())
			return true;
		if (m_LoginNames.size() > _Right.m_LoginNames.size())
			return false;
		for (size_t i = 0; i < m_LoginNames.size(); ++i)
		{
			if (m_LoginNames[i] < _Right.m_LoginNames[i])
				return true;
			if (m_LoginNames[i] > _Right.m_LoginNames[i])
				return false;
		}
		if (m_NoPasswordText < _Right.m_NoPasswordText)
			return true;
		if (m_NoPasswordText > _Right.m_NoPasswordText)
			return false;
		return false;
	}
	bool operator > (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMAuthenticationClientPluginProperties &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMAuthenticationSessionKey
{
	public:
	std::vector<HPMUInt8> m_Bytes;
	HPMAuthenticationSessionKey()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMAuthenticationSessionKey(HPMAuthenticationSessionKey const &_Right)
		: m_Bytes(_Right.m_Bytes)
	{
	}
	HPMAuthenticationSessionKey(HPMAuthenticationSessionKey &&_Right)
		: m_Bytes(std::move(_Right.m_Bytes))
	{
	}
	HPMAuthenticationSessionKey &operator =(HPMAuthenticationSessionKey const &_Right)
	{
		m_Bytes = _Right.m_Bytes;
		return *this;
	}
	HPMAuthenticationSessionKey &operator =(HPMAuthenticationSessionKey &&_Right)
	{
		m_Bytes = std::move(_Right.m_Bytes);
		return *this;
	}
#endif
	bool operator == (const HPMAuthenticationSessionKey &_Right) const
	{
		if (m_Bytes.size() != _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
			if (m_Bytes[i] != _Right.m_Bytes[i])
				return false;
		return true;
	}
	bool operator != (const HPMAuthenticationSessionKey &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMAuthenticationSessionKey &_Right) const
	{
		if (m_Bytes.size() < _Right.m_Bytes.size())
			return true;
		if (m_Bytes.size() > _Right.m_Bytes.size())
			return false;
		for (size_t i = 0; i < m_Bytes.size(); ++i)
		{
			if (m_Bytes[i] < _Right.m_Bytes[i])
				return true;
			if (m_Bytes[i] > _Right.m_Bytes[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMAuthenticationSessionKey &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMAuthenticationSessionKey &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMAuthenticationSessionKey &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMAuthenticationErrorDescription
{
	public:
	HPMUntranslatedString m_Origin;
	HPMUntranslatedString m_ErrorText;
	HPMAuthenticationErrorDescription()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMAuthenticationErrorDescription(HPMAuthenticationErrorDescription const &_Right)
		: m_Origin(_Right.m_Origin)
		, m_ErrorText(_Right.m_ErrorText)
	{
	}
	HPMAuthenticationErrorDescription(HPMAuthenticationErrorDescription &&_Right)
		: m_Origin(std::move(_Right.m_Origin))
		, m_ErrorText(std::move(_Right.m_ErrorText))
	{
	}
	HPMAuthenticationErrorDescription &operator =(HPMAuthenticationErrorDescription const &_Right)
	{
		m_Origin = _Right.m_Origin;
		m_ErrorText = _Right.m_ErrorText;
		return *this;
	}
	HPMAuthenticationErrorDescription &operator =(HPMAuthenticationErrorDescription &&_Right)
	{
		m_Origin = std::move(_Right.m_Origin);
		m_ErrorText = std::move(_Right.m_ErrorText);
		return *this;
	}
#endif
	bool operator == (const HPMAuthenticationErrorDescription &_Right) const
	{
		if (m_Origin != _Right.m_Origin)
			return false;
		if (m_ErrorText != _Right.m_ErrorText)
			return false;
		return true;
	}
	bool operator != (const HPMAuthenticationErrorDescription &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMAuthenticationErrorDescription &_Right) const
	{
		if (m_Origin < _Right.m_Origin)
			return true;
		if (m_Origin > _Right.m_Origin)
			return false;
		if (m_ErrorText < _Right.m_ErrorText)
			return true;
		if (m_ErrorText > _Right.m_ErrorText)
			return false;
		return false;
	}
	bool operator > (const HPMAuthenticationErrorDescription &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMAuthenticationErrorDescription &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMAuthenticationErrorDescription &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMAuthenticationErrorDescriptions
{
	public:
	std::vector<HPMAuthenticationErrorDescription> m_Descriptions;
	HPMAuthenticationErrorDescriptions()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMAuthenticationErrorDescriptions(HPMAuthenticationErrorDescriptions const &_Right)
		: m_Descriptions(_Right.m_Descriptions)
	{
	}
	HPMAuthenticationErrorDescriptions(HPMAuthenticationErrorDescriptions &&_Right)
		: m_Descriptions(std::move(_Right.m_Descriptions))
	{
	}
	HPMAuthenticationErrorDescriptions &operator =(HPMAuthenticationErrorDescriptions const &_Right)
	{
		m_Descriptions = _Right.m_Descriptions;
		return *this;
	}
	HPMAuthenticationErrorDescriptions &operator =(HPMAuthenticationErrorDescriptions &&_Right)
	{
		m_Descriptions = std::move(_Right.m_Descriptions);
		return *this;
	}
#endif
	bool operator == (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		if (m_Descriptions.size() != _Right.m_Descriptions.size())
			return false;
		for (size_t i = 0; i < m_Descriptions.size(); ++i)
			if (m_Descriptions[i] != _Right.m_Descriptions[i])
				return false;
		return true;
	}
	bool operator != (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		if (m_Descriptions.size() < _Right.m_Descriptions.size())
			return true;
		if (m_Descriptions.size() > _Right.m_Descriptions.size())
			return false;
		for (size_t i = 0; i < m_Descriptions.size(); ++i)
		{
			if (m_Descriptions[i] < _Right.m_Descriptions[i])
				return true;
			if (m_Descriptions[i] > _Right.m_Descriptions[i])
				return false;
		}
		return false;
	}
	bool operator > (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMAuthenticationErrorDescriptions &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMGlobalStatisticsSettings
{
	public:
	HPMUInt32 m_SamplingFrequency;
	HPMUInt32 m_SecondOfDaySample;
	HPMUInt32 m_SamplingFrequencyResource;
	HPMUInt32 m_SecondOfDaySampleResource;
	HPMUInt32 m_SamplingFrequencyResourceGroup;
	HPMUInt32 m_SecondOfDaySampleResourceGroup;
	HPMGlobalStatisticsSettings()
		: m_SamplingFrequency(86400)
		, m_SecondOfDaySample(0)
		, m_SamplingFrequencyResource(86400)
		, m_SecondOfDaySampleResource(0)
		, m_SamplingFrequencyResourceGroup(86400)
		, m_SecondOfDaySampleResourceGroup(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMGlobalStatisticsSettings(HPMGlobalStatisticsSettings const &_Right)
		: m_SamplingFrequency(_Right.m_SamplingFrequency)
		, m_SecondOfDaySample(_Right.m_SecondOfDaySample)
		, m_SamplingFrequencyResource(_Right.m_SamplingFrequencyResource)
		, m_SecondOfDaySampleResource(_Right.m_SecondOfDaySampleResource)
		, m_SamplingFrequencyResourceGroup(_Right.m_SamplingFrequencyResourceGroup)
		, m_SecondOfDaySampleResourceGroup(_Right.m_SecondOfDaySampleResourceGroup)
	{
	}
	HPMGlobalStatisticsSettings(HPMGlobalStatisticsSettings &&_Right)
		: m_SamplingFrequency(std::move(_Right.m_SamplingFrequency))
		, m_SecondOfDaySample(std::move(_Right.m_SecondOfDaySample))
		, m_SamplingFrequencyResource(std::move(_Right.m_SamplingFrequencyResource))
		, m_SecondOfDaySampleResource(std::move(_Right.m_SecondOfDaySampleResource))
		, m_SamplingFrequencyResourceGroup(std::move(_Right.m_SamplingFrequencyResourceGroup))
		, m_SecondOfDaySampleResourceGroup(std::move(_Right.m_SecondOfDaySampleResourceGroup))
	{
	}
	HPMGlobalStatisticsSettings &operator =(HPMGlobalStatisticsSettings const &_Right)
	{
		m_SamplingFrequency = _Right.m_SamplingFrequency;
		m_SecondOfDaySample = _Right.m_SecondOfDaySample;
		m_SamplingFrequencyResource = _Right.m_SamplingFrequencyResource;
		m_SecondOfDaySampleResource = _Right.m_SecondOfDaySampleResource;
		m_SamplingFrequencyResourceGroup = _Right.m_SamplingFrequencyResourceGroup;
		m_SecondOfDaySampleResourceGroup = _Right.m_SecondOfDaySampleResourceGroup;
		return *this;
	}
	HPMGlobalStatisticsSettings &operator =(HPMGlobalStatisticsSettings &&_Right)
	{
		m_SamplingFrequency = std::move(_Right.m_SamplingFrequency);
		m_SecondOfDaySample = std::move(_Right.m_SecondOfDaySample);
		m_SamplingFrequencyResource = std::move(_Right.m_SamplingFrequencyResource);
		m_SecondOfDaySampleResource = std::move(_Right.m_SecondOfDaySampleResource);
		m_SamplingFrequencyResourceGroup = std::move(_Right.m_SamplingFrequencyResourceGroup);
		m_SecondOfDaySampleResourceGroup = std::move(_Right.m_SecondOfDaySampleResourceGroup);
		return *this;
	}
#endif
	bool operator == (const HPMGlobalStatisticsSettings &_Right) const
	{
		if (m_SamplingFrequency != _Right.m_SamplingFrequency)
			return false;
		if (m_SecondOfDaySample != _Right.m_SecondOfDaySample)
			return false;
		if (m_SamplingFrequencyResource != _Right.m_SamplingFrequencyResource)
			return false;
		if (m_SecondOfDaySampleResource != _Right.m_SecondOfDaySampleResource)
			return false;
		if (m_SamplingFrequencyResourceGroup != _Right.m_SamplingFrequencyResourceGroup)
			return false;
		if (m_SecondOfDaySampleResourceGroup != _Right.m_SecondOfDaySampleResourceGroup)
			return false;
		return true;
	}
	bool operator != (const HPMGlobalStatisticsSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMGlobalStatisticsSettings &_Right) const
	{
		if (m_SamplingFrequency < _Right.m_SamplingFrequency)
			return true;
		if (m_SamplingFrequency > _Right.m_SamplingFrequency)
			return false;
		if (m_SecondOfDaySample < _Right.m_SecondOfDaySample)
			return true;
		if (m_SecondOfDaySample > _Right.m_SecondOfDaySample)
			return false;
		if (m_SamplingFrequencyResource < _Right.m_SamplingFrequencyResource)
			return true;
		if (m_SamplingFrequencyResource > _Right.m_SamplingFrequencyResource)
			return false;
		if (m_SecondOfDaySampleResource < _Right.m_SecondOfDaySampleResource)
			return true;
		if (m_SecondOfDaySampleResource > _Right.m_SecondOfDaySampleResource)
			return false;
		if (m_SamplingFrequencyResourceGroup < _Right.m_SamplingFrequencyResourceGroup)
			return true;
		if (m_SamplingFrequencyResourceGroup > _Right.m_SamplingFrequencyResourceGroup)
			return false;
		if (m_SecondOfDaySampleResourceGroup < _Right.m_SecondOfDaySampleResourceGroup)
			return true;
		if (m_SecondOfDaySampleResourceGroup > _Right.m_SecondOfDaySampleResourceGroup)
			return false;
		return false;
	}
	bool operator > (const HPMGlobalStatisticsSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMGlobalStatisticsSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMGlobalStatisticsSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMGlobalEmailSettings
{
	public:
	HPMString m_Server;
	HPMInt32 m_Port;
	HPMString m_Name;
	HPMString m_Email;
	bool m_bAuthentication;
	HPMString m_UserName;
	HPMString m_UserPassword;
	EHPMEmailSecurityProtocol m_SecurityProtocol;
	HPMGlobalEmailSettings()
		: m_Port(25)
		, m_bAuthentication(0)
		, m_SecurityProtocol(EHPMEmailSecurityProtocol_None)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMGlobalEmailSettings(HPMGlobalEmailSettings const &_Right)
		: m_Server(_Right.m_Server)
		, m_Port(_Right.m_Port)
		, m_Name(_Right.m_Name)
		, m_Email(_Right.m_Email)
		, m_bAuthentication(_Right.m_bAuthentication)
		, m_UserName(_Right.m_UserName)
		, m_UserPassword(_Right.m_UserPassword)
		, m_SecurityProtocol(_Right.m_SecurityProtocol)
	{
	}
	HPMGlobalEmailSettings(HPMGlobalEmailSettings &&_Right)
		: m_Server(std::move(_Right.m_Server))
		, m_Port(std::move(_Right.m_Port))
		, m_Name(std::move(_Right.m_Name))
		, m_Email(std::move(_Right.m_Email))
		, m_bAuthentication(std::move(_Right.m_bAuthentication))
		, m_UserName(std::move(_Right.m_UserName))
		, m_UserPassword(std::move(_Right.m_UserPassword))
		, m_SecurityProtocol(std::move(_Right.m_SecurityProtocol))
	{
	}
	HPMGlobalEmailSettings &operator =(HPMGlobalEmailSettings const &_Right)
	{
		m_Server = _Right.m_Server;
		m_Port = _Right.m_Port;
		m_Name = _Right.m_Name;
		m_Email = _Right.m_Email;
		m_bAuthentication = _Right.m_bAuthentication;
		m_UserName = _Right.m_UserName;
		m_UserPassword = _Right.m_UserPassword;
		m_SecurityProtocol = _Right.m_SecurityProtocol;
		return *this;
	}
	HPMGlobalEmailSettings &operator =(HPMGlobalEmailSettings &&_Right)
	{
		m_Server = std::move(_Right.m_Server);
		m_Port = std::move(_Right.m_Port);
		m_Name = std::move(_Right.m_Name);
		m_Email = std::move(_Right.m_Email);
		m_bAuthentication = std::move(_Right.m_bAuthentication);
		m_UserName = std::move(_Right.m_UserName);
		m_UserPassword = std::move(_Right.m_UserPassword);
		m_SecurityProtocol = std::move(_Right.m_SecurityProtocol);
		return *this;
	}
#endif
	bool operator == (const HPMGlobalEmailSettings &_Right) const
	{
		if (m_Server != _Right.m_Server)
			return false;
		if (m_Port != _Right.m_Port)
			return false;
		if (m_Name != _Right.m_Name)
			return false;
		if (m_Email != _Right.m_Email)
			return false;
		if (m_bAuthentication != _Right.m_bAuthentication)
			return false;
		if (m_UserName != _Right.m_UserName)
			return false;
		if (m_UserPassword != _Right.m_UserPassword)
			return false;
		if (m_SecurityProtocol != _Right.m_SecurityProtocol)
			return false;
		return true;
	}
	bool operator != (const HPMGlobalEmailSettings &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMGlobalEmailSettings &_Right) const
	{
		if (m_Server < _Right.m_Server)
			return true;
		if (m_Server > _Right.m_Server)
			return false;
		if (m_Port < _Right.m_Port)
			return true;
		if (m_Port > _Right.m_Port)
			return false;
		if (m_Name < _Right.m_Name)
			return true;
		if (m_Name > _Right.m_Name)
			return false;
		if (m_Email < _Right.m_Email)
			return true;
		if (m_Email > _Right.m_Email)
			return false;
		if (m_bAuthentication < _Right.m_bAuthentication)
			return true;
		if (m_bAuthentication > _Right.m_bAuthentication)
			return false;
		if (m_UserName < _Right.m_UserName)
			return true;
		if (m_UserName > _Right.m_UserName)
			return false;
		if (m_UserPassword < _Right.m_UserPassword)
			return true;
		if (m_UserPassword > _Right.m_UserPassword)
			return false;
		if (m_SecurityProtocol < _Right.m_SecurityProtocol)
			return true;
		if (m_SecurityProtocol > _Right.m_SecurityProtocol)
			return false;
		return false;
	}
	bool operator > (const HPMGlobalEmailSettings &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMGlobalEmailSettings &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMGlobalEmailSettings &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMDatabaseGUIDs
{
	public:
	HPMString m_GUID;
	HPMUInt64 m_ID64;
	HPMUInt32 m_ID32;
	HPMDatabaseGUIDs()
		: m_ID64(0)
		, m_ID32(0)
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMDatabaseGUIDs(HPMDatabaseGUIDs const &_Right)
		: m_GUID(_Right.m_GUID)
		, m_ID64(_Right.m_ID64)
		, m_ID32(_Right.m_ID32)
	{
	}
	HPMDatabaseGUIDs(HPMDatabaseGUIDs &&_Right)
		: m_GUID(std::move(_Right.m_GUID))
		, m_ID64(std::move(_Right.m_ID64))
		, m_ID32(std::move(_Right.m_ID32))
	{
	}
	HPMDatabaseGUIDs &operator =(HPMDatabaseGUIDs const &_Right)
	{
		m_GUID = _Right.m_GUID;
		m_ID64 = _Right.m_ID64;
		m_ID32 = _Right.m_ID32;
		return *this;
	}
	HPMDatabaseGUIDs &operator =(HPMDatabaseGUIDs &&_Right)
	{
		m_GUID = std::move(_Right.m_GUID);
		m_ID64 = std::move(_Right.m_ID64);
		m_ID32 = std::move(_Right.m_ID32);
		return *this;
	}
#endif
	bool operator == (const HPMDatabaseGUIDs &_Right) const
	{
		if (m_GUID != _Right.m_GUID)
			return false;
		if (m_ID64 != _Right.m_ID64)
			return false;
		if (m_ID32 != _Right.m_ID32)
			return false;
		return true;
	}
	bool operator != (const HPMDatabaseGUIDs &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMDatabaseGUIDs &_Right) const
	{
		if (m_GUID < _Right.m_GUID)
			return true;
		if (m_GUID > _Right.m_GUID)
			return false;
		if (m_ID64 < _Right.m_ID64)
			return true;
		if (m_ID64 > _Right.m_ID64)
			return false;
		if (m_ID32 < _Right.m_ID32)
			return true;
		if (m_ID32 > _Right.m_ID32)
			return false;
		return false;
	}
	bool operator > (const HPMDatabaseGUIDs &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMDatabaseGUIDs &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMDatabaseGUIDs &_Right) const
	{
		return !(*this < _Right);
	}
};

class HPMNotificationSubscription
{
	public:
	HPMHelper_RefOriginalObject m_RefOrigObject;
	void SetOriginalObject(NInternal_C::HPMSdkFunctions *_pSDKFunctions, void *_pSession, void *_pObject)
	{
		m_RefOrigObject.m_pRef = new HPMHelper_RefOriginalObjectRef(_pSDKFunctions, _pSession, _pObject);
	}
	const NInternal_C::HPMNotificationSubscription *GetOriginalObject() const
	{
		if (m_RefOrigObject.m_pRef)
			return (const NInternal_C::HPMNotificationSubscription *)m_RefOrigObject.m_pRef->m_pObject;
		return 0;
	}
	public:
	HPMNotificationSubscription()
	{
	}
#ifdef DHansoftSDKSupportMoveSemantic
	HPMNotificationSubscription(HPMNotificationSubscription const &_Right)
		: m_RefOrigObject(_Right.m_RefOrigObject)
	{
	}
	HPMNotificationSubscription(HPMNotificationSubscription &&_Right)
		: m_RefOrigObject(std::move(_Right.m_RefOrigObject))
	{
	}
	HPMNotificationSubscription &operator =(HPMNotificationSubscription const &_Right)
	{
		m_RefOrigObject = _Right.m_RefOrigObject;
		return *this;
	}
	HPMNotificationSubscription &operator =(HPMNotificationSubscription &&_Right)
	{
		m_RefOrigObject = std::move(_Right.m_RefOrigObject);
		return *this;
	}
#endif
	bool operator == (const HPMNotificationSubscription &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() != _Right.GetOriginalObject())
				return false;
		}
		else if (Return != 0)
			return false;
		return true;
	}
	bool operator != (const HPMNotificationSubscription &_Right) const
	{
		return !(*this == _Right);
	}
	bool operator < (const HPMNotificationSubscription &_Right) const
	{
		int Return = m_RefOrigObject.m_pRef->Compare(_Right.m_RefOrigObject.m_pRef->m_pObject);
		if (Return == -2)
		{
			if (GetOriginalObject() < _Right.GetOriginalObject())
				return true;
		}
		else if (Return == -1)
			return true;
		return false;
	}
	bool operator > (const HPMNotificationSubscription &_Right) const
	{
		return _Right < *this;
	}
	bool operator <= (const HPMNotificationSubscription &_Right) const
	{
		return !(_Right < *this);
	}
	bool operator >= (const HPMNotificationSubscription &_Right) const
	{
		return !(*this < _Right);
	}
};

